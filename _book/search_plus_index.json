{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2020-01-02 10:47:44 "},"data-structure/linear-list.html":{"url":"data-structure/linear-list.html","title":"线性表","keywords":"","body":"概要 线性表是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。本章先介绍线性表的几个基本组成部分：数组、单向链表、双向链表。 数组 数组有上界和下界，数组的元素在上下界内是连续的。 存储10,20,30,40,50的数组的示意图如下： 数组的特点是：数据是连续的；随机访问速度快。 数组中稍微复杂一点的是多维数组和动态数组。对于C语言而言，多维数组本质上也是通过一维数组实现的。至于动态数组，是指数组的容量能动态增长的数组；对于C语言而言，若要提供动态数组，需要手动实现；而对于C++而言，STL提供了Vector；对于Java而言，Collection集合中提供了ArrayList和Vector。 单向链表 单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。 单链表的示意图如下： 表头为空，表头的后继节点是\"节点10\"(数据为10的节点)，\"节点10\"的后继节点是\"节点20\"(数据为10的节点)，... 单链表删除节点 删除\"节点30\" 删除之前：\"节点20\" 的后继节点为\"节点30\"，而\"节点30\" 的后继节点为\"节点40\"。 删除之后：\"节点20\" 的后继节点为\"节点40\"。 单链表添加节点 在\"节点10\"与\"节点20\"之间添加\"节点15\" 添加之前：\"节点10\" 的后继节点为\"节点20\"。 添加之后：\"节点10\" 的后继节点为\"节点15\"，而\"节点15\" 的后继节点为\"节点20\"。 单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。 双向链表 双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。 双链表的示意图如下： 表头为空，表头的后继节点为\"节点10\"(数据为10的节点)；\"节点10\"的后继节点是\"节点20\"(数据为10的节点)，\"节点20\"的前继节点是\"节点10\"；\"节点20\"的后继节点是\"节点30\"，\"节点30\"的前继节点是\"节点20\"；...；末尾节点的后继节点是表头。 双链表删除节点 删除\"节点30\" 删除之前：\"节点20\"的后继节点为\"节点30\"，\"节点30\" 的前继节点为\"节点20\"。\"节点30\"的后继节点为\"节点40\"，\"节点40\" 的前继节点为\"节点30\"。 删除之后：\"节点20\"的后继节点为\"节点40\"，\"节点40\" 的前继节点为\"节点20\"。 双链表添加节点 在\"节点10\"与\"节点20\"之间添加\"节点15\" 添加之前：\"节点10\"的后继节点为\"节点20\"，\"节点20\" 的前继节点为\"节点10\"。 添加之后：\"节点10\"的后继节点为\"节点15\"，\"节点15\" 的前继节点为\"节点10\"。\"节点15\"的后继节点为\"节点20\"，\"节点20\" 的前继节点为\"节点15\"。 双链表的Java实现 /** * Java 实现的双向链表。 * 注：java自带的集合包中有实现双向链表，路径是:java.util.LinkedList * * @author skywang * @date 2013/11/07 */ public class DoubleLink { // 表头 private DNode mHead; // 节点个数 private int mCount; // 双向链表“节点”对应的结构体 private class DNode { public DNode prev; public DNode next; public T value; public DNode(T value, DNode prev, DNode next) { this.value = value; this.prev = prev; this.next = next; } } // 构造函数 public DoubleLink() { // 创建“表头”。注意：表头没有存储数据！ mHead = new DNode(null, null, null); mHead.prev = mHead.next = mHead; // 初始化“节点个数”为0 mCount = 0; } // 返回节点数目 public int size() { return mCount; } // 返回链表是否为空 public boolean isEmpty() { return mCount==0; } // 获取第index位置的节点 private DNode getNode(int index) { if (index=mCount) throw new IndexOutOfBoundsException(); // 正向查找 if (index node = mHead.next; for (int i=0; i rnode = mHead.prev; int rindex = mCount - index -1; for (int j=0; j node = new DNode(t, mHead, mHead.next); mHead.next.prev = node; mHead.next = node; mCount++; return ; } DNode inode = getNode(index); DNode tnode = new DNode(t, inode.prev, inode); inode.prev.next = tnode; inode.prev = tnode; mCount++; return ; } // 将节点插入第一个节点处。 public void insertFirst(T t) { insert(0, t); } // 将节点追加到链表的末尾 public void appendLast(T t) { DNode node = new DNode(t, mHead.prev, mHead); mHead.prev.next = node; mHead.prev = node; mCount++; } // 删除index位置的节点 public void del(int index) { DNode inode = getNode(index); inode.prev.next = inode.next; inode.next.prev = inode.prev; inode = null; mCount--; } // 删除第一个节点 public void deleteFirst() { del(0); } // 删除最后一个节点 public void deleteLast() { del(mCount-1); } } Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/stack-queue.html":{"url":"data-structure/stack-queue.html","title":"栈和队","keywords":"","body":"一、栈 栈（stack），是一种线性存储结构，它有以下几个特点： (01) 栈中数据是按照\"后进先出（LIFO, Last In First Out）\"方式进出栈的。 (02) 向栈中添加/删除数据时，只能从栈顶进行操作。 栈通常包括的三种操作：push、peek、pop。 push -- 向栈中添加元素。 peek -- 返回栈顶元素。 pop -- 返回并删除栈顶元素的操作。 1.栈的示意图 栈中的数据依次是 30 --> 20 --> 10 2.出栈 出栈前：栈顶元素是30。此时，栈中的元素依次是 30 --> 20 --> 10 出栈后：30出栈之后，栈顶元素变成20。此时，栈中的元素依次是 20 --> 10 3. 入栈 入栈前：栈顶元素是20。此时，栈中的元素依次是 20 --> 10 入栈后：40入栈之后，栈顶元素变成40。此时，栈中的元素依次是 40 --> 20 --> 10 4.栈的Java实现 JDK包中也提供了\"栈\"的实现，它就是集合框架中的Stack类。 本部分使用数组实现栈，能存储任意类型的数据。 /** * Java : 数组实现的栈，能存储任意类型的数据 * * @author skywang * @date 2013/11/07 */ import java.lang.reflect.Array; public class GeneralArrayStack { private static final int DEFAULT_SIZE = 12; private T[] mArray; private int count; public GeneralArrayStack(Class type) { this(type, DEFAULT_SIZE); } public GeneralArrayStack(Class type, int size) { // 不能直接使用mArray = new T[DEFAULT_SIZE]; mArray = (T[]) Array.newInstance(type, size); count = 0; } // 将val添加到栈中 public void push(T val) { mArray[count++] = val; } // 返回“栈顶元素值” public T peek() { return mArray[count-1]; } // 返回“栈顶元素值”，并删除“栈顶元素” public T pop() { T ret = mArray[count-1]; count--; return ret; } // 返回“栈”的大小 public int size() { return count; } // 返回“栈”是否为空 public boolean isEmpty() { return size()==0; } // 打印“栈” public void PrintArrayStack() { if (isEmpty()) { System.out.printf(\"stack is Empty\\n\"); } System.out.printf(\"stack size()=%d\\n\", size()); int i=size()-1; while (i>=0) { System.out.println(mArray[i]); i--; } } } 二、队列 队列（Queue），是一种线性存储结构。它有以下几个特点： (1) 队列中数据是按照\"先进先出（FIFO, First-In-First-Out）\"方式进出队列的。 (2) 队列只允许在\"队首\"进行删除操作，而在\"队尾\"进行插入操作。 队列通常包括的两种操作：入队列 和 出队列。 1.队列的示意图 队列中有10，20，30共3个数据。 2.出队列 出队列前：队首是10，队尾是30。 出队列后：出队列(队首)之后。队首是20，队尾是30。 3.入队列 入队列前：队首是20，队尾是30。 入队列后：40入队列(队尾)之后。队首是20，队尾是40。 4.队列的Java实现 JDK中的Queue接口就是\"队列\"，它的实现类也都是队列，用的最多的是LinkedList。本部分使用数组实现队列，能存储任意类型的数据。 /** * Java : 数组实现“队列”，只能存储int数据。 * * @author skywang * @date 2013/11/07 */ public class ArrayQueue { private int[] mArray; private int mCount; public ArrayQueue(int sz) { mArray = new int[sz]; mCount = 0; } // 将val添加到队列的末尾 public void add(int val) { mArray[mCount++] = val; } // 返回“队列开头元素” public int front() { return mArray[0]; } // 返回“队首元素值”，并删除“队首元素” public int pop() { int ret = mArray[0]; mCount--; for (int i=1; i Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/tree.html":{"url":"data-structure/tree.html","title":"树","keywords":"","body":"一、前言 树作为一种重要的数据结构，即是面试重点考察知识点，也是实际生产应用中可能会灵活应用的一种数据结构。那么其重要性不言而喻，无论是在剑指offer，还是在leetcode中，都有很多关于树的题目。 本部分内容主要介绍树的一些基础概念及Java实现，同时介绍一些常见的树，如二叉搜索树，平衡树，红黑树等。 二、目录 树的基础 其他常见的树 并查集 B-树，B+树，B*树 Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/tree/tree-introduction.html":{"url":"data-structure/tree/tree-introduction.html","title":"树的基础","keywords":"","body":"一、树的介绍 1.树的定义 树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。 把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： (01) 每个节点有零个或多个子节点； (02) 没有父节点的节点称为根节点； (03) 每一个非根节点有且只有一个父节点； (04) 除了根节点外，每个子节点可以分为多个不相交的子树。 2.树的基本术语 若一个结点有子树，那么该结点称为子树根的\"双亲\"，子树的根是该结点的\"孩子\"。有相同双亲的结点互为\"兄弟\"。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。 结点的度：结点拥有的子树的数目。 叶子：度为零的结点。 分支结点：度不为零的结点。 树的度：树中结点的最大的度。 层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。 树的高度：树中结点的最大层次。 无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置。 有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。 森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。 二、二叉树的介绍 1.二叉树的定义 二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。 2. 二叉树的性质 二叉树有以下几个性质： 性质1：二叉树第i层上的结点数目最多为$2^{i-1}$ (i≥1)。 性质2：深度为k的二叉树至多有$2^k - 1$个结点(k≥1)。 性质3：包含n个结点的二叉树的高度至少为$log_2(n+1)$。 性质4：在任意一棵二叉树中，若叶子结点的个数为n0，度为2的结点数为n2，则n0=n2+1。 2.1 性质1：二叉树第i层上的结点数目最多为$2^{i-1}$(i≥1) 证明：下面用\"数学归纳法\"进行证明。 ​ (01) 当i=1时，第i层的节点数目为1。因为第1层上只有一个根结点，所以命题成立。 ​ (02) 假设当i>1，第i层的节点数目为$2^{i-1}$。这个是根据(01)推断出来的！ 下面根据这个假设，推断出\"第(i+1)层的节点数目为$2^{i}$\"即可。 由于二叉树的每个结点至多有两个孩子，故\"第(i+1)层上的结点数目\" 最多是 \"第i层的结点数目的2倍\"。即，第(i+1)层上的结点数目最大值=2×$2^{i-1}$=$2^{i}$。 故假设成立，原命题得证！ 2.2 性质2：深度为k的二叉树至多有$2^{k}-1$个结点(k≥1) 证明：在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用\"性质1\"可知，深度为k的二叉树的结点数至多为： ​ $ 2^0+2^1+…+2^{k-1}=2^k-1$ 故原命题得证！ 2.3 性质3：包含n个结点的二叉树的高度至少为$log_2(n+1)$ 证明：根据\"性质2\"可知，高度为h的二叉树最多有$2^{h}-1$个结点。反之，对于包含n个节点的二叉树的高度至少为$log_2(n+1)$。 2.4 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1 证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=\"0度结点数(n0)\" + \"1度结点数(n1)\" + \"2度结点数(n2)\"。由此，得到等式一。 (等式一) n=n0+n1+n2 另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。 (等式二) n=n1+2n2+1 由(等式一)和(等式二)计算得到：n0=n2+1。原命题得证！ 3. 满二叉树，完全二叉树和二叉查找树 3.1 满二叉树 定义：高度为h，并且由$2^{h}-1$个结点的二叉树，被称为满二叉树。 3.2 完全二叉树 定义：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。 特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。 3.3 二叉查找树 定义：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] = key[x]。 在二叉查找树中： (01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； (02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； (03) 任意节点的左、右子树也分别为二叉查找树。 (04) 没有键值相等的节点（no duplicate nodes）。 三、二叉查找树的Java实现 1.二叉查找树节点的定义 public class BSTree> { private BSTNode mRoot; // 根结点 public class BSTNode> { T key; // 关键字(键值) BSTNode left; // 左孩子 BSTNode right; // 右孩子 BSTNode parent; // 父结点 public BSTNode(T key, BSTNode parent, BSTNode left, BSTNode right) { this.key = key; this.parent = parent; this.left = left; this.right = right; } } ...... } BSTree是二叉树，它保含了二叉树的根节点mRoot；mRoot是BSTNode类型，而BSTNode是二叉查找树的节点，它是BSTree的内部类。BSTNode包含二叉查找树的几个基本信息： (01) key -- 它是关键字，是用来对二叉查找树的节点进行排序的。 (02) left -- 它指向当前节点的左孩子。 (03) right -- 它指向当前节点的右孩子。 (04) parent -- 它指向当前节点的父结点。 2.遍历 这里讲解前序遍历、中序遍历、后序遍历3种方式。 2.1 前序遍历 若二叉树非空，则执行以下操作： (01) 访问根结点； (02) 先序遍历左子树； (03) 先序遍历右子树。 前序遍历代码 private void preOrder(BSTNode tree) { if(tree != null) { System.out.print(tree.key+\" \"); preOrder(tree.left); preOrder(tree.right); } } public void preOrder() { preOrder(mRoot); } 2.2 中序遍历 若二叉树非空，则执行以下操作： (01) 中序遍历左子树； (02) 访问根结点； (03) 中序遍历右子树。 中序遍历代码 private void inOrder(BSTNode tree) { if(tree != null) { inOrder(tree.left); System.out.print(tree.key+\" \"); inOrder(tree.right); } } public void inOrder() { inOrder(mRoot); } 2.3 后序遍历 若二叉树非空，则执行以下操作： (01) 后序遍历左子树； (02) 后序遍历右子树； (03) 访问根结点。 后序遍历代码 private void postOrder(BSTNode tree) { if(tree != null) { postOrder(tree.left); postOrder(tree.right); System.out.print(tree.key+\" \"); } } public void postOrder() { postOrder(mRoot); } 看看下面这颗树的各种遍历方式： 对于上面的二叉树而言， (01) 前序遍历结果： 3 1 2 5 4 6 (02) 中序遍历结果： 1 2 3 4 5 6 (03) 后序遍历结果： 2 1 4 6 5 3 3. 查找 递归版本的代码 /* * (递归实现)查找\"二叉树x\"中键值为key的节点 */ private BSTNode search(BSTNode x, T key) { if (x==null) return x; int cmp = key.compareTo(x.key); if (cmp 0) return search(x.right, key); else return x; } public BSTNode search(T key) { return search(mRoot, key); } 非递归版本的代码 /* * (非递归实现)查找\"二叉树x\"中键值为key的节点 */ private BSTNode iterativeSearch(BSTNode x, T key) { while (x!=null) { int cmp = key.compareTo(x.key); if (cmp 0) x = x.right; else return x; } return x; } public BSTNode iterativeSearch(T key) { return iterativeSearch(mRoot, key); } 4. 最大值和最小值 查找最大值的代码 /* * 查找最大结点：返回tree为根结点的二叉树的最大结点。 */ private BSTNode maximum(BSTNode tree) { if (tree == null) return null; while(tree.right != null) tree = tree.right; return tree; } public T maximum() { BSTNode p = maximum(mRoot); if (p != null) return p.key; return null; } 查找最小值的代码 /* * 查找最小结点：返回tree为根结点的二叉树的最小结点。 */ private BSTNode minimum(BSTNode tree) { if (tree == null) return null; while(tree.left != null) tree = tree.left; return tree; } public T minimum() { BSTNode p = minimum(mRoot); if (p != null) return p.key; return null; } 5. 前驱和后继 节点的前驱：是该节点的左子树中的最大节点。 节点的后继：是该节点的右子树中的最小节点。 查找前驱节点的代码 /* * 找结点(x)的前驱结点。即，查找\"二叉树中数据值小于该结点\"的\"最大结点\"。 */ public BSTNode predecessor(BSTNode x) { // 如果x存在左孩子，则\"x的前驱结点\"为 \"以其左孩子为根的子树的最大结点\"。 if (x.left != null) return maximum(x.left); // 如果x没有左孩子。则x有以下两种可能： // (01) x是\"一个右孩子\"，则\"x的前驱结点\"为 \"它的父结点\"。 // (02) x是\"一个左孩子\"，则查找\"x的最低的父结点，并且该父结点要具有右孩子\"，找到的这个\"最低的父结点\"就是\"x的前驱结点\"。 BSTNode y = x.parent; while ((y!=null) && (x==y.left)) {//满足条件，不断往上追溯，直到找到右祖先结点 x = y; y = y.parent; } return y; } 查找后继节点的代码 /* * 找结点(x)的后继结点。即，查找\"二叉树中数据值大于该结点\"的\"最小结点\"。 */ public BSTNode successor(BSTNode x) { // 如果x存在右孩子，则\"x的后继结点\"为 \"以其右孩子为根的子树的最小结点\"。 if (x.right != null) return minimum(x.right); // 如果x没有右孩子。则x有以下两种可能： // (01) x是\"一个左孩子\"，则\"x的后继结点\"为 \"它的父结点\"。 // (02) x是\"一个右孩子\"，则查找\"x的最低的父结点，并且该父结点要具有左孩子\"，找到的这个\"最低的父结点\"就是\"x的后继结点\"。 BSTNode y = x.parent; while ((y!=null) && (x==y.right)) {//满足条件，不断往上追溯，直到找到右祖先结点 x = y; y = y.parent; } return y; } 6. 插入 插入节点的代码 /* * 将结点插入到二叉树中 * * 参数说明： * tree 二叉树的 * z 插入的结点 */ private void insert(BSTree bst, BSTNode z) { int cmp; BSTNode y = null; BSTNode x = bst.mRoot; // 查找z的插入位置 while (x != null) { y = x; cmp = z.key.compareTo(x.key); if (cmp z=new BSTNode(key,null,null,null); // 如果新建结点失败，则返回。 if (z != null) insert(this, z); } 注：本文实现的二叉查找树是允许插入相同键值的节点的。 7. 删除 删除节点的代码 /* * 删除结点(z)，并返回被删除的结点 * * 参数说明： * bst 二叉树 * z 删除的结点 */ private BSTNode remove(BSTree bst, BSTNode z) { BSTNode x=null; BSTNode y=null; if ((z.left == null) || (z.right == null) ) y = z; else y = successor(z); if (y.left != null) x = y.left; else x = y.right; if (x != null) x.parent = y.parent; if (y.parent == null) bst.mRoot = x; else if (y == y.parent.left) y.parent.left = x; else y.parent.right = x; if (y != z) z.key = y.key; return y; } /* * 删除结点(z)，并返回被删除的结点 * * 参数说明： * tree 二叉树的根结点 * z 删除的结点 */ public void remove(T key) { BSTNode z, node; if ((z = search(mRoot, key)) != null) if ( (node = remove(this, z)) != null) node = null; } 8. 打印 打印二叉查找树的代码 /* * 打印\"二叉查找树\" * * key -- 节点的键值 * direction -- 0，表示该节点是根节点; * -1，表示该节点是它的父结点的左孩子; * 1，表示该节点是它的父结点的右孩子。 */ private void print(BSTNode tree, T key, int direction) { if(tree != null) { if(direction==0) // tree是根节点 System.out.printf(\"%2d is root\\n\", tree.key); else // tree是分支节点 System.out.printf(\"%2d is %2d's %6s child\\n\", tree.key, key, direction==1?\"right\" : \"left\"); print(tree.left, tree.key, -1); print(tree.right,tree.key, 1); } } public void print() { if (mRoot != null) print(mRoot, mRoot.key, 0); } 9. 销毁 销毁二叉查找树的代码 /* * 销毁二叉树 */ private void destroy(BSTNode tree) { if (tree==null) return ; if (tree.left != null) destroy(tree.left); if (tree.right != null) destroy(tree.right); tree=null; } public void clear() { destroy(mRoot); mRoot = null; } 四、树的深度/广度优先遍历 树的深度优先遍历需要用到额外的数据结构--->栈；而广度优先遍历需要队列来辅助；这里以二叉树为例来实现。 import java.util.ArrayDeque; public class BinaryTree { static class TreeNode{ int value; TreeNode left; TreeNode right; public TreeNode(int value){ this.value=value; } } TreeNode root; public BinaryTree(int[] array){ root=makeBinaryTreeByArray(array,1); } /** * 采用递归的方式创建一颗二叉树 * 传入的是二叉树的数组表示法 * 构造后是二叉树的二叉链表表示法 */ public static TreeNode makeBinaryTreeByArray(int[] array,int index){ if(index stack=new ArrayDeque(); stack.push(root); while(stack.isEmpty()==false){ TreeNode node=stack.pop(); System.out.print(node.value+\" \"); if(node.right!=null){ stack.push(node.right); } if(node.left!=null){ stack.push(node.left); } } System.out.print(\"\\n\"); } /** * 广度优先遍历 * 采用非递归实现 * 需要辅助数据结构：队列 */ public void levelOrderTraversal(){ if(root==null){ System.out.println(\"empty tree\"); return; } ArrayDeque queue=new ArrayDeque(); queue.add(root); while(queue.isEmpty()==false){ TreeNode node=queue.remove(); System.out.print(node.value+\" \"); if(node.left!=null){ queue.add(node.left); } if(node.right!=null){ queue.add(node.right); } } System.out.print(\"\\n\"); } /** * 13 * / \\ * 65 5 * / \\ \\ * 97 25 37 * / /\\ / * 22 4 28 32 */ public static void main(String[] args) { int[] arr={0,13,65,5,97,25,0,37,22,0,4,28,0,0,32,0}; BinaryTree tree=new BinaryTree(arr); tree.depthOrderTraversal(); tree.levelOrderTraversal(); } } Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/tree/other-tree.html":{"url":"data-structure/tree/other-tree.html","title":"其他常见的树","keywords":"","body":"一、AVL树 AVL树是高度平衡的而二叉树。它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。 上面的两张图片，左边的是AVL树，它的任何节点的两个子树的高度差别都 二、红黑树 R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树的特性: （1）每个节点或者是黑色，或者是红色。 （2）根节点是黑色。 （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] （4）如果一个节点是红色的，则它的子节点必须是黑色的。 （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 注意： (01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。 (02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。 红黑树示意图如下： 红黑树的应用 红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。 例如，Java集合中的TreeMap和HashMap，都是通过红黑树去实现的。 三、哈夫曼树 Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。 定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。 这个定义里面涉及到了几个陌生的概念，下面就是一颗哈夫曼树，我们来看图解答。 (01) 路径和路径长度 定义：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。 例子：100和80的路径长度是1，50和30的路径长度是2，20和10的路径长度是3。 (02) 结点的权及带权路径长度 定义：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。 例子：节点20的路径长度是3，它的带权路径长度= 路径长度x权 = 3 x 20 = 60。 (03) 树的带权路径长度 定义：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。 例子：示例中，树的WPL= 1x100 + 2x50 + 3x20 + 3x10 = 100 + 100 + 60 + 30 = 290。 比较下面两棵树 上面的两棵树都是以{10, 20, 50, 100}为叶子节点的树。 左边的树WPL=2x10 + 2x20 + 2x50 + 2x100 = 360 右边的树WPL=290 左边的树WPL > 右边的树的WPL。你也可以计算除上面两种示例之外的情况，但实际上右边的树就是{10,20,50,100}对应的哈夫曼树。至此，应该堆哈夫曼树的概念有了一定的了解了，下面看看如何去构造一棵哈夫曼树。 哈夫曼树的图文解析 假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为： 1. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)； 2. 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和； 3. 从森林中删除选取的两棵树，并将新树加入森林； 4. 重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。 以{5,6,7,8,15}为例，来构造一棵哈夫曼树。 第1步：创建森林，森林包括5棵树，这5棵树的权值分别是5,6,7,8,15。 第2步：在森林中，选择根节点权值最小的两棵树(5和6)来进行合并，将它们作为一颗新树的左右孩子(谁左谁右无关紧要，这里，我们选择较小的作为左孩子)，并且新树的权值是左右孩子的权值之和。即，新树的权值是11。 然后，将\"树5\"和\"树6\"从森林中删除，并将新的树(树11)添加到森林中。 第3步：在森林中，选择根节点权值最小的两棵树(7和8)来进行合并。得到的新树的权值是15。 然后，将\"树7\"和\"树8\"从森林中删除，并将新的树(树15)添加到森林中。 第4步：在森林中，选择根节点权值最小的两棵树(11和15)来进行合并。得到的新树的权值是26。 然后，将\"树11\"和\"树15\"从森林中删除，并将新的树(树26)添加到森林中。 第5步：在森林中，选择根节点权值最小的两棵树(15和26)来进行合并。得到的新树的权值是41。 然后，将\"树15\"和\"树26\"从森林中删除，并将新的树(树41)添加到森林中。 此时，森林中只有一棵树(树41)。这棵树就是我们需要的哈夫曼树！ Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/tree/Union-Find.html":{"url":"data-structure/tree/Union-Find.html","title":"并查集","keywords":"","body":"一、并查集的介绍 并查集（Union/Find）从名字可以看出，主要涉及两种基本操作:合并和查找。这说明，初始时并查集中的元素是不相交的，经过一系列的基本操作(Union)，最终合并成一个大的集合。 而在某次合并之后，有一种合理的需求：某两个元素是否已经处在同一个集合中了？因此就需要Find操作。 并查集是一种 不相交集合 的数据结构，设有一个动态集合S={s1，s2，s3，.....sn}，每个集合通过一个代表来标识，该代表中集合中的某个元素。 比如，若某个元素 x 是否在集合 s1 中(Find操作)，返回集合 s1 的代表元素即可。这样，判断两个元素是否在同一个集合中也是很方便的，只要看find(x) 和 find(y) 是否返回同一个代表即可。 为什么是动态集合S呢？因为随着Union操作，动态集合S中的子集合个数越来越少。 数据结构的基本操作决定了它的应用范围，对并查集而言，一个简单的应用就是判断无向图的连通分量个数，或者判断无向图中任何两个顶点是否连通。 二、并查集的存储结构及实现分析 ①存储结构 并查集(大S)由若干子集合si构成，并查集的逻辑结构就是一个森林。si表示森林中的一棵子树。一般以子树的根作为该子树的代表。 而对于并查集的存储结构，可用一维数组和链表来实现。这里主要介绍一维数组的实现。 根据前面介绍的基本操作再加上存储结构，并查集类的实现架构如下： public class DisjSets { private int[] s; private int count;//记录并查集中子集合的个数(子树的个数) public DisjSets(int numElements) { //构造函数，负责初始化并查集 } public void unionByHeight(int root1, int root2){ //union操作 } public int find(int x){ //find 操作 } } 由于Find操作需要找到该子集合的代表元素，而代表元素是树根，因此需要保存树中结点的父亲，对于每一个结点，如果知道了父亲，沿着父结点链就可以最终找到树根。 为了简单起见，假设一维数组s中的每个元素 s[i] 表示该元素 i 的父亲。这里有两个需要注意的地方：①我们用一维数组来存储并查集，数组的元素s[i]表示的是结点的父亲的位置。②数组元素的下标 i 则是结点的标识。如：s[5]=4，节点5 在数组的第4号位置处。 假设有并查集中6个元素，初始时，所有的元素都相互独立，处在不同的集合中： 对应的一维数组初始化如下： 因为，初始时每个元素代表一个集合，该元素本身就是树根。树根的父结点用 -1 来表示。代码实现如下： public DisjSets(int numElements) { s = new int[numElements]; count = numElements; //初始化并查集,相当于新建了s.length 个互不相交的集合 for(int i = 0; i ②基本操作实现 Union操作就是将两个不相交的子集合合并成一个大集合。简单的Union操作是非常容易实现的，因为只需要把一棵子树的根结点指向另一棵子树即可完成合并。 比如合并 节点3 和节点4： 这里的合并很随意，把任意一棵子树的结点指向另一棵子树结点就完成了合并。 public void union(int root1, int root2){ s[root2] = root1;//将root1作为root2的新树根 } 但是，这只是一个简单的情况，如果待合并的两棵子树很大，而且高度不一样时，如何使得合并操作生成的新的子树的高度最小？因为高度越小的子树Find操作越快。 后面会介绍一种更好的合并策略，以支持Quick Union/Find。 Find操作就是查找某个元素所在的集合，返回该集合的代表元素。在union(3,4) 和 union(1,2)后，并查集如下： 此时的一维数组如下： 此时一共有4个子集合。第一个集合的代表元素为0，第二个集合的代表元素为1，第三个集合的代表元素为3，第四个集合的代表元素为5，故： find(2)返回1，find(0)返回0。因为 结点3 和 结点4 在同一个集合内，find(4)返回3，find(3)返回3。 public int find(int x){ if(s[x] 这里find(int x)返回的是最里层递归执行后，得到的值。由于只有树根的父结点位置小于0，故返回的是树根结点的标识。 （数组中索引 i 处的元素 s[i] 小于0，表示 结点i 是根结点.....） 三、Union/Find的改进----Quick Union/Find 上面介绍的Union操作很随意：任选一棵子树，将另一棵子树的根指向它即完成了合并。如果一直按照上述方式合并，很可能产生一棵非常不平衡的子树。 比如在上面的基础上union(2,3)后 树越来越高了，此时会影响到Find操作的效率。比如，find(4)时，会一直沿着父结点遍历直到根，4-->3-->2-->1 这里引入一种新的合并策略，这是一种启发式策略，称之为按秩合并：将秩小的子树的根指向秩大的子树的根。 秩的定义：对每个结点，用秩表示结点高度的一个上界。为什么是上界？ 因为路径压缩不完全与按高度求并兼容。路径压缩会改变树的高度，这样在Union操作之前，我们就无法获得子树的高度的精确值，因此就不计算高度的精确值，而是存储每棵树的高度的估计值，这个值称之为秩。 说了这么多，按秩求并就是在合并之前，先判断下哪棵子树更高，让矮的子树的根指向高的子树的根。 除了按高度求并之外，还可以按大小求并，即先判断下哪棵子树含有的结点数目多，让较小的子树的根指向较大的子树的根。 对于按高度求并，需要解释下数组中存储的元素：是高度的负值再减去1。这样，初始时，所有元素都是-1，而树根节点的高度为0，s[i]=-1。 按高度求并的代码如下： /** * * @param root1 并查集中以root1为代表的某个子集 * @param roo2 并查集中以root2为代表的某个子集 * 按高度(秩)合并以root1 和 root2为代表的两个集合 */ public void unionByHeight(int root1, int root2){ if(find(root1) == find(root2)) return;//root1 与 root2已经连通了 if(s[root2] 使用了路径压缩的Find的操作 上面程序代码find方法只是简单地把待查找的元素所在的根返回。路径压缩是指，在find操作进行时，使find查找路径中的顶点(的父亲)都直接指向为树根（这很明显地改变了子树的高度） 如何使find查找路径中经过的每个顶点都直接指向树根呢？只需要小小改动一下就可以了，这里用到了非常神奇的递归。修改后的find代码如下： public int find(int x){ if(s[x] 因为递归最终得到的返回值是根元素。第5行将根元素直接赋值给s[x]，s[x]在每次递归过程中相当于结点x的父结点指针。 关于路径压缩对按”秩“求并的兼容性问题 上面的unionByHeight(int , int)是按照两棵树的高度来进行合并的。但是find操作中的路径压缩会对树的高度产生影响。使用了路径压缩后，树的高度变化了，但是数组并没有更新这个变化。因为无法更新！！（我们没有在Find操作中去计算原来的树的高度，然后再计算新的树的高度，这样不现实，复杂度太大了） 举个例子： 依次高度unionByHeight(3, 4)、unionByHeight(1, 3)、unionByHeight(1, 0)后，并查集如下： 此时，数组中的元素如下： 可以看出，此时只有两棵子树，一棵根结点为1，另一棵只有一个结点5。结点1的s[1]=-3，它所表示是该子树的高度为2，如果此时执行find(4)，会改变这棵树的高度！但是，数组s中存储的根的高度却没有更新，只会更新查找路径上的顶点的高度。执行完find(4)后，变成： 查找路径为 4-->3-->1，find(4)使得查找路径上的所有顶点的父结点指向了根。如，将结点4 指向了根。但是没有根结点的高度（没有影响树根的秩），因为s[1]的值仍为-3 -3表示的高度为2，但是树的高度实际上已经变成了1 执行find(4)之后，树实际上是这样的： （关于路径压缩对按秩合并有影响，我一直有个疑问，希望有大神指点啊）。。。。 路径压缩改变了子树的高度，而这个高度是按秩求的依据。，而且当高度改变之后，我们是无法更新这个变化了的高度的。那这会不会影响按秩求并的正确性？或者说使按秩求并达不到减小新生成的子树的高度的效果？ 四、并查集的应用 并查集数据结构非常简单，基本操作也很简单。但是用途感觉很大。比如，求解无向图中连通分量的个数，生成迷宫…… 这些应用本质上就是：初始时都是一个个不连通的对象，经过一步步处理，变成连通的了。。。。。 如迷宫，初始时，起点和终点不连通，随机地打开起点到终点路径上的一个方向，直至起点和终点连通了，就生成了一个迷宫。 如，无向图的连通分量个数，初始时，将无向图中各个顶点视为不连通的子集合，对图中每一条边，相当于union这条边对应的两个顶点分别所在的集合，直至所有的边都处理完后，还剩下的集合的个数即为连通分量的个数。 五、完整代码 public class DisjSets { private int[] s; private int count;//记录并查集中子集合的个数(子树的个数) public DisjSets(int numElements) { s = new int[numElements]; count = numElements; //初始化并查集,相当于新建了s.length 个互不相交的集合 for(int i = 0; i Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/tree/b-tree.html":{"url":"data-structure/tree/b-tree.html","title":"B-树，B+树，B*树","keywords":"","body":"一、概念 Binary Tree（二叉树）：二叉树的每个节点最多有两个子节点 Binary Search Tree（二叉搜索树）：二叉搜索树每个节点只存储一个键值，并且左子树（如果有）所有节点的值都要小于根节点的值，右子树（如果有）所有节点的值都要大于根节点的值。 B-Tree（Balanced Tree）：也就是今天要说的B-树，这里的-不是minus的意思，而是作为连接符的横杠，而我们也经常把B-树直接翻译为B树，所以B树与B-树通常是指一个概念，B代表的是Balance，而不是Binary。而B+树和B*树则是B-树的基础上正对不同场景的优化版本，将会在后文中有所介绍。 在大规模数据存储中，二叉查找树的深度会过大，当内存无法存储所有节点数据时，需要读取磁盘，进行IO操作，从而树的高度越高，I/O操作次数越多，效率也就越低。所以诸如之前所讲的红黑树，AVL树 因为树的高度太高而不适合这种需要大量IO操作的查询。所以，B树通过多叉的实现来降低树的高度，从而减少IO操作的次数。 二、B树（B-树） 为方便描述，下面一律用B树这个名称。B树是一种多路平衡搜索树（非二叉），若其是M路，则： 任意非叶子节点最多可以有M个子女，且M>2； 根节点的子女数为[2,M]； 除了根节点以外的非叶子节点的子女数目为M/2（取上整）个到M个； 每个节点存放至少M/2-1（取上整）和至多M-1个键值（至少两个）； 非叶子节点的关键字个数=指向子女的指针个数-1； 非叶子节点的关键字K[1],K[2],…,K[M-1]且有K[i] 非叶子节点的指针P[1],P[2],…,P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1],K[i])的子树； 所有叶子节点都位于同一层。 B树与二叉搜索树的最大区别在于其每个节点可以存不止一个键值，并且其子女不止两个，不过还是需要满足键值数=子女数-1。因此，对于相同数量的键值，B树比二叉搜索树要更加矮一些，特别是当M较大时，树高会更低。 上图中是一个简单的B树，在实际应用中，M可以取到很大，比如大于1000。一般情况下M的取值会使得每个磁盘盘块可以正好存放一个B数节点。上图中的35节点，35是一个key（或者说是索引，比如磁盘文件的文件名），而小黑块则代表的是该key所指向的内容在磁盘中实际的存储位置，是一个指针（比如35这个文件在硬盘中的位置）。 B树的搜索 B树的搜索与二叉搜索树类似，只不过需要在节点内部进行一次搜索查找。从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点； B树的插入 B树的插入首先查找插入所在的节点，若该节点未满，插入即可，若该节点以及满了，则需要将该节点分裂，并将该节点的中间的元素移动到父节点上，若父节点未满，则结束，若父节点也满了，则需要继续分裂父节点，如此不断向上，直到根节点，如果根节点也满了，则分裂根节点，从而树的高度+1。 下面是B树插入的一个演示动画，往B树中一次插入的元素为6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4。 B树的删除 B树的删除首先要找到删除的节点，并删除节点中的元素，如果删除的元素有左右孩子，则上移左孩子最右节点或右孩子最左节点到父节点，若没有左右孩子，则直接删除。删除后，若某节点中元素数目不符合B树要求（小于M/2-1取上整），则需要看起相邻的兄弟节点是否有多余的元素，若有，则可以向父节点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有点类似于左旋）。若其相邻兄弟节点没有多余的元素，则与其兄弟节点合并成一个节点，此时也需要将父节点中的一个元素一起合并。 三、B+树 B+树是B树的一个变种，其也是一种多路平衡搜索树，其与B树的主要区别是： 非叶子节点的指针数量与关键字数量相等； 非叶子节点的子树指针P[i]，指向关键字值属于[K[i],K[i+1]）的子树（B树是开区间，B+树是左闭右开，也就是说B树不允许关键字重复，而B+树允许）； 所有关键字都在叶子节点出现，所有的叶子节点增加了一个链指针（稠密索引，且链表中的关键字切好是有序的）； 非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储数据的数据层。 B+树主要是应文件系统所需而产生的。文件系统中，文件的目录是一级一级索引，只有最底层的叶子节点（文件）保存数据。非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，所有的非叶子节点都可以看成是索引部分。 非叶子节点（比如[5，28，65]）只是一个key（索引，实际的数据在叶子节点上，对应于叶子节点[5,8,9]中的5，[28,30,33]中的28，[65,73,79]中的65才是真正的数据或指向真实数据的指针）。 B+树的搜索 B+的搜索与B树也是基本相同的。唯一的区别是B+树只有达到叶子结点才命中，因为只有叶节点中存放着真实数据或真实数据的指正，而B树可以在非叶子结点命中，其性能也等价于在元素全集做一次二分查找。 B+树的插入 B+树的插入与B树类似，如果节点中有多余的空间放入元素，则直接插入即可。如果节点本来就已经满了，则将其分裂为两个节点，并将其中间元素的索引放入到父节点中，在这里如果是叶子节点的话，是拷贝中间元素的索引到父节点中（因为叶子节点需要包含所有的元素），而如果是非叶子节点，则是上移节点的中间元素到父节点中。 下面是B+树插入的一个演示动画： B+树的删除 在叶节点中删除元素，如果节点还满足B+树的要求，则okay。如果元素个数过少，并且其邻近兄弟节点有多余的元素，则从邻近兄弟节点中借一个元素，并修改父节点中的索引使其满足新的划分。如果其邻近兄弟节点也没有多余的元素，则将其和邻近兄弟节点合并，并且我们需要修改其父节点的索引以满足新的划分。并且如果父节点的索引元素太少不满足要求，则需要继续看起兄弟节点是否多余，如果没有多余则还需要与兄弟节点合并，如此不断向上，直到根节点。如果根节点中元素也被删除，则把根节点删除，并由合并来的节点作为新的根节点，树的高度减1。 四、B+树与B树的比较 B+树的非叶子节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，盘块所能容纳的关键字数量也越多，具有更好的空间局部性，一次性读入内存的需要查找的关键字也越多，相对的IO读写次数也就降低了。 另外对于B+树来说，因为非叶子节点只是叶子节点中关键字的索引，所以任何关键字的查找都必须走一条从根节点到叶子节点的路，所有关键字查询的路径长度相同。而若经常访问的元素离根节点很近，则B树访问更迅速，因为其不一定要到叶子节点。 数据库索引采用B+树的主要原因是B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题，而也正是为了解决该问题，B+树应运而生。因为叶子节点中增加了一个链指针，B+树只需要取遍历叶子节点可以实现整棵树的遍历。而且数据库中基于范围的查询是非常频繁的，B树对基于范围的查询效率太低。 五、B*树 B*树又是B+树的变种，其与B+树的区别有： B*树在B+树的非根和非叶子节点再增加指向兄弟节点的指针 B树规定非叶子节点的键值个数至少为(2/3)M，这样每个节点的使用率就从B+树的1/2上升到2/3，所以空间使用率更高。 B树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；B树分配新结点的概率比B+树要低，空间使用率更高； Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph.html":{"url":"data-structure/graph.html","title":"图","keywords":"","body":"一、前言 图作为数据结构中最复杂的一种结构，涉及到一些著名的算法，如dijkstra,flyod等。 此外，图的一些特性也值得我们学习，是笔试和面试中会高频考察的知识点。 本部分内容不仅介绍了图的基础概念及特性，同时介绍了图涉及的一些算法的Java实现。 二、目录 图的基础 拓扑排序 Kruskal算法 Prim算法 Dijkstra算法 Floyd算法 Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/graph-introduction.html":{"url":"data-structure/graph/graph-introduction.html","title":"图的基础","keywords":"","body":"一、图的基本概念 1. 图的定义 定义：图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为\"顶点(vertex)\"，而点与点之间的连线则被成为\"边或弧\"(edege)。通常记为，G=(V,E)。 2. 图的种类 根据边是否有方向，将图可以划分为：无向图和有向图。 2.1 无向图 上面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中， (01) V1={A,B,C,D,E,F}。 V1表示由\"A,B,C,D,E,F\"几个顶点组成的集合。 (02) E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)...等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。 2.2 有向图 上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中， (01) V2={A,C,B,F,D,E,G}。 V2表示由\"A,B,C,D,E,F,G\"几个顶点组成的集合。 (02) A2={,,,,,,,,}。 E1是由矢量,矢量...等等组成的集合。其中，矢量 3. 邻接点和度 3.1 邻接点 一条边上的两个顶点叫做邻接点。 例如，上面无向图G0中的顶点A和顶点C就是邻接点。 在有向图中，除了邻接点之外；还有\"入边\"和\"出边\"的概念。 顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。 例如，上面有向图G2中的B和E是邻接点；是B的出边，还是E的入边。 3.2 度 在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。 例如，上面无向图G0中顶点A的度是2。 在有向图中，度还有\"入度\"和\"出度\"之分。 某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。 顶点的度=入度+出度。 例如，上面有向图G2中，顶点B的入度是2，出度是3；顶点B的度=2+3=5。 4. 路径和回路 路径：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。 路径长度：路径中\"边的数量\"。 简单路径：若一条路径上顶点不重复出现，则是简单路径。 回路：若路径的第一个顶点和最后一个顶点相同，则是回路。 简单回路：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。 5. 连通图和连通分量 连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。 连通分量：非连通图中的各个连通子图称为该图的连通分量。 6. 权 在学习\"哈夫曼树\"的时候，了解过\"权\"的概念。图中权的概念与此类似。 上面就是一个带权的图。 二、图的存储结构 上面了解了\"图的基本概念\"，下面开始介绍图的存储结构。图的存储结构，常用的是\"邻接矩阵\"和\"邻接表\"。 1. 邻接矩阵 邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。 假设图中顶点数为n，则邻接矩阵定义为： 下面通过示意图来进行解释。 图中的G1是无向图和它对应的邻接矩阵。 图中的G2是无向图和它对应的邻接矩阵。 通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。 邻接矩阵的缺点就是比较耗费空间。 2. 邻接表 邻接表是图的一种链式存储表示方法。它是改进后的\"邻接矩阵\"，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。 图中的G1是无向图和它对应的邻接矩阵。 图中的G2是有向图和它对应的邻接矩阵。 三、图的深度/广度优先遍历 1. 深度优先搜索介绍 图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。 它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 显然，深度优先搜索是一个递归的过程。 2. 深度优先搜索图解 2.1 无向图的深度优先搜索 下面以\"无向图\"为例，来对深度优先搜索进行演示。 对上面的图G1进行深度优先遍历，从顶点A开始。 第1步：访问A。 第2步：访问(A的邻接点)C。 ​ 在第1步访问A之后，接下来应该访问的是A的邻接点，即\"C,D,F\"中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在\"D和F\"的前面，因此，先访问C。 第3步：访问(C的邻接点)B。 ​ 在第2步访问C之后，接下来应该访问C的邻接点，即\"B和D\"中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 第4步：访问(C的邻接点)D。 ​ 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 第5步：访问(A的邻接点)F。 ​ 前面已经访问了A，并且访问完了\"A的邻接点B的所有邻接点(包括递归的邻接点在内)\"；因此，此时返回到访问A的另一个邻接点F。 第6步：访问(F的邻接点)G。 第7步：访问(G的邻接点)E。 因此访问顺序是：A -> C -> B -> D -> F -> G -> E 2.2 有向图的深度优先搜索 下面以\"有向图\"为例，来对深度优先搜索进行演示。 对上面的图G2进行深度优先遍历，从顶点A开始。 第1步：访问A。 第2步：访问B。 ​ 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 第3步：访问C。 ​ 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 第4步：访问E。 ​ 接下来访问C的出边的另一个顶点，即顶点E。 第5步：访问D。 ​ 接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 第6步：访问F。 ​ 接下应该回溯\"访问A的出边的另一个顶点F\"。 第7步：访问G。 因此访问顺序是：A -> B -> C -> E -> D -> F -> G 3. 广度优先搜索介绍 广度优先搜索算法(Breadth First Search)，又称为\"宽度优先搜索\"或\"横向优先搜索\"，简称BFS。 它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。 4. 广度优先搜索图解 4.1 无向图的广度优先搜索 下面以\"无向图\"为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。 第1步：访问A。 第2步：依次访问C,D,F。 ​ 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在\"D和F\"的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 第3步：依次访问B,G。 ​ 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 第4步：访问E。 ​ 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。 因此访问顺序是：A -> C -> D -> F -> B -> G -> E 4.2 有向图的广度优先搜索 下面以\"有向图\"为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。 第1步：访问A。 第2步：访问B。 第3步：依次访问C,E,F。 ​ 在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 第4步：依次访问D,G。 ​ 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。 因此访问顺序是：A -> B -> C -> E -> F -> D -> G Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/topology.html":{"url":"data-structure/graph/topology.html","title":"拓扑排序","keywords":"","body":"一、拓扑排序介绍 拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。 这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！ 例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。 在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。 二、拓扑排序的算法图解 拓扑排序算法的基本步骤： 1. 构造一个队列Q(queue) 和 拓扑排序的结果队列T(topological)； 2. 把所有没有依赖顶点的节点放入Q； 3. 当Q还有顶点的时候，执行下面步骤： 3.1 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)； 3.2 对n每一个邻接点m(n是起点，m是终点)； 3.2.1 去掉边; 3.2.2 如果m没有依赖顶点，则把m放入Q; 注：顶点A没有依赖顶点，是指不存在以A为终点的边。 以上图为例，来对拓扑排序进行演示。 第1步：将B和C加入到排序结果中。 ​ 顶点B和顶点C都是没有依赖顶点，因此将C和C加入到结果集T中。假设ABCDEFG按顺序存储，因此先访问B，再访问C。访问B之后，去掉边和，并将A和D加入到队列Q中。同样的，去掉边和，并将F和G加入到Q中。 ​ (01) 将B加入到排序结果中，然后去掉边和；此时，由于A和D没有依赖顶点，因此并将A和D加入到队列Q中。 ​ (02) 将C加入到排序结果中，然后去掉边和；此时，由于F有依赖顶点D，G有依赖顶点A，因此不对F和G进行处理。 第2步：将A,D依次加入到排序结果中。 ​ 第1步访问之后，A,D都是没有依赖顶点的，根据存储顺序，先访问A，然后访问D。访问之后，删除顶点A和顶点D的出边。 第3步：将E,F,G依次加入到排序结果中。 因此访问顺序是：B -> C -> A -> D -> E -> F -> G 三、拓扑排序的代码说明 拓扑排序是对有向无向图的排序。下面以邻接表实现的有向图来对拓扑排序进行说明。 1. 基本定义 public class ListDG { // 邻接表中表对应的链表的顶点 private class ENode { int ivex; // 该边所指向的顶点的位置 ENode nextEdge; // 指向下一条弧的指针 } // 邻接表中表的顶点 private class VNode { char data; // 顶点信息 ENode firstEdge; // 指向第一条依附该顶点的弧 }; private VNode[] mVexs; // 顶点数组 ... } (01) ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。 (02) VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。 (03) ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。 2. 拓扑排序 /* * 拓扑排序 * * 返回值： * -1 -- 失败(由于内存不足等原因导致) * 0 -- 成功排序，并输入结果 * 1 -- 失败(该有向图是有环的) */ public int topologicalSort() { int index = 0; int num = mVexs.size(); int[] ins; // 入度数组 char[] tops; // 拓扑排序结果数组，记录每个节点的排序后的序号。 Queue queue; // 辅组队列 ins = new int[num]; tops = new char[num]; queue = new LinkedList(); // 统计每个顶点的入度数 for(int i = 0; i 说明： (01) queue的作用就是用来存储没有依赖顶点的顶点。它与前面所说的Q相对应。 (02) tops的作用就是用来存储排序结果。它与前面所说的T相对应。 Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/Kruskal.html":{"url":"data-structure/graph/Kruskal.html","title":"Kruskal算法","keywords":"","body":"一、最小生成树 在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。 例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。 二、克鲁斯卡尔算法介绍 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。 三、克鲁斯卡尔算法图解 以上图G4为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。 第1步：将边加入R中。 ​ 边的权值最小，因此将它加入到最小生成树结果R中。 第2步：将边加入R中。 ​ 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果R中。 第3步：将边加入R中。 ​ 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果R中。 第4步：将边加入R中。 ​ 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳过边。将边加入到最小生成树结果R中。 第5步：将边加入R中。 ​ 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果R中。 第6步：将边加入R中。 ​ 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳过边。将边加入到最小生成树结果R中。 此时，最小生成树构造完成！它包括的边依次是： 。 四、克鲁斯卡尔算法分析 根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题： 问题一 对图的所有边按照权值大小进行排序。 问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。 问题一很好解决，采用排序算法进行排序即可。 问题二，处理方式是：记录顶点在\"最小生成树\"中的终点，顶点的终点是\"在最小生成树中与它连通的最大顶点\"(关于这一点，后面会通过图片给出说明)。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。 以下图来进行说明： 在将 加入到最小生成树R中之后，这几条边的顶点就都有了终点： (01) C的终点是F。 (02) D的终点是F。 (03) E的终点是F。 (04) F的终点是F。 关于终点，就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是\"与它连通的最大顶点\"。 因此，接下来，虽然是权值最小的边。但是C和E的重点都是F，即它们的终点相同，因此，将加入最小生成树的话，会形成回路。这就是判断回路的方式。 五、克鲁斯卡尔算法的代码说明 有了前面的算法分析之后，下面我们来查看具体代码。这里选取\"邻接矩阵\"进行说明，对于\"邻接表\"实现的图在后面的源码中会给出相应的源码。 1. 基本定义 // 边的结构体 private static class EData { char start; // 边的起点 char end; // 边的终点 int weight; // 边的权重 public EData(char start, char end, int weight) { this.start = start; this.end = end; this.weight = weight; } }; EData是邻接矩阵边对应的结构体。 public class MatrixUDG { private int mEdgNum; // 边的数量 private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ... } MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示\"顶点i(即mVexs[i])\"和\"顶点j(即mVexs[j])\"是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 克鲁斯卡尔算法 /* * 克鲁斯卡尔（Kruskal)最小生成树 */ public void kruskal() { int index = 0; // rets数组的索引 int[] vends = new int[mEdgNum]; // 用于保存\"已有最小生成树\"中每个顶点在该最小树中的终点。 EData[] rets = new EData[mEdgNum]; // 结果数组，保存kruskal最小生成树的边 EData[] edges; // 图对应的所有边 // 获取\"图中所有的边\" edges = getEdges(); // 将边按照\"权\"的大小进行排序(从小到大) sortEdges(edges, mEdgNum); for (int i=0; i Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/Prim.html":{"url":"data-structure/graph/Prim.html","title":"Prim算法","keywords":"","body":"一、普里姆算法介绍 普里姆(Prim)算法，是用来求加权连通图的最小生成树的算法。 基本思想 对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。 二、普里姆算法图解 以上图G4为例，来对普里姆进行演示(从第一个顶点A开始通过普里姆算法生成最小生成树)。 初始状态：V是所有顶点的集合，即V={A,B,C,D,E,F,G}；U和T都是空！ 第1步：将顶点A加入到U中。 ​ 此时，U={A}。 第2步：将顶点B加入到U中。 ​ 上一步操作之后，U={A}, V-U={B,C,D,E,F,G}；因此，边(A,B)的权值最小。将顶点B添加到U中；此时，U={A,B}。 第3步：将顶点F加入到U中。 ​ 上一步操作之后，U={A,B}, V-U={C,D,E,F,G}；因此，边(B,F)的权值最小。将顶点F添加到U中；此时，U={A,B,F}。 第4步：将顶点E加入到U中。 ​ 上一步操作之后，U={A,B,F}, V-U={C,D,E,G}；因此，边(F,E)的权值最小。将顶点E添加到U中；此时，U={A,B,F,E}。 第5步：将顶点D加入到U中。 ​ 上一步操作之后，U={A,B,F,E}, V-U={C,D,G}；因此，边(E,D)的权值最小。将顶点D添加到U中；此时，U={A,B,F,E,D}。 第6步：将顶点C加入到U中。 ​ 上一步操作之后，U={A,B,F,E,D}, V-U={C,G}；因此，边(D,C)的权值最小。将顶点C添加到U中；此时，U={A,B,F,E,D,C}。 第7步：将顶点G加入到U中。 ​ 上一步操作之后，U={A,B,F,E,D,C}, V-U={G}；因此，边(F,G)的权值最小。将顶点G添加到U中；此时，U=V。 此时，最小生成树构造完成！它包括的顶点依次是：A B F E D C G。 三、普里姆算法的代码说明 以\"邻接矩阵\"为例对普里姆算法进行说明。 1. 基本定义 public class MatrixUDG { private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ... } MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示\"顶点i(即mVexs[i])\"和\"顶点j(即mVexs[j])\"是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 普里姆算法 /* * prim最小生成树 * * 参数说明： * start -- 从图中的第start个元素开始，生成最小树 */ public void prim(int start) { int num = mVexs.length; // 顶点个数 int index=0; // prim最小树的索引，即prims数组的索引 char[] prims = new char[num]; // prim最小树的结果数组 int[] weights = new int[num]; // 顶点间边的权值 // prim最小生成树中第一个数是\"图中第start个顶点\"，因为是从start开始的。 prims[index++] = mVexs[start]; // 初始化\"顶点的权值数组\"， // 将每个顶点的权值初始化为\"第start个顶点\"到\"该顶点\"的权值。 for (int i = 0; i Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/Dijkstra.html":{"url":"data-structure/graph/Dijkstra.html","title":"Dijkstra算法","keywords":"","body":"一、迪杰斯特拉算法介绍 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 基本思想 ​ 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。 ​ 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。 ​ 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是\"起点s到该顶点的路径\"。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 ... 重复该操作，直到遍历完所有顶点。 操作步骤 (1) 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为\"起点s到该顶点的距离\"[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。 (2) 从U中选出\"距离最短的顶点k\"，并将顶点k加入到S中；同时，从U中移除顶点k。 (3) 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。 (4) 重复步骤(2)和(3)，直到遍历完所有顶点。 单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。 二、迪杰斯特拉算法图解 以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。 初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！ 第1步：将顶点D加入到S中。 ​ 此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。 注:C(3)表示C到起点D的距离是3。 第2步：将顶点C加入到S中。 ​ 上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。 ​ 此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。 第3步：将顶点E加入到S中。 ​ 上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。 ​ 此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。 第4步：将顶点F加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。 第5步：将顶点G加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。 第6步：将顶点B加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。 第7步：将顶点A加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。 此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。 三、迪杰斯特拉算法的代码说明 以\"邻接矩阵\"为例对迪杰斯特拉算法进行说明。 1. 基本定义 public class MatrixUDG { private int mEdgNum; // 边的数量 private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ... } MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示\"顶点i(即mVexs[i])\"和\"顶点j(即mVexs[j])\"是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 迪杰斯特拉算法 /* * Dijkstra最短路径。 * 即，统计图中\"顶点vs\"到其它各个顶点的最短路径。 * * 参数说明： * vs -- 起始顶点(start vertex)。即计算\"顶点vs\"到其它顶点的最短路径。 * prev -- 前驱顶点数组。即，prev[i]的值是\"顶点vs\"到\"顶点i\"的最短路径所经历的全部顶点中，位于\"顶点i\"之前的那个顶点。 * dist -- 长度数组。即，dist[i]是\"顶点vs\"到\"顶点i\"的最短路径的长度。 */ public void dijkstra(int vs, int[] prev, int[] dist) { // flag[i]=true表示\"顶点vs\"到\"顶点i\"的最短路径已成功获取 boolean[] flag = new boolean[mVexs.length]; // 初始化 for (int i = 0; i Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/Floyd.html":{"url":"data-structure/graph/Floyd.html","title":"Floyd算法","keywords":"","body":"一、弗洛伊德算法介绍 和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。 基本思想 ​ 通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入一个矩阵S，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。 ​ 假设图G中顶点个数为N，则需要对矩阵S进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。 接下来开始，对矩阵S进行N次更新。第1次更新时，如果\"a[i][j]的距离\" > \"a[i][0]+a[0][j]\"(a[i][0]+a[0][j]表示\"i与j之间经过第1个顶点的距离\")，则更新a[i][j]为\"a[i][0]+a[0][j]\"。 同理，第k次更新时，如果\"a[i][j]的距离\" > \"a[i][k]+a[k][j]\"，则更新a[i][j]为\"a[i][k]+a[k][j]\"。更新N次之后，操作完成！ ​ 单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。 二、弗洛伊德算法图解 以上图G4为例，来对弗洛伊德进行算法演示。 初始状态：S是记录各个顶点间最短路径的矩阵。 第1步：初始化S。 ​ 矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。实际上，就是将图的原始矩阵复制到S中。 ​ 注:a[i][j]表示矩阵S中顶点i(第i个顶点)到顶点j(第j个顶点)的距离。 第2步：以顶点A(第1个顶点)为中介点，若a[i][j] > a[i][0]+a[0][j]，则设置a[i][j]=a[i][0]+a[0][j]。 ​ 以顶点a[1][6]，上一步操作之后，a[1][6]=∞；而将A作为中介点时，(B,A)=12，(A,G)=14，因此B和G之间的距离可以更新为16。 同理，依次将顶点B,C,D,E,F,G作为中介点，并更新a[i][j]的大小。 三、弗洛伊德算法的代码说明 以\"邻接矩阵\"为例对弗洛伊德算法进行说明，对于\"邻接表\"实现的图在后面会给出相应的源码。 1. 基本定义 public class MatrixUDG { private int mEdgNum; // 边的数量 private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ... } MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示\"顶点i(即mVexs[i])\"和\"顶点j(即mVexs[j])\"是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 弗洛伊德算法 /* * floyd最短路径。 * 即，统计图中各个顶点间的最短路径。 * * 参数说明： * path -- 路径。path[i][j]=k表示，\"顶点i\"到\"顶点j\"的最短路径会经过顶点k。 * dist -- 长度数组。即，dist[i][j]=sum表示，\"顶点i\"到\"顶点j\"的最短路径的长度是sum。 */ public void floyd(int[][] path, int[][] dist) { // 初始化 for (int i = 0; i tmp) { // \"i到j最短路径\"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // \"i到j最短路径\"对应的路径，经过k path[i][j] = path[i][k]; } } } } // 打印floyd最短路径的结果 System.out.printf(\"floyd: \\n\"); for (int i = 0; i Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/hash.html":{"url":"data-structure/hash.html","title":"散列查找","keywords":"","body":"一、什么是哈希表 哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。 哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。 使用哈希查找有两个步骤: 使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突 处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。 哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。 二、哈希函数 哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。比如举个简单的例子，使用手机号码后三位就比前三位作为key更好，因为前三位手机号码的重复率很高。再比如使用身份证号码出生年月位数要比使用前几位数要更好。 在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。 1. 正整数 获取正整数哈希值最常用的方法是使用除留余数法。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。M一般取素数。 2. 字符串 将字符串作为键的时候，我们也可以将他作为一个大的整数，采用保留除余法。我们可以将组成字符串的每一个字符取值然后进行哈希，比如 public int GetHashCode(string str) { char[] s = str.ToCharArray(); int hash = 0; for (int i = 0; i 上面的哈希值是Horner计算字符串哈希值的方法，公式为: 举个例子，比如要获取”call”的哈希值，字符串c对应的unicode为99，a对应的unicode为97，L对应的unicode为108，所以字符串”call”的哈希值为 如果对每个字符去哈希值可能会比较耗时，所以可以通过间隔取N个字符来获取哈希值来节省时间，比如，可以 获取每8-9个字符来获取哈希值： public int GetHashCode(string str) { char[] s = str.ToCharArray(); int hash = 0; int skip = Math.Max(1, s.Length / 8); for (int i = 0; i 但是，对于某些情况，不同的字符串会产生相同的哈希值，这就是前面说到的哈希冲突（Hash Collisions），比如下面的四个字符串： 如果我们按照每8个字符取哈希的话，就会得到一样的哈希值。所以下面来讲解如何解决哈希碰撞： 三、避免哈希冲突 拉链法 通过哈希函数，我们可以将键转换为数组的索引(0-M-1)，但是对于两个或者多个键具有相同索引值的情况，我们需要有一种方法来处理这种冲突。 一种比较直接的办法就是，将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，这就是拉链法。下图很清楚的描述了什么是拉链法。 图中，”John Smith”和”Sandra Dee” 通过哈希函数都指向了152 这个索引，该索引又指向了一个链表， 在链表中依次存储了这两个字符串。 该方法的基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，以保证查找的效率。对采用拉链法的哈希实现的查找分为两步，首先是根据散列值找到对应的链表，然后沿着链表顺序找到相应的键。 实现基于拉链表的散列表，目标是选择适当的数组大小M，使得既不会因为空链表而浪费内存空间，也不会因为链表太而在查找上浪费太多时间。拉链表的优点在于，这种数组大小M的选择不是关键性的，如果存入的键多于预期，那么查找的时间只会比选择更大的数组稍长，另外，我们也可以使用更高效的结构来代替链表存储。如果存入的键少于预期，索然有些浪费空间，但是查找速度就会很快。所以当内存不紧张时，我们可以选择足够大的M，可以使得查找时间变为常数，如果内存紧张时，选择尽量大的M仍能够将性能提高M倍。 线性探测法 线性探测法是开放寻址法解决哈希冲突的一种方法，基本原理为，使用大小为M的数组来保存N个键值对，其中M>N，我们需要使用数组中的空位解决碰撞冲突。如下图所示： 对照前面的拉链法，在该图中，”Ted Baker” 是有唯一的哈希值153的，但是由于153被”Sandra Dee”占用了。而原先”Snadra Dee”和”John Smith”的哈希值都是152的，但是在对”Sandra Dee”进行哈希的时候发现152已经被占用了，所以往下找发现153没有被占用，所以存放在153上，然后”Ted Baker”哈希到153上，发现已经被占用了，所以往下找，发现154没有被占用，所以值存到了154上。 开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果： 命中，该位置的键和被查找的键相同 未命中，键为空 继续查找，该位置的键和被查找的键不同。 线性探查（Linear Probing）方式虽然简单，但是有一些问题，它会导致同类哈希的聚集。在存入的时候存在冲突，在查找的时候冲突依然存在。 Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/sort.html":{"url":"data-structure/sort.html","title":"排序","keywords":"","body":" 冒泡排序 基本思想: 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 Java实现 加入标记状态 flag 若在一次冒泡中，没有交换 则说明可以停止 减少运行时 public static void bubbleSort(int[] numbers) { int temp = 0; int size = numbers.length; boolean flag = true; for (int i = 0; i numbers[j + 1]) // 交换两数位置 { temp = numbers[j]; numbers[j] = numbers[j + 1]; numbers[j + 1] = temp; flag = true; } } } } 时间复杂度O(n*n) 选择排序算法 基本思想： 在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 Java 实现 public static void selectSort(int[] numbers) { int size = numbers.length; // 数组长度 int temp = 0; // 中间变量 for (int i = 0; i i; j--) { if (numbers[j] 时间复杂度O(n*n) 性能上优于冒泡排序 交换次数少 插入排序算法 基本思想： 每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。 Java 实现 public static void insertSort(int[] numbers) { int size = numbers.length; int temp = 0; int j = 0; for (int i = 1; i 0 && temp 时间复杂度 O(n*n) 性能上优于冒泡排序和选择排序 希尔排序算法 基本思想： 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 Java 实现 /** * 希尔排序的原理:根据需求，如果你想要结果从小到大排列，它会首先将数组进行分组，然后将较小值移到前面，较大值 * 移到后面，最后将整个数组进行插入排序，这样比起一开始就用插入排序减少了数据交换和移动的次数， * 可以说希尔排序是加强 版的插入排序 拿数组5, 2,8, 9, 1, 3，4来说，数组长度为7，当increment为3时，数组分为两个序列 * 5，2，8和9，1，3，4，第一次排序，9和5比较，1和2比较，3和8比较，4和比其下标值小increment的数组值相比较 * 此例子是按照从小到大排列，所以小的会排在前面，第一次排序后数组为5, 1, 3, 4, 2, 8，9 * 第一次后increment的值变为3/2=1,此时对数组进行插入排序， 实现数组从大到小排 */ public static void shellSort(int[] data) { int j = 0; int temp = 0; // 每次将步长缩短为原来的一半 for (int increment = data.length / 2; increment > 0; increment /= 2) { for (int i = increment; i = increment; j -= increment) { if (temp 时间复杂度O(n^1.5） 堆排序算法 基本思想: 堆排序是一种树形选择排序，是对直接选择排序的有效改进。 堆的定义下：具有n个元素的序列 （h1,h2,...,hn),当且仅当满足（hi>=h2i,hi>=h2i+1）或（hi 思想:初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个 堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。 Java 实现 public static void heapSort(int[] a){ int arrayLength = a.length; // 循环建堆 for (int i = 0; i = 0; i--) { // k保存正在判断的节点 int k = i; // 如果当前k节点的子节点存在 while (k * 2 + 1 时间复杂度O(nlogn）不适合待排序序列较少的情况 快速排序算法 基本思想： 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，则分别对这两部分继续进行排序，直到整个序列有序。 Java 实现 /** * 快速排序 * * @param numbers * 带排序数组 */ public static void quick(int[] numbers) { if (numbers.length > 0) // 查看数组是否为空 { quickSort(numbers, 0, numbers.length - 1); } } /** * * @param numbers * 带排序数组 * @param low * 开始位置 * @param high * 结束位置 */ public static void quickSort(int[] numbers, int low, int high) { if (low >= high) { return; } int middle = getMiddle(numbers, low, high); // 将numbers数组进行一分为二 quickSort(numbers, low, middle - 1); // 对低字段表进行递归排序 quickSort(numbers, middle + 1, high); // 对高字段表进行递归排序 } /** * 查找出中轴（默认是最低位low）的在numbers数组排序后所在位置 * * @param numbers * 带查找数组 * @param low * 开始位置 * @param high * 结束位置 * @return 中轴所在位置 */ public static int getMiddle(int[] numbers, int low, int high) { int temp = numbers[low]; // 数组的第一个作为中轴 while (low temp) { high--; } numbers[low] = numbers[high];// 比中轴小的记录移到低端 while (low 时间复杂度O(nlogn） 快速排序在序列中元素很少时，效率将比较低，不如插入排序，因此一般在序列中元素很少时使用插入排序，这样可以提高整体效率。 归并排序算法 基本思想: 归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 Java 实现 /** * 归并排序 * 简介:将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列 * 时间复杂度为O(nlogn) * 稳定排序方式 * @param nums 待排序数组 * @return 输出有序数组 */ public static int[] sort(int[] nums, int low, int high) { int mid = (low + high) / 2; if (low 时间复杂度O(nlogn） 各种算法的时间复杂度等性能比较 Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/mass_data_processing.html":{"url":"data-structure/mass_data_processing.html","title":"海量数据处理","keywords":"","body":"一、海量数据处理 所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。 那解决办法呢? 针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/trie树。 针对空间，无非就一个办法：大而化小，分而治之（hash映射）。 二、算法/数据结构基础 1.Bloom Filter Bloom Filter（BF）是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。它是一个判断元素是否存在集合的快速的概率算法。Bloom Filter有可能会出现错误判断，但不会漏掉判断。也就是Bloom Filter判断元素不再集合，那肯定不在。如果判断元素存在集合中，有一定的概率判断错误。因此，Bloom Filter不适合那些“零错误”的应用场合。 而在能容忍低错误率的应用场合下，Bloom Filter比其他常见的算法（如hash，折半查找）极大节省了空间。 适用范围 可以用来实现数据字典，进行数据的判重，或者集合求交集 具体参考：海量数据处理之Bloom Filter详解 2.Hash Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 具体参考：从头到尾解析Hash表算法 3. Bit-map 所谓的Bit-map就是用一个bit位来标记某个元素对应的值。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。 如果说了这么多还没明白什么是Bit-map，那么我们来看一个具体的例子，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0(如下图：) 然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0x01 然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下： 具体参考：数据结构：位图法 4.堆 堆是一种特殊的二叉树，具备以下两种性质 1）每个节点的值都大于（或者都小于，称为最小堆）其子节点的值 2）树是完全平衡的，并且最后一层的树叶都在最左边这样就定义了一个最大堆。 如下图用一个数组来表示堆： 5.trie树 下面我们有and,as,at,cn,com这些关键词，那么如何构建trie树呢？ 从上面的图中，我们或多或少的可以发现一些好玩的特性。 第一：根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 第二：从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。 第三：每个单词的公共前缀作为一个字符节点保存。 适用范围： 前缀统计，词频统计。 具体参考：6天通吃树结构—— 第五天 Trie树 6.外排序 适用范围： 大数据的排序，去重 基本原理及要点： 外部排序的两个独立阶段： 1）首先按内存大小，将外存上含n个记录的文件分成若干长度L的子文件或段。依次读入内存并利用有效的内部排序对他们进行排序，并将排序后得到的有序字文件重新写入外存，通常称这些子文件为归并段。 2）对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件为之。 外排序的优化方法：置换选择 败者树原理，最优归并树 具体参考：选择置换+败者树搞定外部排序 三、面试问题解决 ①、海量日志数据，提取出某日访问百度次数最多的那个IP。 算法思想：分而治之+Hash 1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理； 2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址； 3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址； 4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP； ②、 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。 可以在内存中处理，典型的Top K算法 算法思想：hashmap+堆 1.先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计； 2.借助堆这个数据结构，找出Top K，时间复杂度为O(N*logK)。 或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 ③、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。 算法思想：分而治之 + hash统计 + 堆排序 1.顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 2.对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。 3.取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。 ④、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。 方案1： 算法思想：分而治之 + hash统计 + 堆排序 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件中。这样新生成的文件每个的大小大约也1G，大于1G继续按照上述思路分。 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。 对这10个文件进行归并排序（内排序与外排序相结合）。 方案2： 算法思想：hashmap+堆 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。 ⑤、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url 方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。 算法思想：分而治之 + hash统计 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。 方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。 ⑥、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。 采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。 ⑦、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？ 方案1：申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。 方案2：因为2^32为40亿多，所以给定一个数可能在，也可能不在其中； 这里我们把40亿个数中的每一个用32位的二进制来表示 假设这40亿个数开始放在一个文件中。 然后将这40亿个数分成两类: 1.最高位为0 2.最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数=20亿（这相当于折半了）； 与要查找的数的最高位比较并接着进入相应的文件再查找 再然后把这个文件为又分成两类: 1.次最高位为0 2.次最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数=10亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。 ....... 以此类推，就可以找到了。 Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"sql/SQL.html":{"url":"sql/SQL.html","title":"SQL","keywords":"","body":"1.创建表 语法 CREATE TABLE ( [列级完整性约束条件] [, [列级完整性约束条件]]…); 列级完整性约束条件有NULL[可为空]、NOT NULL[不为空]、UNIQUE[唯一]，可以组合使用，但是不能重复和对立关系同时存在。 示例 -- 创建学生表 CREATE TABLE Student ( Id INT NOT NULL UNIQUE PRIMARY KEY, Name VARCHAR(20) NOT NULL, Age INT NULL, Gender VARCHAR(4) NULL ); 2.删除表 语法 DROP TABLE ; 示例 -- 删除学生表 DROP TABLE Student; 3.清空表 语法 TRUNCATE TABLE ; 示例 -- 删除学生表 TRUNCATE TABLE Student; 4.修改表 语法 -- 添加列 ALTER TABLE [ADD [列级完整性约束条件]] -- 删除列 ALTER TABLE [DROP COLUMN ] -- 修改列 ALTER TABLE [MODIFY COLUMN [列级完整性约束条件]] 示例 -- 添加学生表`Phone`列 ALTER TABLE Student ADD Phone VARCHAR(15) NULL; -- 删除学生表`Phone`列 ALTER TABLE Student DROP COLUMN Phone; -- 修改学生表`Phone`列 ALTER TABLE Student MODIFY Phone VARCHAR(13) NULL; 5.查询 语法 SELECT [ALL | DISTINCT] [,]… FROM [,]… [WHERE ] [GROUP BY [HAVING ]] [ORDER BY [ASC|DESC]…] SQL查询语句的顺序：SELECT、FROM、WHERE、GROUP BY、HAVING、ORDER BY。SELECT、FROM是必须的，HAVING子句只能与GROUP BY搭配使用。 示例 SELECT * FROM Student WHERE Id>10 GROUP BY Age HAVING AVG(Age) > 20 ORDER BY Id DESC 6.插入 语法 -- 插入不存在的数据 INSERT INTO [(字段名[,字段名]…)] VALUES (常量[,常量]…); -- 将查询的数据插入到数据表中 INSERT INTO [(字段名[,字段名]…)] SELECT 查询语句; 示例 -- 插入不存在的数据 INSERT INTO Student (Name,Age,Gender) VALUES ('Andy',30,'女'); -- 将查询的数据插入到数据表中 INSERT INTO Student (Name,Age,Gender) SELECT Name,Age,Gender FROM Student_T WHERE Id >10; 7.更新 语法 UPDATE SET 列名=值表达式[,列名=值表达式…] [WHERE 条件表达式] 示例 -- 将Id在(10,100)的Age加1 UPDATE Student SET Age= Age+1 WHERE Id>10 AND Id 8.删除 语法 DELETE FROM [WHERE 条件表达式] 示例 -- 删除Id小于10的数据记录 DELETE FROM Student WHERE Id 9.索引 索引是一种特殊的查询表，可以被数据库搜索引擎用来加速数据的检索。简单说来，索引就是指向表中数据的指针。数据库的索引同书籍后面的索引非常相像。 例如，如果想要查阅一本书中与某个特定主题相关的所有页面，你会先去查询索引（索引按照字母表顺序列出了所有主题），然后从索引中找到一页或者多页与该主题相关的页面。 索引能够提高 SELECT 查询和 WHERE 子句的速度，但是却降低了包含 UPDATE 语句或 INSERT 语句的数据输入过程的速度。索引的创建与删除不会对表中的数据产生影响。 创建索引需要使用 CREATE INDEX 语句，该语句允许对索引命名，指定要创建索引的表以及对哪些列进行索引，还可以指定索引按照升序或者降序排列。 同 UNIQUE 约束一样，索引可以是唯一的。这种情况下，索引会阻止列中（或者列的组合，其中某些列有索引）出现重复的条目。 创建索引 语法 CREATE [UNIQUE] [CLUSTER] INDEX ON ([][,[]]…); UNIQUE：表明此索引的每一个索引值只对应唯一的数据记录 CLUSTER：表明建立的索引是聚集索引 次序：可选ASC(升序)或DESC(降序)，默认ASC 示例 -- 建立学生表索引：单一字段Id索引倒序 CREATE UNIQUE INDEX INDEX_SId ON Student (Id DESC); -- 建立学生表索引：多个字段Id、Name索引倒序 CREATE UNIQUE INDEX INDEX_SId_SName ON Student (Id DESC,Name DESC); 删除索引 语法 DROP INDEX ; 示例 -- 删除学生表索引 INDEX_SId DROP INDEX INDEX_SId; 10.视图 视图无非就是存储在数据库中并具有名字的 SQL 语句，或者说是以预定义的 SQL 查询的形式存在的数据表的成分。 视图可以包含表中的所有列，或者仅包含选定的列。视图可以创建自一个或者多个表，这取决于创建该视图的 SQL 语句的写法。 视图，一种虚拟的表，允许用户执行以下操作： 以用户或者某些类型的用户感觉自然或者直观的方式来组织数据； 限制对数据的访问，从而使得用户仅能够看到或者修改（某些情况下）他们需要的数据； 从多个表中汇总数据，以产生报表。 创建视图 语法 CREATE VIEW AS SELECT 查询子句 [WITH CHECK OPTION] 查询子句：子查询可以是任何SELECT语句，但是常不允许含有ORDER BY子句和DISTINCT短语； WITH CHECK OPTION：表示对UPDATE、INSERT、DELETE操作时要保证更新。 更新视图： 视图可以在特定的情况下更新： SELECT 子句不能包含 DISTINCT 关键字 SELECT 子句不能包含任何汇总函数（summary functions） SELECT 子句不能包含任何集合函数（set functions） SELECT 子句不能包含任何集合运算符（set operators） SELECT 子句不能包含 ORDER BY 子句 FROM 子句中不能有多个数据表 WHERE 子句不能包含子查询（subquery） 查询语句中不能有 GROUP BY 或者 HAVING 计算得出的列不能更新 视图必须包含原始数据表中所有的 NOT NULL 列，从而使 INSERT 查询生效。 示例 CREATE VIEW VIEW_Stu_Man AS SELECT * FROM Student WHERE Gender = '男' WITH CHECK OPTION 删除视图 语法 DROP VIEW ; 示例 DROP VIEW VIEW_Stu_Man; 11.ORDER BY ORDER BY 子句根据一列或者多列的值，按照升序或者降序排列数据。某些数据库默认以升序排列查询结果。 语法 SELECT [ALL | DISTINCT] [,]… FROM [,]… [WHERE ] [ORDER BY ] [ASC | DESC]; ORDER BY 子句可以同时使用多个列作为排序条件。无论用哪一列作为排序条件，都要确保该列在存在。 示例 SELECT * FROM CUSTOMERS ORDER BY NAME DESC 12.WHERE WHERE 子句用于有条件地从单个表中取回数据或者将多个表进行合并。 如果条件满足，则查询只返回表中满足条件的值。你可以用 WHERE 子句来过滤查询结果，只获取必要的记录。 WHERE 子句不仅可以用于 SELECT 语句，还可以用于 UPDATE、DELETE 等语句。 语法 SELECT [ALL | DISTINCT] [,]… FROM [,]… WHERE 在指定条件时，可以使用关系运算符和逻辑运算符，例如 >、、=、LIKE、NOT 等。 示例 SELECT ID, NAME, SALARY FROM CUSTOMERS WHERE SALARY > 2000; 13.LIKE LIKE 子句通过通配符来将一个值同其他相似的值作比较。可以同 LIKE 运算符一起使用的通配符有两个： 百分号（%） 下划线（_） 百分号代表零个、一个或者多个字符。下划线则代表单个数字或者字符。两个符号可以一起使用。 语法 % 和 _ 的基本语法如下： SELECT FROM table_name WHERE column LIKE 'XXXX%' SELECT FROM table_name WHERE column LIKE '%XXXX%' SELECT FROM table_name WHERE column LIKE 'XXXX_' SELECT FROM table_name WHERE column LIKE '_XXXX' SELECT FROM table_name WHERE column LIKE '_XXXX_' 你可以将多个条件用 AND 或者 OR　连接在一起。这里，XXXX　为任何数字值或者字符串。 示例 下面这些示例中，每个 WHERE 子句都有不同的 LIKE 子句，展示了 % 和 _ 的用法: 语句 描述 WHERE SALARY LIKE '200%' 找出所有 200 打头的值 WHERE SALARY LIKE '%200%' 找出所有含有 200 的值 WHERE SALARY LIKE '_00%' 找出所有第二位和第三位为 0 的值 WHERE SALARY LIKE '2%%' 找出所有以 2 开始，并且长度至少为 3 的值 WHERE SALARY LIKE '%2' 找出所有以 2 结尾的值 WHERE SALARY LIKE '_2%3' 找出所有第二位为 2，并且以3结束的值 WHERE SALARY LIKE '2___3' 找出所有以 2 开头以 3 结束的五位数 14.HAVING HAVING 子句使你能够指定过滤条件，从而控制查询结果中哪些组可以出现在最终结果里面。 WHERE 子句对被选择的列施加条件，而 HAVING 子句则对 GROUP BY 子句所产生的组施加条件。 语法 下面可以看到 HAVING 子句在 SELECT 查询中的位置： SELECT FROM WHERE GROUP BY HAVING ORDER BY 在 SELECT 查询中，HAVING 子句必须紧随 GROUP BY 子句，并出现在 ORDER BY 子句（如果有的话）之前。带有 HAVING 子句的 SELECT 语句的语法如下所示： SELECT column1, column2 FROM table1, table2 WHERE [ conditions ] GROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2 示例 考虑 CUSTOMERS 表，表中的记录如下所示： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ 下面是一个有关 HAVING 子句使用的实例，该实例将会筛选出出现次数大于或等于 2 的所有记录。 SELECT ID, NAME, AGE, ADDRESS, SALARY FROM CUSTOMERS GROUP BY age HAVING COUNT(age) >= 2; 其执行结果如下所示： +----+--------+-----+---------+---------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+--------+-----+---------+---------+ | 2 | Khilan | 25 | Delhi | 1500.00 | +----+--------+-----+---------+---------+ 15.DISTINCT DISTINCT 关键字同 SELECT 语句一起使用，可以去除所有重复记录，只返回唯一项。 有时候，数据表中可能会有重复的记录。在检索这些记录的时候，应该只取回唯一的记录，而不是重复的。 语法 使用 DISTINCT 关键字去除查询结果中的重复记录的基本语法如下所示： SELECT DISTINCT column1, column2,.....columnN FROM table_name WHERE [condition] 示例 SELECT DISTINCT SALARY FROM CUSTOMERS ORDER BY SALARY 去除（SALARY 字段）重复记录。 16.AND和OR AND 和 OR 运算符可以将多个条件结合在一起，从而过滤 SQL 语句的返回结果。这两个运算符被称作连接运算符。 AND 语法 SELECT column1, column2, columnN FROM table_name WHERE [condition1] AND [condition2]...AND [conditionN]; 将 N 个条件用 AND 运算符结合在一起。对于 SQL 语句要执行的动作来说——无论是事务还是查询，AND 运算符连接的所有条件都必须为 TRUE。 示例 SELECT ID, NAME, SALARY FROM CUSTOMERS WHERE SALARY > 2000 AND age OR 语法 SELECT column1, column2, columnN FROM table_name WHERE [condition1] OR [condition2]...OR [conditionN] 你可以将 N 个条件用 OR 运算符结合在一起。对于 SQL 语句要执行的动作来说——无论是事务还是查询，OR 运算符连接的所有条件中只需要有一个为 TRUE 即可。 示例 SELECT ID, NAME, SALARY FROM CUSTOMERS WHERE SALARY > 2000 OR age 17.UNION UNION 子句/运算符用于将两个或者更多的 SELECT 语句的运算结果组合起来。 在使用 UNION 的时候，每个 SELECT 语句必须有相同数量的选中列、相同数量的列表达式、相同的数据类型，并且它们出现的次序要一致，不过长度不一定要相同。 语法 SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE condition] UNION SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE condition] 这里的条件可以是任何根据你的需要而设的条件。 示例 SELECT Txn_Date FROM Store_Information UNION SELECT Txn_Date FROM Internet_Sales; UNION ALL 子句： UNION ALL 运算符用于将两个 SELECT 语句的结果组合在一起，重复行也包含在内。 其他类似语句 INTERSECT子句： 用于组合两个 SELECT 语句，但是只返回两个 SELECT 语句的结果中都有的行。 EXCEPT 子句： 组合两个 SELECT 语句，并将第一个 SELECT 语句的结果中存在，但是第二个 SELECT 语句的结果中不存在的行返回。 18.JOIN 连接（JOIN） 子句用于将数据库中两个或者两个以上表中的记录组合起来。连接通过共有值将不同表中的字段组合在一起。 考虑下面两个表，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ （b）另一个表是 ORDERS 表： +-----+---------------------+-------------+--------+ |OID | DATE | CUSTOMER_ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用 SELECT 语句将这个两张表连接（JOIN）在一起： SQL> SELECT ID, NAME, AGE, AMOUNT FROM CUSTOMERS, ORDERS WHERE CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句的运行结果如下所示： +----+----------+-----+--------+ | ID | NAME | AGE | AMOUNT | +----+----------+-----+--------+ | 3 | kaushik | 23 | 3000 | | 3 | kaushik | 23 | 1500 | | 2 | Khilan | 25 | 1560 | | 4 | Chaitali | 25 | 2060 | +----+----------+-----+--------+ SQL 连接类型 SQL 中有多种不同的连接： 内连接（INNER JOIN）：当两个表中都存在匹配时，才返回行。 左连接（LEFT JOIN）：返回左表中的所有行，如果左表中行在右表中没有匹配行，则结果中右表中的列返回空值。 右连接（RIGHT JOIN）：恰与左连接相反，返回右表中的所有行，如果右表中行在左表中没有匹配行，则结果中左表中的列返回空值。 全连接（FULL JOIN）：返回左表和右表中的所有行。当某行在另一表中没有匹配行，则另一表中的列返回空值 内连接 语法 SELECT table1.column1, table2.column2... FROM table1 INNER JOIN table2 ON table1.common_field = table2.common_field; 示例 考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用内连接将这两个表连接在一起： SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS INNER JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +----+----------+--------+---------------------+ | ID | NAME | AMOUNT | DATE | +----+----------+--------+---------------------+ | 3 | kaushik | 3000 | 2009-10-08 00:00:00 | | 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | +----+----------+--------+---------------------+ 左连接 语法 SELECT table1.column1, table2.column2... FROM table1 LEFT JOIN table2 ON table1.common_field = table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例 考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用左连接将这两个表连接在一起： SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +----+----------+--------+---------------------+ | ID | NAME | AMOUNT | DATE | +----+----------+--------+---------------------+ | 1 | Ramesh | NULL | NULL | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 | | 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | | 5 | Hardik | NULL | NULL | | 6 | Komal | NULL | NULL | | 7 | Muffy | NULL | NULL | +----+----------+--------+---------------------+ 右连接 语法 SELECT table1.column1, table2.column2... FROM table1 RIGHT JOIN table2 ON table1.common_field = table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例 考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用右连接将这两个表连接在一起： SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +------+----------+--------+---------------------+ | ID | NAME | AMOUNT | DATE | +------+----------+--------+---------------------+ | 3 | kaushik | 3000 | 2009-10-08 00:00:00 | | 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | +------+----------+--------+---------------------+ 全连接 语法 SELECT table1.column1, table2.column2... FROM table1 FULL JOIN table2 ON table1.common_field = table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例 考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在让我们用全连接将两个表连接在一起： SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS FULL JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +------+----------+--------+---------------------+ | ID | NAME | AMOUNT | DATE | +------+----------+--------+---------------------+ | 1 | Ramesh | NULL | NULL | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 | | 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | | 5 | Hardik | NULL | NULL | | 6 | Komal | NULL | NULL | | 7 | Muffy | NULL | NULL | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 | | 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | +------+----------+--------+---------------------+ 如果你所用的数据库不支持全连接，比如 MySQL，那么你可以使用 UNION ALL子句来将左连接和右连接结果组合在一起： SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID UNION ALL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID 19.常用函数 COUNT函数是 SQL 中最简单的函数了，对于统计由 SELECT 语句返回的记录非常有用。 要理解 COUNT 函数，请考虑 employee_tbl 表，表中的记录如下所示： SELECT * FROM employee_tbl; +------+------+------------+--------------------+ | id | name | work_date | daily_typing_pages | +------+------+------------+--------------------+ | 1 | John | 2007-01-24 | 250 | | 2 | Ram | 2007-05-27 | 220 | | 3 | Jack | 2007-05-06 | 170 | | 3 | Jack | 2007-04-06 | 100 | | 4 | Jill | 2007-04-06 | 220 | | 5 | Zara | 2007-06-06 | 300 | | 5 | Zara | 2007-02-06 | 350 | +------+------+------------+--------------------+ 7 rows in set (0.00 sec) 现在，假设你想要统计上表中记录的总数，那么可以依如下所示步骤达到目的： SELECT COUNT(*) FROM employee_tbl ; +----------+ | COUNT(*) | +----------+ | 7 | +----------+ 1 row in set (0.01 sec) 类似地，如果你想要统计 Zara 的数目，就可以像下面这样： SELECT COUNT(*) FROM employee_tbl WHERE name=\"Zara\"; +----------+ | COUNT(*) | +----------+ | 2 | +----------+ 1 row in set (0.04 sec) 注意：所有的 SQL 查询都是不区分大小写的，因此在 WHERE 子句的条件中，ZARA 和 Zara 是没有任何区别的。 CONCAT 函数用于将两个字符串连接为一个字符串，试一下下面这个例子： SELECT CONCAT('FIRST ', 'SECOND'); +----------------------------+ | CONCAT('FIRST ', 'SECOND') | +----------------------------+ | FIRST SECOND | +----------------------------+ 1 row in set (0.00 sec) 要对 CONCAT 函数有更为深入的了解，请考虑 employee_tbl 表，表中记录如下所示： SELECT * FROM employee_tbl; +------+------+------------+--------------------+ | id | name | work_date | daily_typing_pages | +------+------+------------+--------------------+ | 1 | John | 2007-01-24 | 250 | | 2 | Ram | 2007-05-27 | 220 | | 3 | Jack | 2007-05-06 | 170 | | 3 | Jack | 2007-04-06 | 100 | | 4 | Jill | 2007-04-06 | 220 | | 5 | Zara | 2007-06-06 | 300 | | 5 | Zara | 2007-02-06 | 350 | +------+------+------------+--------------------+ 7 rows in set (0.00 sec) 现在，假设你想要将上表中所有的姓名（name）、id和工作日（work_date）连接在一起，那么可以通过如下的命令来达到目的： SELECT CONCAT(id, name, work_date) FROM employee_tbl; +-----------------------------+ | CONCAT(id, name, work_date) | +-----------------------------+ | 1John2007-01-24 | | 2Ram2007-05-27 | | 3Jack2007-05-06 | | 3Jack2007-04-06 | | 4Jill2007-04-06 | | 5Zara2007-06-06 | | 5Zara2007-02-06 | +-----------------------------+ 7 rows in set (0.00 sec) SUM函数用于找出表中记录在某字段处的总和。 要理解 SUM 函数，请考虑 employee_tbl 表，表中记录如下所示： SELECT * FROM employee_tbl; +------+------+------------+--------------------+ | id | name | work_date | daily_typing_pages | +------+------+------------+--------------------+ | 1 | John | 2007-01-24 | 250 | | 2 | Ram | 2007-05-27 | 220 | | 3 | Jack | 2007-05-06 | 170 | | 3 | Jack | 2007-04-06 | 100 | | 4 | Jill | 2007-04-06 | 220 | | 5 | Zara | 2007-06-06 | 300 | | 5 | Zara | 2007-02-06 | 350 | +------+------+------------+--------------------+ 7 rows in set (0.00 sec) 现在，假设你想要获取 daily_typing_pages 的总和，那么你可以用如下命令来达到目的： SELECT SUM(daily_typing_pages) FROM employee_tbl; +-------------------------+ | SUM(daily_typing_pages) | +-------------------------+ | 1610 | +-------------------------+ 1 row in set (0.00 sec) 你还可以使用 GROUP BY 子句来得出不同记录分组的总和。下面的例子将会计算得出每个人的总和，，你将能够得到每个人打的总页数。 SELECT name, SUM(daily_typing_pages) FROM employee_tbl GROUP BY name; Copyright © ruheng.com 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "}}