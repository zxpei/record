{"./":{"url":"./","title":"Introduction","summary":"To be continued","keywords":"","body":"Introduction To be continued... Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2020-01-02 11:59:02 "},"data-structure/linear-list.html":{"url":"data-structure/linear-list.html","title":"线性表","keywords":"","body":"概要 线性表是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。本章先介绍线性表的几个基本组成部分：数组、单向链表、双向链表。 数组 数组有上界和下界，数组的元素在上下界内是连续的。 存储10,20,30,40,50的数组的示意图如下： 数组的特点是：数据是连续的；随机访问速度快。 数组中稍微复杂一点的是多维数组和动态数组。对于C语言而言，多维数组本质上也是通过一维数组实现的。至于动态数组，是指数组的容量能动态增长的数组；对于C语言而言，若要提供动态数组，需要手动实现；而对于C++而言，STL提供了Vector；对于Java而言，Collection集合中提供了ArrayList和Vector。 单向链表 单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。 单链表的示意图如下： 表头为空，表头的后继节点是\"节点10\"(数据为10的节点)，\"节点10\"的后继节点是\"节点20\"(数据为10的节点)，... 单链表删除节点 删除\"节点30\" 删除之前：\"节点20\" 的后继节点为\"节点30\"，而\"节点30\" 的后继节点为\"节点40\"。 删除之后：\"节点20\" 的后继节点为\"节点40\"。 单链表添加节点 在\"节点10\"与\"节点20\"之间添加\"节点15\" 添加之前：\"节点10\" 的后继节点为\"节点20\"。 添加之后：\"节点10\" 的后继节点为\"节点15\"，而\"节点15\" 的后继节点为\"节点20\"。 单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。 双向链表 双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。 双链表的示意图如下： 表头为空，表头的后继节点为\"节点10\"(数据为10的节点)；\"节点10\"的后继节点是\"节点20\"(数据为10的节点)，\"节点20\"的前继节点是\"节点10\"；\"节点20\"的后继节点是\"节点30\"，\"节点30\"的前继节点是\"节点20\"；...；末尾节点的后继节点是表头。 双链表删除节点 删除\"节点30\" 删除之前：\"节点20\"的后继节点为\"节点30\"，\"节点30\" 的前继节点为\"节点20\"。\"节点30\"的后继节点为\"节点40\"，\"节点40\" 的前继节点为\"节点30\"。 删除之后：\"节点20\"的后继节点为\"节点40\"，\"节点40\" 的前继节点为\"节点20\"。 双链表添加节点 在\"节点10\"与\"节点20\"之间添加\"节点15\" 添加之前：\"节点10\"的后继节点为\"节点20\"，\"节点20\" 的前继节点为\"节点10\"。 添加之后：\"节点10\"的后继节点为\"节点15\"，\"节点15\" 的前继节点为\"节点10\"。\"节点15\"的后继节点为\"节点20\"，\"节点20\" 的前继节点为\"节点15\"。 双链表的Java实现 /** * Java 实现的双向链表。 * 注：java自带的集合包中有实现双向链表，路径是:java.util.LinkedList * * @author skywang * @date 2013/11/07 */ public class DoubleLink { // 表头 private DNode mHead; // 节点个数 private int mCount; // 双向链表“节点”对应的结构体 private class DNode { public DNode prev; public DNode next; public T value; public DNode(T value, DNode prev, DNode next) { this.value = value; this.prev = prev; this.next = next; } } // 构造函数 public DoubleLink() { // 创建“表头”。注意：表头没有存储数据！ mHead = new DNode(null, null, null); mHead.prev = mHead.next = mHead; // 初始化“节点个数”为0 mCount = 0; } // 返回节点数目 public int size() { return mCount; } // 返回链表是否为空 public boolean isEmpty() { return mCount==0; } // 获取第index位置的节点 private DNode getNode(int index) { if (index=mCount) throw new IndexOutOfBoundsException(); // 正向查找 if (index node = mHead.next; for (int i=0; i rnode = mHead.prev; int rindex = mCount - index -1; for (int j=0; j node = new DNode(t, mHead, mHead.next); mHead.next.prev = node; mHead.next = node; mCount++; return ; } DNode inode = getNode(index); DNode tnode = new DNode(t, inode.prev, inode); inode.prev.next = tnode; inode.prev = tnode; mCount++; return ; } // 将节点插入第一个节点处。 public void insertFirst(T t) { insert(0, t); } // 将节点追加到链表的末尾 public void appendLast(T t) { DNode node = new DNode(t, mHead.prev, mHead); mHead.prev.next = node; mHead.prev = node; mCount++; } // 删除index位置的节点 public void del(int index) { DNode inode = getNode(index); inode.prev.next = inode.next; inode.next.prev = inode.prev; inode = null; mCount--; } // 删除第一个节点 public void deleteFirst() { del(0); } // 删除最后一个节点 public void deleteLast() { del(mCount-1); } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/stack-queue.html":{"url":"data-structure/stack-queue.html","title":"栈和队","keywords":"","body":"一、栈 栈（stack），是一种线性存储结构，它有以下几个特点： (01) 栈中数据是按照\"后进先出（LIFO, Last In First Out）\"方式进出栈的。 (02) 向栈中添加/删除数据时，只能从栈顶进行操作。 栈通常包括的三种操作：push、peek、pop。 push -- 向栈中添加元素。 peek -- 返回栈顶元素。 pop -- 返回并删除栈顶元素的操作。 1.栈的示意图 栈中的数据依次是 30 --> 20 --> 10 2.出栈 出栈前：栈顶元素是30。此时，栈中的元素依次是 30 --> 20 --> 10 出栈后：30出栈之后，栈顶元素变成20。此时，栈中的元素依次是 20 --> 10 3. 入栈 入栈前：栈顶元素是20。此时，栈中的元素依次是 20 --> 10 入栈后：40入栈之后，栈顶元素变成40。此时，栈中的元素依次是 40 --> 20 --> 10 4.栈的Java实现 JDK包中也提供了\"栈\"的实现，它就是集合框架中的Stack类。 本部分使用数组实现栈，能存储任意类型的数据。 /** * Java : 数组实现的栈，能存储任意类型的数据 * * @author skywang * @date 2013/11/07 */ import java.lang.reflect.Array; public class GeneralArrayStack { private static final int DEFAULT_SIZE = 12; private T[] mArray; private int count; public GeneralArrayStack(Class type) { this(type, DEFAULT_SIZE); } public GeneralArrayStack(Class type, int size) { // 不能直接使用mArray = new T[DEFAULT_SIZE]; mArray = (T[]) Array.newInstance(type, size); count = 0; } // 将val添加到栈中 public void push(T val) { mArray[count++] = val; } // 返回“栈顶元素值” public T peek() { return mArray[count-1]; } // 返回“栈顶元素值”，并删除“栈顶元素” public T pop() { T ret = mArray[count-1]; count--; return ret; } // 返回“栈”的大小 public int size() { return count; } // 返回“栈”是否为空 public boolean isEmpty() { return size()==0; } // 打印“栈” public void PrintArrayStack() { if (isEmpty()) { System.out.printf(\"stack is Empty\\n\"); } System.out.printf(\"stack size()=%d\\n\", size()); int i=size()-1; while (i>=0) { System.out.println(mArray[i]); i--; } } } 二、队列 队列（Queue），是一种线性存储结构。它有以下几个特点： (1) 队列中数据是按照\"先进先出（FIFO, First-In-First-Out）\"方式进出队列的。 (2) 队列只允许在\"队首\"进行删除操作，而在\"队尾\"进行插入操作。 队列通常包括的两种操作：入队列 和 出队列。 1.队列的示意图 队列中有10，20，30共3个数据。 2.出队列 出队列前：队首是10，队尾是30。 出队列后：出队列(队首)之后。队首是20，队尾是30。 3.入队列 入队列前：队首是20，队尾是30。 入队列后：40入队列(队尾)之后。队首是20，队尾是40。 4.队列的Java实现 JDK中的Queue接口就是\"队列\"，它的实现类也都是队列，用的最多的是LinkedList。本部分使用数组实现队列，能存储任意类型的数据。 /** * Java : 数组实现“队列”，只能存储int数据。 * * @author skywang * @date 2013/11/07 */ public class ArrayQueue { private int[] mArray; private int mCount; public ArrayQueue(int sz) { mArray = new int[sz]; mCount = 0; } // 将val添加到队列的末尾 public void add(int val) { mArray[mCount++] = val; } // 返回“队列开头元素” public int front() { return mArray[0]; } // 返回“队首元素值”，并删除“队首元素” public int pop() { int ret = mArray[0]; mCount--; for (int i=1; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/tree.html":{"url":"data-structure/tree.html","title":"树","keywords":"","body":"一、前言 树作为一种重要的数据结构，即是面试重点考察知识点，也是实际生产应用中可能会灵活应用的一种数据结构。那么其重要性不言而喻，无论是在剑指offer，还是在leetcode中，都有很多关于树的题目。 本部分内容主要介绍树的一些基础概念及Java实现，同时介绍一些常见的树，如二叉搜索树，平衡树，红黑树等。 二、目录 树的基础 其他常见的树 并查集 B-树，B+树，B*树 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/tree/tree-introduction.html":{"url":"data-structure/tree/tree-introduction.html","title":"树的基础","keywords":"","body":"一、树的介绍 1.树的定义 树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。 把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： (01) 每个节点有零个或多个子节点； (02) 没有父节点的节点称为根节点； (03) 每一个非根节点有且只有一个父节点； (04) 除了根节点外，每个子节点可以分为多个不相交的子树。 2.树的基本术语 若一个结点有子树，那么该结点称为子树根的\"双亲\"，子树的根是该结点的\"孩子\"。有相同双亲的结点互为\"兄弟\"。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。 结点的度：结点拥有的子树的数目。 叶子：度为零的结点。 分支结点：度不为零的结点。 树的度：树中结点的最大的度。 层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。 树的高度：树中结点的最大层次。 无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置。 有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。 森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。 二、二叉树的介绍 1.二叉树的定义 二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。 2. 二叉树的性质 二叉树有以下几个性质： 性质1：二叉树第i层上的结点数目最多为$2^{i-1}$ (i≥1)。 性质2：深度为k的二叉树至多有$2^k - 1$个结点(k≥1)。 性质3：包含n个结点的二叉树的高度至少为$log_2(n+1)$。 性质4：在任意一棵二叉树中，若叶子结点的个数为n0，度为2的结点数为n2，则n0=n2+1。 2.1 性质1：二叉树第i层上的结点数目最多为$2^{i-1}$(i≥1) 证明：下面用\"数学归纳法\"进行证明。 ​ (01) 当i=1时，第i层的节点数目为1。因为第1层上只有一个根结点，所以命题成立。 ​ (02) 假设当i>1，第i层的节点数目为$2^{i-1}$。这个是根据(01)推断出来的！ 下面根据这个假设，推断出\"第(i+1)层的节点数目为$2^{i}$\"即可。 由于二叉树的每个结点至多有两个孩子，故\"第(i+1)层上的结点数目\" 最多是 \"第i层的结点数目的2倍\"。即，第(i+1)层上的结点数目最大值=2×$2^{i-1}$=$2^{i}$。 故假设成立，原命题得证！ 2.2 性质2：深度为k的二叉树至多有$2^{k}-1$个结点(k≥1) 证明：在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用\"性质1\"可知，深度为k的二叉树的结点数至多为： ​ $ 2^0+2^1+…+2^{k-1}=2^k-1$ 故原命题得证！ 2.3 性质3：包含n个结点的二叉树的高度至少为$log_2(n+1)$ 证明：根据\"性质2\"可知，高度为h的二叉树最多有$2^{h}-1$个结点。反之，对于包含n个节点的二叉树的高度至少为$log_2(n+1)$。 2.4 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1 证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=\"0度结点数(n0)\" + \"1度结点数(n1)\" + \"2度结点数(n2)\"。由此，得到等式一。 (等式一) n=n0+n1+n2 另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。 (等式二) n=n1+2n2+1 由(等式一)和(等式二)计算得到：n0=n2+1。原命题得证！ 3. 满二叉树，完全二叉树和二叉查找树 3.1 满二叉树 定义：高度为h，并且由$2^{h}-1$个结点的二叉树，被称为满二叉树。 3.2 完全二叉树 定义：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。 特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。 3.3 二叉查找树 定义：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] = key[x]。 在二叉查找树中： (01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； (02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； (03) 任意节点的左、右子树也分别为二叉查找树。 (04) 没有键值相等的节点（no duplicate nodes）。 三、二叉查找树的Java实现 1.二叉查找树节点的定义 public class BSTree> { private BSTNode mRoot; // 根结点 public class BSTNode> { T key; // 关键字(键值) BSTNode left; // 左孩子 BSTNode right; // 右孩子 BSTNode parent; // 父结点 public BSTNode(T key, BSTNode parent, BSTNode left, BSTNode right) { this.key = key; this.parent = parent; this.left = left; this.right = right; } } ...... } BSTree是二叉树，它保含了二叉树的根节点mRoot；mRoot是BSTNode类型，而BSTNode是二叉查找树的节点，它是BSTree的内部类。BSTNode包含二叉查找树的几个基本信息： (01) key -- 它是关键字，是用来对二叉查找树的节点进行排序的。 (02) left -- 它指向当前节点的左孩子。 (03) right -- 它指向当前节点的右孩子。 (04) parent -- 它指向当前节点的父结点。 2.遍历 这里讲解前序遍历、中序遍历、后序遍历3种方式。 2.1 前序遍历 若二叉树非空，则执行以下操作： (01) 访问根结点； (02) 先序遍历左子树； (03) 先序遍历右子树。 前序遍历代码 private void preOrder(BSTNode tree) { if(tree != null) { System.out.print(tree.key+\" \"); preOrder(tree.left); preOrder(tree.right); } } public void preOrder() { preOrder(mRoot); } 2.2 中序遍历 若二叉树非空，则执行以下操作： (01) 中序遍历左子树； (02) 访问根结点； (03) 中序遍历右子树。 中序遍历代码 private void inOrder(BSTNode tree) { if(tree != null) { inOrder(tree.left); System.out.print(tree.key+\" \"); inOrder(tree.right); } } public void inOrder() { inOrder(mRoot); } 2.3 后序遍历 若二叉树非空，则执行以下操作： (01) 后序遍历左子树； (02) 后序遍历右子树； (03) 访问根结点。 后序遍历代码 private void postOrder(BSTNode tree) { if(tree != null) { postOrder(tree.left); postOrder(tree.right); System.out.print(tree.key+\" \"); } } public void postOrder() { postOrder(mRoot); } 看看下面这颗树的各种遍历方式： 对于上面的二叉树而言， (01) 前序遍历结果： 3 1 2 5 4 6 (02) 中序遍历结果： 1 2 3 4 5 6 (03) 后序遍历结果： 2 1 4 6 5 3 3. 查找 递归版本的代码 /* * (递归实现)查找\"二叉树x\"中键值为key的节点 */ private BSTNode search(BSTNode x, T key) { if (x==null) return x; int cmp = key.compareTo(x.key); if (cmp 0) return search(x.right, key); else return x; } public BSTNode search(T key) { return search(mRoot, key); } 非递归版本的代码 /* * (非递归实现)查找\"二叉树x\"中键值为key的节点 */ private BSTNode iterativeSearch(BSTNode x, T key) { while (x!=null) { int cmp = key.compareTo(x.key); if (cmp 0) x = x.right; else return x; } return x; } public BSTNode iterativeSearch(T key) { return iterativeSearch(mRoot, key); } 4. 最大值和最小值 查找最大值的代码 /* * 查找最大结点：返回tree为根结点的二叉树的最大结点。 */ private BSTNode maximum(BSTNode tree) { if (tree == null) return null; while(tree.right != null) tree = tree.right; return tree; } public T maximum() { BSTNode p = maximum(mRoot); if (p != null) return p.key; return null; } 查找最小值的代码 /* * 查找最小结点：返回tree为根结点的二叉树的最小结点。 */ private BSTNode minimum(BSTNode tree) { if (tree == null) return null; while(tree.left != null) tree = tree.left; return tree; } public T minimum() { BSTNode p = minimum(mRoot); if (p != null) return p.key; return null; } 5. 前驱和后继 节点的前驱：是该节点的左子树中的最大节点。 节点的后继：是该节点的右子树中的最小节点。 查找前驱节点的代码 /* * 找结点(x)的前驱结点。即，查找\"二叉树中数据值小于该结点\"的\"最大结点\"。 */ public BSTNode predecessor(BSTNode x) { // 如果x存在左孩子，则\"x的前驱结点\"为 \"以其左孩子为根的子树的最大结点\"。 if (x.left != null) return maximum(x.left); // 如果x没有左孩子。则x有以下两种可能： // (01) x是\"一个右孩子\"，则\"x的前驱结点\"为 \"它的父结点\"。 // (02) x是\"一个左孩子\"，则查找\"x的最低的父结点，并且该父结点要具有右孩子\"，找到的这个\"最低的父结点\"就是\"x的前驱结点\"。 BSTNode y = x.parent; while ((y!=null) && (x==y.left)) {//满足条件，不断往上追溯，直到找到右祖先结点 x = y; y = y.parent; } return y; } 查找后继节点的代码 /* * 找结点(x)的后继结点。即，查找\"二叉树中数据值大于该结点\"的\"最小结点\"。 */ public BSTNode successor(BSTNode x) { // 如果x存在右孩子，则\"x的后继结点\"为 \"以其右孩子为根的子树的最小结点\"。 if (x.right != null) return minimum(x.right); // 如果x没有右孩子。则x有以下两种可能： // (01) x是\"一个左孩子\"，则\"x的后继结点\"为 \"它的父结点\"。 // (02) x是\"一个右孩子\"，则查找\"x的最低的父结点，并且该父结点要具有左孩子\"，找到的这个\"最低的父结点\"就是\"x的后继结点\"。 BSTNode y = x.parent; while ((y!=null) && (x==y.right)) {//满足条件，不断往上追溯，直到找到右祖先结点 x = y; y = y.parent; } return y; } 6. 插入 插入节点的代码 /* * 将结点插入到二叉树中 * * 参数说明： * tree 二叉树的 * z 插入的结点 */ private void insert(BSTree bst, BSTNode z) { int cmp; BSTNode y = null; BSTNode x = bst.mRoot; // 查找z的插入位置 while (x != null) { y = x; cmp = z.key.compareTo(x.key); if (cmp z=new BSTNode(key,null,null,null); // 如果新建结点失败，则返回。 if (z != null) insert(this, z); } 注：本文实现的二叉查找树是允许插入相同键值的节点的。 7. 删除 删除节点的代码 /* * 删除结点(z)，并返回被删除的结点 * * 参数说明： * bst 二叉树 * z 删除的结点 */ private BSTNode remove(BSTree bst, BSTNode z) { BSTNode x=null; BSTNode y=null; if ((z.left == null) || (z.right == null) ) y = z; else y = successor(z); if (y.left != null) x = y.left; else x = y.right; if (x != null) x.parent = y.parent; if (y.parent == null) bst.mRoot = x; else if (y == y.parent.left) y.parent.left = x; else y.parent.right = x; if (y != z) z.key = y.key; return y; } /* * 删除结点(z)，并返回被删除的结点 * * 参数说明： * tree 二叉树的根结点 * z 删除的结点 */ public void remove(T key) { BSTNode z, node; if ((z = search(mRoot, key)) != null) if ( (node = remove(this, z)) != null) node = null; } 8. 打印 打印二叉查找树的代码 /* * 打印\"二叉查找树\" * * key -- 节点的键值 * direction -- 0，表示该节点是根节点; * -1，表示该节点是它的父结点的左孩子; * 1，表示该节点是它的父结点的右孩子。 */ private void print(BSTNode tree, T key, int direction) { if(tree != null) { if(direction==0) // tree是根节点 System.out.printf(\"%2d is root\\n\", tree.key); else // tree是分支节点 System.out.printf(\"%2d is %2d's %6s child\\n\", tree.key, key, direction==1?\"right\" : \"left\"); print(tree.left, tree.key, -1); print(tree.right,tree.key, 1); } } public void print() { if (mRoot != null) print(mRoot, mRoot.key, 0); } 9. 销毁 销毁二叉查找树的代码 /* * 销毁二叉树 */ private void destroy(BSTNode tree) { if (tree==null) return ; if (tree.left != null) destroy(tree.left); if (tree.right != null) destroy(tree.right); tree=null; } public void clear() { destroy(mRoot); mRoot = null; } 四、树的深度/广度优先遍历 树的深度优先遍历需要用到额外的数据结构--->栈；而广度优先遍历需要队列来辅助；这里以二叉树为例来实现。 import java.util.ArrayDeque; public class BinaryTree { static class TreeNode{ int value; TreeNode left; TreeNode right; public TreeNode(int value){ this.value=value; } } TreeNode root; public BinaryTree(int[] array){ root=makeBinaryTreeByArray(array,1); } /** * 采用递归的方式创建一颗二叉树 * 传入的是二叉树的数组表示法 * 构造后是二叉树的二叉链表表示法 */ public static TreeNode makeBinaryTreeByArray(int[] array,int index){ if(index stack=new ArrayDeque(); stack.push(root); while(stack.isEmpty()==false){ TreeNode node=stack.pop(); System.out.print(node.value+\" \"); if(node.right!=null){ stack.push(node.right); } if(node.left!=null){ stack.push(node.left); } } System.out.print(\"\\n\"); } /** * 广度优先遍历 * 采用非递归实现 * 需要辅助数据结构：队列 */ public void levelOrderTraversal(){ if(root==null){ System.out.println(\"empty tree\"); return; } ArrayDeque queue=new ArrayDeque(); queue.add(root); while(queue.isEmpty()==false){ TreeNode node=queue.remove(); System.out.print(node.value+\" \"); if(node.left!=null){ queue.add(node.left); } if(node.right!=null){ queue.add(node.right); } } System.out.print(\"\\n\"); } /** * 13 * / \\ * 65 5 * / \\ \\ * 97 25 37 * / /\\ / * 22 4 28 32 */ public static void main(String[] args) { int[] arr={0,13,65,5,97,25,0,37,22,0,4,28,0,0,32,0}; BinaryTree tree=new BinaryTree(arr); tree.depthOrderTraversal(); tree.levelOrderTraversal(); } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/tree/other-tree.html":{"url":"data-structure/tree/other-tree.html","title":"其他常见的树","keywords":"","body":"一、AVL树 AVL树是高度平衡的而二叉树。它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。 上面的两张图片，左边的是AVL树，它的任何节点的两个子树的高度差别都 二、红黑树 R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树的特性: （1）每个节点或者是黑色，或者是红色。 （2）根节点是黑色。 （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] （4）如果一个节点是红色的，则它的子节点必须是黑色的。 （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 注意： (01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。 (02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。 红黑树示意图如下： 红黑树的应用 红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。 例如，Java集合中的TreeMap和HashMap，都是通过红黑树去实现的。 三、哈夫曼树 Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。 定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。 这个定义里面涉及到了几个陌生的概念，下面就是一颗哈夫曼树，我们来看图解答。 (01) 路径和路径长度 定义：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。 例子：100和80的路径长度是1，50和30的路径长度是2，20和10的路径长度是3。 (02) 结点的权及带权路径长度 定义：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。 例子：节点20的路径长度是3，它的带权路径长度= 路径长度x权 = 3 x 20 = 60。 (03) 树的带权路径长度 定义：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。 例子：示例中，树的WPL= 1x100 + 2x50 + 3x20 + 3x10 = 100 + 100 + 60 + 30 = 290。 比较下面两棵树 上面的两棵树都是以{10, 20, 50, 100}为叶子节点的树。 左边的树WPL=2x10 + 2x20 + 2x50 + 2x100 = 360 右边的树WPL=290 左边的树WPL > 右边的树的WPL。你也可以计算除上面两种示例之外的情况，但实际上右边的树就是{10,20,50,100}对应的哈夫曼树。至此，应该堆哈夫曼树的概念有了一定的了解了，下面看看如何去构造一棵哈夫曼树。 哈夫曼树的图文解析 假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为： 1. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)； 2. 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和； 3. 从森林中删除选取的两棵树，并将新树加入森林； 4. 重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。 以{5,6,7,8,15}为例，来构造一棵哈夫曼树。 第1步：创建森林，森林包括5棵树，这5棵树的权值分别是5,6,7,8,15。 第2步：在森林中，选择根节点权值最小的两棵树(5和6)来进行合并，将它们作为一颗新树的左右孩子(谁左谁右无关紧要，这里，我们选择较小的作为左孩子)，并且新树的权值是左右孩子的权值之和。即，新树的权值是11。 然后，将\"树5\"和\"树6\"从森林中删除，并将新的树(树11)添加到森林中。 第3步：在森林中，选择根节点权值最小的两棵树(7和8)来进行合并。得到的新树的权值是15。 然后，将\"树7\"和\"树8\"从森林中删除，并将新的树(树15)添加到森林中。 第4步：在森林中，选择根节点权值最小的两棵树(11和15)来进行合并。得到的新树的权值是26。 然后，将\"树11\"和\"树15\"从森林中删除，并将新的树(树26)添加到森林中。 第5步：在森林中，选择根节点权值最小的两棵树(15和26)来进行合并。得到的新树的权值是41。 然后，将\"树15\"和\"树26\"从森林中删除，并将新的树(树41)添加到森林中。 此时，森林中只有一棵树(树41)。这棵树就是我们需要的哈夫曼树！ Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/tree/Union-Find.html":{"url":"data-structure/tree/Union-Find.html","title":"并查集","keywords":"","body":"一、并查集的介绍 并查集（Union/Find）从名字可以看出，主要涉及两种基本操作:合并和查找。这说明，初始时并查集中的元素是不相交的，经过一系列的基本操作(Union)，最终合并成一个大的集合。 而在某次合并之后，有一种合理的需求：某两个元素是否已经处在同一个集合中了？因此就需要Find操作。 并查集是一种 不相交集合 的数据结构，设有一个动态集合S={s1，s2，s3，.....sn}，每个集合通过一个代表来标识，该代表中集合中的某个元素。 比如，若某个元素 x 是否在集合 s1 中(Find操作)，返回集合 s1 的代表元素即可。这样，判断两个元素是否在同一个集合中也是很方便的，只要看find(x) 和 find(y) 是否返回同一个代表即可。 为什么是动态集合S呢？因为随着Union操作，动态集合S中的子集合个数越来越少。 数据结构的基本操作决定了它的应用范围，对并查集而言，一个简单的应用就是判断无向图的连通分量个数，或者判断无向图中任何两个顶点是否连通。 二、并查集的存储结构及实现分析 ①存储结构 并查集(大S)由若干子集合si构成，并查集的逻辑结构就是一个森林。si表示森林中的一棵子树。一般以子树的根作为该子树的代表。 而对于并查集的存储结构，可用一维数组和链表来实现。这里主要介绍一维数组的实现。 根据前面介绍的基本操作再加上存储结构，并查集类的实现架构如下： public class DisjSets { private int[] s; private int count;//记录并查集中子集合的个数(子树的个数) public DisjSets(int numElements) { //构造函数，负责初始化并查集 } public void unionByHeight(int root1, int root2){ //union操作 } public int find(int x){ //find 操作 } } 由于Find操作需要找到该子集合的代表元素，而代表元素是树根，因此需要保存树中结点的父亲，对于每一个结点，如果知道了父亲，沿着父结点链就可以最终找到树根。 为了简单起见，假设一维数组s中的每个元素 s[i] 表示该元素 i 的父亲。这里有两个需要注意的地方：①我们用一维数组来存储并查集，数组的元素s[i]表示的是结点的父亲的位置。②数组元素的下标 i 则是结点的标识。如：s[5]=4，节点5 在数组的第4号位置处。 假设有并查集中6个元素，初始时，所有的元素都相互独立，处在不同的集合中： 对应的一维数组初始化如下： 因为，初始时每个元素代表一个集合，该元素本身就是树根。树根的父结点用 -1 来表示。代码实现如下： public DisjSets(int numElements) { s = new int[numElements]; count = numElements; //初始化并查集,相当于新建了s.length 个互不相交的集合 for(int i = 0; i ②基本操作实现 Union操作就是将两个不相交的子集合合并成一个大集合。简单的Union操作是非常容易实现的，因为只需要把一棵子树的根结点指向另一棵子树即可完成合并。 比如合并 节点3 和节点4： 这里的合并很随意，把任意一棵子树的结点指向另一棵子树结点就完成了合并。 public void union(int root1, int root2){ s[root2] = root1;//将root1作为root2的新树根 } 但是，这只是一个简单的情况，如果待合并的两棵子树很大，而且高度不一样时，如何使得合并操作生成的新的子树的高度最小？因为高度越小的子树Find操作越快。 后面会介绍一种更好的合并策略，以支持Quick Union/Find。 Find操作就是查找某个元素所在的集合，返回该集合的代表元素。在union(3,4) 和 union(1,2)后，并查集如下： 此时的一维数组如下： 此时一共有4个子集合。第一个集合的代表元素为0，第二个集合的代表元素为1，第三个集合的代表元素为3，第四个集合的代表元素为5，故： find(2)返回1，find(0)返回0。因为 结点3 和 结点4 在同一个集合内，find(4)返回3，find(3)返回3。 public int find(int x){ if(s[x] 这里find(int x)返回的是最里层递归执行后，得到的值。由于只有树根的父结点位置小于0，故返回的是树根结点的标识。 （数组中索引 i 处的元素 s[i] 小于0，表示 结点i 是根结点.....） 三、Union/Find的改进----Quick Union/Find 上面介绍的Union操作很随意：任选一棵子树，将另一棵子树的根指向它即完成了合并。如果一直按照上述方式合并，很可能产生一棵非常不平衡的子树。 比如在上面的基础上union(2,3)后 树越来越高了，此时会影响到Find操作的效率。比如，find(4)时，会一直沿着父结点遍历直到根，4-->3-->2-->1 这里引入一种新的合并策略，这是一种启发式策略，称之为按秩合并：将秩小的子树的根指向秩大的子树的根。 秩的定义：对每个结点，用秩表示结点高度的一个上界。为什么是上界？ 因为路径压缩不完全与按高度求并兼容。路径压缩会改变树的高度，这样在Union操作之前，我们就无法获得子树的高度的精确值，因此就不计算高度的精确值，而是存储每棵树的高度的估计值，这个值称之为秩。 说了这么多，按秩求并就是在合并之前，先判断下哪棵子树更高，让矮的子树的根指向高的子树的根。 除了按高度求并之外，还可以按大小求并，即先判断下哪棵子树含有的结点数目多，让较小的子树的根指向较大的子树的根。 对于按高度求并，需要解释下数组中存储的元素：是高度的负值再减去1。这样，初始时，所有元素都是-1，而树根节点的高度为0，s[i]=-1。 按高度求并的代码如下： /** * * @param root1 并查集中以root1为代表的某个子集 * @param roo2 并查集中以root2为代表的某个子集 * 按高度(秩)合并以root1 和 root2为代表的两个集合 */ public void unionByHeight(int root1, int root2){ if(find(root1) == find(root2)) return;//root1 与 root2已经连通了 if(s[root2] 使用了路径压缩的Find的操作 上面程序代码find方法只是简单地把待查找的元素所在的根返回。路径压缩是指，在find操作进行时，使find查找路径中的顶点(的父亲)都直接指向为树根（这很明显地改变了子树的高度） 如何使find查找路径中经过的每个顶点都直接指向树根呢？只需要小小改动一下就可以了，这里用到了非常神奇的递归。修改后的find代码如下： public int find(int x){ if(s[x] 因为递归最终得到的返回值是根元素。第5行将根元素直接赋值给s[x]，s[x]在每次递归过程中相当于结点x的父结点指针。 关于路径压缩对按”秩“求并的兼容性问题 上面的unionByHeight(int , int)是按照两棵树的高度来进行合并的。但是find操作中的路径压缩会对树的高度产生影响。使用了路径压缩后，树的高度变化了，但是数组并没有更新这个变化。因为无法更新！！（我们没有在Find操作中去计算原来的树的高度，然后再计算新的树的高度，这样不现实，复杂度太大了） 举个例子： 依次高度unionByHeight(3, 4)、unionByHeight(1, 3)、unionByHeight(1, 0)后，并查集如下： 此时，数组中的元素如下： 可以看出，此时只有两棵子树，一棵根结点为1，另一棵只有一个结点5。结点1的s[1]=-3，它所表示是该子树的高度为2，如果此时执行find(4)，会改变这棵树的高度！但是，数组s中存储的根的高度却没有更新，只会更新查找路径上的顶点的高度。执行完find(4)后，变成： 查找路径为 4-->3-->1，find(4)使得查找路径上的所有顶点的父结点指向了根。如，将结点4 指向了根。但是没有根结点的高度（没有影响树根的秩），因为s[1]的值仍为-3 -3表示的高度为2，但是树的高度实际上已经变成了1 执行find(4)之后，树实际上是这样的： （关于路径压缩对按秩合并有影响，我一直有个疑问，希望有大神指点啊）。。。。 路径压缩改变了子树的高度，而这个高度是按秩求的依据。，而且当高度改变之后，我们是无法更新这个变化了的高度的。那这会不会影响按秩求并的正确性？或者说使按秩求并达不到减小新生成的子树的高度的效果？ 四、并查集的应用 并查集数据结构非常简单，基本操作也很简单。但是用途感觉很大。比如，求解无向图中连通分量的个数，生成迷宫…… 这些应用本质上就是：初始时都是一个个不连通的对象，经过一步步处理，变成连通的了。。。。。 如迷宫，初始时，起点和终点不连通，随机地打开起点到终点路径上的一个方向，直至起点和终点连通了，就生成了一个迷宫。 如，无向图的连通分量个数，初始时，将无向图中各个顶点视为不连通的子集合，对图中每一条边，相当于union这条边对应的两个顶点分别所在的集合，直至所有的边都处理完后，还剩下的集合的个数即为连通分量的个数。 五、完整代码 public class DisjSets { private int[] s; private int count;//记录并查集中子集合的个数(子树的个数) public DisjSets(int numElements) { s = new int[numElements]; count = numElements; //初始化并查集,相当于新建了s.length 个互不相交的集合 for(int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/tree/b-tree.html":{"url":"data-structure/tree/b-tree.html","title":"B-树，B+树，B*树","keywords":"","body":"一、概念 Binary Tree（二叉树）：二叉树的每个节点最多有两个子节点 Binary Search Tree（二叉搜索树）：二叉搜索树每个节点只存储一个键值，并且左子树（如果有）所有节点的值都要小于根节点的值，右子树（如果有）所有节点的值都要大于根节点的值。 B-Tree（Balanced Tree）：也就是今天要说的B-树，这里的-不是minus的意思，而是作为连接符的横杠，而我们也经常把B-树直接翻译为B树，所以B树与B-树通常是指一个概念，B代表的是Balance，而不是Binary。而B+树和B*树则是B-树的基础上正对不同场景的优化版本，将会在后文中有所介绍。 在大规模数据存储中，二叉查找树的深度会过大，当内存无法存储所有节点数据时，需要读取磁盘，进行IO操作，从而树的高度越高，I/O操作次数越多，效率也就越低。所以诸如之前所讲的红黑树，AVL树 因为树的高度太高而不适合这种需要大量IO操作的查询。所以，B树通过多叉的实现来降低树的高度，从而减少IO操作的次数。 二、B树（B-树） 为方便描述，下面一律用B树这个名称。B树是一种多路平衡搜索树（非二叉），若其是M路，则： 任意非叶子节点最多可以有M个子女，且M>2； 根节点的子女数为[2,M]； 除了根节点以外的非叶子节点的子女数目为M/2（取上整）个到M个； 每个节点存放至少M/2-1（取上整）和至多M-1个键值（至少两个）； 非叶子节点的关键字个数=指向子女的指针个数-1； 非叶子节点的关键字K[1],K[2],…,K[M-1]且有K[i] 非叶子节点的指针P[1],P[2],…,P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1],K[i])的子树； 所有叶子节点都位于同一层。 B树与二叉搜索树的最大区别在于其每个节点可以存不止一个键值，并且其子女不止两个，不过还是需要满足键值数=子女数-1。因此，对于相同数量的键值，B树比二叉搜索树要更加矮一些，特别是当M较大时，树高会更低。 上图中是一个简单的B树，在实际应用中，M可以取到很大，比如大于1000。一般情况下M的取值会使得每个磁盘盘块可以正好存放一个B数节点。上图中的35节点，35是一个key（或者说是索引，比如磁盘文件的文件名），而小黑块则代表的是该key所指向的内容在磁盘中实际的存储位置，是一个指针（比如35这个文件在硬盘中的位置）。 B树的搜索 B树的搜索与二叉搜索树类似，只不过需要在节点内部进行一次搜索查找。从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点； B树的插入 B树的插入首先查找插入所在的节点，若该节点未满，插入即可，若该节点以及满了，则需要将该节点分裂，并将该节点的中间的元素移动到父节点上，若父节点未满，则结束，若父节点也满了，则需要继续分裂父节点，如此不断向上，直到根节点，如果根节点也满了，则分裂根节点，从而树的高度+1。 下面是B树插入的一个演示动画，往B树中一次插入的元素为6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4。 B树的删除 B树的删除首先要找到删除的节点，并删除节点中的元素，如果删除的元素有左右孩子，则上移左孩子最右节点或右孩子最左节点到父节点，若没有左右孩子，则直接删除。删除后，若某节点中元素数目不符合B树要求（小于M/2-1取上整），则需要看起相邻的兄弟节点是否有多余的元素，若有，则可以向父节点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有点类似于左旋）。若其相邻兄弟节点没有多余的元素，则与其兄弟节点合并成一个节点，此时也需要将父节点中的一个元素一起合并。 三、B+树 B+树是B树的一个变种，其也是一种多路平衡搜索树，其与B树的主要区别是： 非叶子节点的指针数量与关键字数量相等； 非叶子节点的子树指针P[i]，指向关键字值属于[K[i],K[i+1]）的子树（B树是开区间，B+树是左闭右开，也就是说B树不允许关键字重复，而B+树允许）； 所有关键字都在叶子节点出现，所有的叶子节点增加了一个链指针（稠密索引，且链表中的关键字切好是有序的）； 非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储数据的数据层。 B+树主要是应文件系统所需而产生的。文件系统中，文件的目录是一级一级索引，只有最底层的叶子节点（文件）保存数据。非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，所有的非叶子节点都可以看成是索引部分。 非叶子节点（比如[5，28，65]）只是一个key（索引，实际的数据在叶子节点上，对应于叶子节点[5,8,9]中的5，[28,30,33]中的28，[65,73,79]中的65才是真正的数据或指向真实数据的指针）。 B+树的搜索 B+的搜索与B树也是基本相同的。唯一的区别是B+树只有达到叶子结点才命中，因为只有叶节点中存放着真实数据或真实数据的指正，而B树可以在非叶子结点命中，其性能也等价于在元素全集做一次二分查找。 B+树的插入 B+树的插入与B树类似，如果节点中有多余的空间放入元素，则直接插入即可。如果节点本来就已经满了，则将其分裂为两个节点，并将其中间元素的索引放入到父节点中，在这里如果是叶子节点的话，是拷贝中间元素的索引到父节点中（因为叶子节点需要包含所有的元素），而如果是非叶子节点，则是上移节点的中间元素到父节点中。 下面是B+树插入的一个演示动画： B+树的删除 在叶节点中删除元素，如果节点还满足B+树的要求，则okay。如果元素个数过少，并且其邻近兄弟节点有多余的元素，则从邻近兄弟节点中借一个元素，并修改父节点中的索引使其满足新的划分。如果其邻近兄弟节点也没有多余的元素，则将其和邻近兄弟节点合并，并且我们需要修改其父节点的索引以满足新的划分。并且如果父节点的索引元素太少不满足要求，则需要继续看起兄弟节点是否多余，如果没有多余则还需要与兄弟节点合并，如此不断向上，直到根节点。如果根节点中元素也被删除，则把根节点删除，并由合并来的节点作为新的根节点，树的高度减1。 四、B+树与B树的比较 B+树的非叶子节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，盘块所能容纳的关键字数量也越多，具有更好的空间局部性，一次性读入内存的需要查找的关键字也越多，相对的IO读写次数也就降低了。 另外对于B+树来说，因为非叶子节点只是叶子节点中关键字的索引，所以任何关键字的查找都必须走一条从根节点到叶子节点的路，所有关键字查询的路径长度相同。而若经常访问的元素离根节点很近，则B树访问更迅速，因为其不一定要到叶子节点。 数据库索引采用B+树的主要原因是B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题，而也正是为了解决该问题，B+树应运而生。因为叶子节点中增加了一个链指针，B+树只需要取遍历叶子节点可以实现整棵树的遍历。而且数据库中基于范围的查询是非常频繁的，B树对基于范围的查询效率太低。 五、B*树 B*树又是B+树的变种，其与B+树的区别有： B*树在B+树的非根和非叶子节点再增加指向兄弟节点的指针 B树规定非叶子节点的键值个数至少为(2/3)M，这样每个节点的使用率就从B+树的1/2上升到2/3，所以空间使用率更高。 B树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；B树分配新结点的概率比B+树要低，空间使用率更高； Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph.html":{"url":"data-structure/graph.html","title":"图","keywords":"","body":"一、前言 图作为数据结构中最复杂的一种结构，涉及到一些著名的算法，如dijkstra,flyod等。 此外，图的一些特性也值得我们学习，是笔试和面试中会高频考察的知识点。 本部分内容不仅介绍了图的基础概念及特性，同时介绍了图涉及的一些算法的Java实现。 二、目录 图的基础 拓扑排序 Kruskal算法 Prim算法 Dijkstra算法 Floyd算法 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/graph-introduction.html":{"url":"data-structure/graph/graph-introduction.html","title":"图的基础","keywords":"","body":"一、图的基本概念 1. 图的定义 定义：图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为\"顶点(vertex)\"，而点与点之间的连线则被成为\"边或弧\"(edege)。通常记为，G=(V,E)。 2. 图的种类 根据边是否有方向，将图可以划分为：无向图和有向图。 2.1 无向图 上面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中， (01) V1={A,B,C,D,E,F}。 V1表示由\"A,B,C,D,E,F\"几个顶点组成的集合。 (02) E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)...等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。 2.2 有向图 上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中， (01) V2={A,C,B,F,D,E,G}。 V2表示由\"A,B,C,D,E,F,G\"几个顶点组成的集合。 (02) A2={,,,,,,,,}。 E1是由矢量,矢量...等等组成的集合。其中，矢量 3. 邻接点和度 3.1 邻接点 一条边上的两个顶点叫做邻接点。 例如，上面无向图G0中的顶点A和顶点C就是邻接点。 在有向图中，除了邻接点之外；还有\"入边\"和\"出边\"的概念。 顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。 例如，上面有向图G2中的B和E是邻接点；是B的出边，还是E的入边。 3.2 度 在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。 例如，上面无向图G0中顶点A的度是2。 在有向图中，度还有\"入度\"和\"出度\"之分。 某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。 顶点的度=入度+出度。 例如，上面有向图G2中，顶点B的入度是2，出度是3；顶点B的度=2+3=5。 4. 路径和回路 路径：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。 路径长度：路径中\"边的数量\"。 简单路径：若一条路径上顶点不重复出现，则是简单路径。 回路：若路径的第一个顶点和最后一个顶点相同，则是回路。 简单回路：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。 5. 连通图和连通分量 连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。 连通分量：非连通图中的各个连通子图称为该图的连通分量。 6. 权 在学习\"哈夫曼树\"的时候，了解过\"权\"的概念。图中权的概念与此类似。 上面就是一个带权的图。 二、图的存储结构 上面了解了\"图的基本概念\"，下面开始介绍图的存储结构。图的存储结构，常用的是\"邻接矩阵\"和\"邻接表\"。 1. 邻接矩阵 邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。 假设图中顶点数为n，则邻接矩阵定义为： 下面通过示意图来进行解释。 图中的G1是无向图和它对应的邻接矩阵。 图中的G2是无向图和它对应的邻接矩阵。 通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。 邻接矩阵的缺点就是比较耗费空间。 2. 邻接表 邻接表是图的一种链式存储表示方法。它是改进后的\"邻接矩阵\"，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。 图中的G1是无向图和它对应的邻接矩阵。 图中的G2是有向图和它对应的邻接矩阵。 三、图的深度/广度优先遍历 1. 深度优先搜索介绍 图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。 它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 显然，深度优先搜索是一个递归的过程。 2. 深度优先搜索图解 2.1 无向图的深度优先搜索 下面以\"无向图\"为例，来对深度优先搜索进行演示。 对上面的图G1进行深度优先遍历，从顶点A开始。 第1步：访问A。 第2步：访问(A的邻接点)C。 ​ 在第1步访问A之后，接下来应该访问的是A的邻接点，即\"C,D,F\"中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在\"D和F\"的前面，因此，先访问C。 第3步：访问(C的邻接点)B。 ​ 在第2步访问C之后，接下来应该访问C的邻接点，即\"B和D\"中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 第4步：访问(C的邻接点)D。 ​ 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 第5步：访问(A的邻接点)F。 ​ 前面已经访问了A，并且访问完了\"A的邻接点B的所有邻接点(包括递归的邻接点在内)\"；因此，此时返回到访问A的另一个邻接点F。 第6步：访问(F的邻接点)G。 第7步：访问(G的邻接点)E。 因此访问顺序是：A -> C -> B -> D -> F -> G -> E 2.2 有向图的深度优先搜索 下面以\"有向图\"为例，来对深度优先搜索进行演示。 对上面的图G2进行深度优先遍历，从顶点A开始。 第1步：访问A。 第2步：访问B。 ​ 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 第3步：访问C。 ​ 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 第4步：访问E。 ​ 接下来访问C的出边的另一个顶点，即顶点E。 第5步：访问D。 ​ 接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 第6步：访问F。 ​ 接下应该回溯\"访问A的出边的另一个顶点F\"。 第7步：访问G。 因此访问顺序是：A -> B -> C -> E -> D -> F -> G 3. 广度优先搜索介绍 广度优先搜索算法(Breadth First Search)，又称为\"宽度优先搜索\"或\"横向优先搜索\"，简称BFS。 它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。 4. 广度优先搜索图解 4.1 无向图的广度优先搜索 下面以\"无向图\"为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。 第1步：访问A。 第2步：依次访问C,D,F。 ​ 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在\"D和F\"的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 第3步：依次访问B,G。 ​ 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 第4步：访问E。 ​ 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。 因此访问顺序是：A -> C -> D -> F -> B -> G -> E 4.2 有向图的广度优先搜索 下面以\"有向图\"为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。 第1步：访问A。 第2步：访问B。 第3步：依次访问C,E,F。 ​ 在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 第4步：依次访问D,G。 ​ 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。 因此访问顺序是：A -> B -> C -> E -> F -> D -> G Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/topology.html":{"url":"data-structure/graph/topology.html","title":"拓扑排序","keywords":"","body":"一、拓扑排序介绍 拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。 这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！ 例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。 在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。 二、拓扑排序的算法图解 拓扑排序算法的基本步骤： 1. 构造一个队列Q(queue) 和 拓扑排序的结果队列T(topological)； 2. 把所有没有依赖顶点的节点放入Q； 3. 当Q还有顶点的时候，执行下面步骤： 3.1 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)； 3.2 对n每一个邻接点m(n是起点，m是终点)； 3.2.1 去掉边; 3.2.2 如果m没有依赖顶点，则把m放入Q; 注：顶点A没有依赖顶点，是指不存在以A为终点的边。 以上图为例，来对拓扑排序进行演示。 第1步：将B和C加入到排序结果中。 ​ 顶点B和顶点C都是没有依赖顶点，因此将C和C加入到结果集T中。假设ABCDEFG按顺序存储，因此先访问B，再访问C。访问B之后，去掉边和，并将A和D加入到队列Q中。同样的，去掉边和，并将F和G加入到Q中。 ​ (01) 将B加入到排序结果中，然后去掉边和；此时，由于A和D没有依赖顶点，因此并将A和D加入到队列Q中。 ​ (02) 将C加入到排序结果中，然后去掉边和；此时，由于F有依赖顶点D，G有依赖顶点A，因此不对F和G进行处理。 第2步：将A,D依次加入到排序结果中。 ​ 第1步访问之后，A,D都是没有依赖顶点的，根据存储顺序，先访问A，然后访问D。访问之后，删除顶点A和顶点D的出边。 第3步：将E,F,G依次加入到排序结果中。 因此访问顺序是：B -> C -> A -> D -> E -> F -> G 三、拓扑排序的代码说明 拓扑排序是对有向无向图的排序。下面以邻接表实现的有向图来对拓扑排序进行说明。 1. 基本定义 public class ListDG { // 邻接表中表对应的链表的顶点 private class ENode { int ivex; // 该边所指向的顶点的位置 ENode nextEdge; // 指向下一条弧的指针 } // 邻接表中表的顶点 private class VNode { char data; // 顶点信息 ENode firstEdge; // 指向第一条依附该顶点的弧 }; private VNode[] mVexs; // 顶点数组 ... } (01) ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。 (02) VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。 (03) ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。 2. 拓扑排序 /* * 拓扑排序 * * 返回值： * -1 -- 失败(由于内存不足等原因导致) * 0 -- 成功排序，并输入结果 * 1 -- 失败(该有向图是有环的) */ public int topologicalSort() { int index = 0; int num = mVexs.size(); int[] ins; // 入度数组 char[] tops; // 拓扑排序结果数组，记录每个节点的排序后的序号。 Queue queue; // 辅组队列 ins = new int[num]; tops = new char[num]; queue = new LinkedList(); // 统计每个顶点的入度数 for(int i = 0; i 说明： (01) queue的作用就是用来存储没有依赖顶点的顶点。它与前面所说的Q相对应。 (02) tops的作用就是用来存储排序结果。它与前面所说的T相对应。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/Kruskal.html":{"url":"data-structure/graph/Kruskal.html","title":"Kruskal算法","keywords":"","body":"一、最小生成树 在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。 例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。 二、克鲁斯卡尔算法介绍 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。 三、克鲁斯卡尔算法图解 以上图G4为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。 第1步：将边加入R中。 ​ 边的权值最小，因此将它加入到最小生成树结果R中。 第2步：将边加入R中。 ​ 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果R中。 第3步：将边加入R中。 ​ 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果R中。 第4步：将边加入R中。 ​ 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳过边。将边加入到最小生成树结果R中。 第5步：将边加入R中。 ​ 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果R中。 第6步：将边加入R中。 ​ 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳过边。将边加入到最小生成树结果R中。 此时，最小生成树构造完成！它包括的边依次是： 。 四、克鲁斯卡尔算法分析 根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题： 问题一 对图的所有边按照权值大小进行排序。 问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。 问题一很好解决，采用排序算法进行排序即可。 问题二，处理方式是：记录顶点在\"最小生成树\"中的终点，顶点的终点是\"在最小生成树中与它连通的最大顶点\"(关于这一点，后面会通过图片给出说明)。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。 以下图来进行说明： 在将 加入到最小生成树R中之后，这几条边的顶点就都有了终点： (01) C的终点是F。 (02) D的终点是F。 (03) E的终点是F。 (04) F的终点是F。 关于终点，就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是\"与它连通的最大顶点\"。 因此，接下来，虽然是权值最小的边。但是C和E的重点都是F，即它们的终点相同，因此，将加入最小生成树的话，会形成回路。这就是判断回路的方式。 五、克鲁斯卡尔算法的代码说明 有了前面的算法分析之后，下面我们来查看具体代码。这里选取\"邻接矩阵\"进行说明，对于\"邻接表\"实现的图在后面的源码中会给出相应的源码。 1. 基本定义 // 边的结构体 private static class EData { char start; // 边的起点 char end; // 边的终点 int weight; // 边的权重 public EData(char start, char end, int weight) { this.start = start; this.end = end; this.weight = weight; } }; EData是邻接矩阵边对应的结构体。 public class MatrixUDG { private int mEdgNum; // 边的数量 private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ... } MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示\"顶点i(即mVexs[i])\"和\"顶点j(即mVexs[j])\"是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 克鲁斯卡尔算法 /* * 克鲁斯卡尔（Kruskal)最小生成树 */ public void kruskal() { int index = 0; // rets数组的索引 int[] vends = new int[mEdgNum]; // 用于保存\"已有最小生成树\"中每个顶点在该最小树中的终点。 EData[] rets = new EData[mEdgNum]; // 结果数组，保存kruskal最小生成树的边 EData[] edges; // 图对应的所有边 // 获取\"图中所有的边\" edges = getEdges(); // 将边按照\"权\"的大小进行排序(从小到大) sortEdges(edges, mEdgNum); for (int i=0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/Prim.html":{"url":"data-structure/graph/Prim.html","title":"Prim算法","keywords":"","body":"一、普里姆算法介绍 普里姆(Prim)算法，是用来求加权连通图的最小生成树的算法。 基本思想 对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。 二、普里姆算法图解 以上图G4为例，来对普里姆进行演示(从第一个顶点A开始通过普里姆算法生成最小生成树)。 初始状态：V是所有顶点的集合，即V={A,B,C,D,E,F,G}；U和T都是空！ 第1步：将顶点A加入到U中。 ​ 此时，U={A}。 第2步：将顶点B加入到U中。 ​ 上一步操作之后，U={A}, V-U={B,C,D,E,F,G}；因此，边(A,B)的权值最小。将顶点B添加到U中；此时，U={A,B}。 第3步：将顶点F加入到U中。 ​ 上一步操作之后，U={A,B}, V-U={C,D,E,F,G}；因此，边(B,F)的权值最小。将顶点F添加到U中；此时，U={A,B,F}。 第4步：将顶点E加入到U中。 ​ 上一步操作之后，U={A,B,F}, V-U={C,D,E,G}；因此，边(F,E)的权值最小。将顶点E添加到U中；此时，U={A,B,F,E}。 第5步：将顶点D加入到U中。 ​ 上一步操作之后，U={A,B,F,E}, V-U={C,D,G}；因此，边(E,D)的权值最小。将顶点D添加到U中；此时，U={A,B,F,E,D}。 第6步：将顶点C加入到U中。 ​ 上一步操作之后，U={A,B,F,E,D}, V-U={C,G}；因此，边(D,C)的权值最小。将顶点C添加到U中；此时，U={A,B,F,E,D,C}。 第7步：将顶点G加入到U中。 ​ 上一步操作之后，U={A,B,F,E,D,C}, V-U={G}；因此，边(F,G)的权值最小。将顶点G添加到U中；此时，U=V。 此时，最小生成树构造完成！它包括的顶点依次是：A B F E D C G。 三、普里姆算法的代码说明 以\"邻接矩阵\"为例对普里姆算法进行说明。 1. 基本定义 public class MatrixUDG { private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ... } MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示\"顶点i(即mVexs[i])\"和\"顶点j(即mVexs[j])\"是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 普里姆算法 /* * prim最小生成树 * * 参数说明： * start -- 从图中的第start个元素开始，生成最小树 */ public void prim(int start) { int num = mVexs.length; // 顶点个数 int index=0; // prim最小树的索引，即prims数组的索引 char[] prims = new char[num]; // prim最小树的结果数组 int[] weights = new int[num]; // 顶点间边的权值 // prim最小生成树中第一个数是\"图中第start个顶点\"，因为是从start开始的。 prims[index++] = mVexs[start]; // 初始化\"顶点的权值数组\"， // 将每个顶点的权值初始化为\"第start个顶点\"到\"该顶点\"的权值。 for (int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/Dijkstra.html":{"url":"data-structure/graph/Dijkstra.html","title":"Dijkstra算法","keywords":"","body":"一、迪杰斯特拉算法介绍 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 基本思想 ​ 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。 ​ 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。 ​ 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是\"起点s到该顶点的路径\"。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 ... 重复该操作，直到遍历完所有顶点。 操作步骤 (1) 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为\"起点s到该顶点的距离\"[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。 (2) 从U中选出\"距离最短的顶点k\"，并将顶点k加入到S中；同时，从U中移除顶点k。 (3) 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。 (4) 重复步骤(2)和(3)，直到遍历完所有顶点。 单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。 二、迪杰斯特拉算法图解 以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。 初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！ 第1步：将顶点D加入到S中。 ​ 此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。 注:C(3)表示C到起点D的距离是3。 第2步：将顶点C加入到S中。 ​ 上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。 ​ 此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。 第3步：将顶点E加入到S中。 ​ 上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。 ​ 此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。 第4步：将顶点F加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。 第5步：将顶点G加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。 第6步：将顶点B加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。 第7步：将顶点A加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。 此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。 三、迪杰斯特拉算法的代码说明 以\"邻接矩阵\"为例对迪杰斯特拉算法进行说明。 1. 基本定义 public class MatrixUDG { private int mEdgNum; // 边的数量 private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ... } MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示\"顶点i(即mVexs[i])\"和\"顶点j(即mVexs[j])\"是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 迪杰斯特拉算法 /* * Dijkstra最短路径。 * 即，统计图中\"顶点vs\"到其它各个顶点的最短路径。 * * 参数说明： * vs -- 起始顶点(start vertex)。即计算\"顶点vs\"到其它顶点的最短路径。 * prev -- 前驱顶点数组。即，prev[i]的值是\"顶点vs\"到\"顶点i\"的最短路径所经历的全部顶点中，位于\"顶点i\"之前的那个顶点。 * dist -- 长度数组。即，dist[i]是\"顶点vs\"到\"顶点i\"的最短路径的长度。 */ public void dijkstra(int vs, int[] prev, int[] dist) { // flag[i]=true表示\"顶点vs\"到\"顶点i\"的最短路径已成功获取 boolean[] flag = new boolean[mVexs.length]; // 初始化 for (int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/graph/Floyd.html":{"url":"data-structure/graph/Floyd.html","title":"Floyd算法","keywords":"","body":"一、弗洛伊德算法介绍 和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。 基本思想 ​ 通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入一个矩阵S，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。 ​ 假设图G中顶点个数为N，则需要对矩阵S进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。 接下来开始，对矩阵S进行N次更新。第1次更新时，如果\"a[i][j]的距离\" > \"a[i][0]+a[0][j]\"(a[i][0]+a[0][j]表示\"i与j之间经过第1个顶点的距离\")，则更新a[i][j]为\"a[i][0]+a[0][j]\"。 同理，第k次更新时，如果\"a[i][j]的距离\" > \"a[i][k]+a[k][j]\"，则更新a[i][j]为\"a[i][k]+a[k][j]\"。更新N次之后，操作完成！ ​ 单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。 二、弗洛伊德算法图解 以上图G4为例，来对弗洛伊德进行算法演示。 初始状态：S是记录各个顶点间最短路径的矩阵。 第1步：初始化S。 ​ 矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。实际上，就是将图的原始矩阵复制到S中。 ​ 注:a[i][j]表示矩阵S中顶点i(第i个顶点)到顶点j(第j个顶点)的距离。 第2步：以顶点A(第1个顶点)为中介点，若a[i][j] > a[i][0]+a[0][j]，则设置a[i][j]=a[i][0]+a[0][j]。 ​ 以顶点a[1][6]，上一步操作之后，a[1][6]=∞；而将A作为中介点时，(B,A)=12，(A,G)=14，因此B和G之间的距离可以更新为16。 同理，依次将顶点B,C,D,E,F,G作为中介点，并更新a[i][j]的大小。 三、弗洛伊德算法的代码说明 以\"邻接矩阵\"为例对弗洛伊德算法进行说明，对于\"邻接表\"实现的图在后面会给出相应的源码。 1. 基本定义 public class MatrixUDG { private int mEdgNum; // 边的数量 private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ... } MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示\"顶点i(即mVexs[i])\"和\"顶点j(即mVexs[j])\"是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 弗洛伊德算法 /* * floyd最短路径。 * 即，统计图中各个顶点间的最短路径。 * * 参数说明： * path -- 路径。path[i][j]=k表示，\"顶点i\"到\"顶点j\"的最短路径会经过顶点k。 * dist -- 长度数组。即，dist[i][j]=sum表示，\"顶点i\"到\"顶点j\"的最短路径的长度是sum。 */ public void floyd(int[][] path, int[][] dist) { // 初始化 for (int i = 0; i tmp) { // \"i到j最短路径\"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // \"i到j最短路径\"对应的路径，经过k path[i][j] = path[i][k]; } } } } // 打印floyd最短路径的结果 System.out.printf(\"floyd: \\n\"); for (int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/hash.html":{"url":"data-structure/hash.html","title":"散列查找","keywords":"","body":"一、什么是哈希表 哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。 哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。 使用哈希查找有两个步骤: 使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突 处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。 哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。 二、哈希函数 哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。比如举个简单的例子，使用手机号码后三位就比前三位作为key更好，因为前三位手机号码的重复率很高。再比如使用身份证号码出生年月位数要比使用前几位数要更好。 在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。 1. 正整数 获取正整数哈希值最常用的方法是使用除留余数法。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。M一般取素数。 2. 字符串 将字符串作为键的时候，我们也可以将他作为一个大的整数，采用保留除余法。我们可以将组成字符串的每一个字符取值然后进行哈希，比如 public int GetHashCode(string str) { char[] s = str.ToCharArray(); int hash = 0; for (int i = 0; i 上面的哈希值是Horner计算字符串哈希值的方法，公式为: 举个例子，比如要获取”call”的哈希值，字符串c对应的unicode为99，a对应的unicode为97，L对应的unicode为108，所以字符串”call”的哈希值为 如果对每个字符去哈希值可能会比较耗时，所以可以通过间隔取N个字符来获取哈希值来节省时间，比如，可以 获取每8-9个字符来获取哈希值： public int GetHashCode(string str) { char[] s = str.ToCharArray(); int hash = 0; int skip = Math.Max(1, s.Length / 8); for (int i = 0; i 但是，对于某些情况，不同的字符串会产生相同的哈希值，这就是前面说到的哈希冲突（Hash Collisions），比如下面的四个字符串： 如果我们按照每8个字符取哈希的话，就会得到一样的哈希值。所以下面来讲解如何解决哈希碰撞： 三、避免哈希冲突 拉链法 通过哈希函数，我们可以将键转换为数组的索引(0-M-1)，但是对于两个或者多个键具有相同索引值的情况，我们需要有一种方法来处理这种冲突。 一种比较直接的办法就是，将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，这就是拉链法。下图很清楚的描述了什么是拉链法。 图中，”John Smith”和”Sandra Dee” 通过哈希函数都指向了152 这个索引，该索引又指向了一个链表， 在链表中依次存储了这两个字符串。 该方法的基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，以保证查找的效率。对采用拉链法的哈希实现的查找分为两步，首先是根据散列值找到对应的链表，然后沿着链表顺序找到相应的键。 实现基于拉链表的散列表，目标是选择适当的数组大小M，使得既不会因为空链表而浪费内存空间，也不会因为链表太而在查找上浪费太多时间。拉链表的优点在于，这种数组大小M的选择不是关键性的，如果存入的键多于预期，那么查找的时间只会比选择更大的数组稍长，另外，我们也可以使用更高效的结构来代替链表存储。如果存入的键少于预期，索然有些浪费空间，但是查找速度就会很快。所以当内存不紧张时，我们可以选择足够大的M，可以使得查找时间变为常数，如果内存紧张时，选择尽量大的M仍能够将性能提高M倍。 线性探测法 线性探测法是开放寻址法解决哈希冲突的一种方法，基本原理为，使用大小为M的数组来保存N个键值对，其中M>N，我们需要使用数组中的空位解决碰撞冲突。如下图所示： 对照前面的拉链法，在该图中，”Ted Baker” 是有唯一的哈希值153的，但是由于153被”Sandra Dee”占用了。而原先”Snadra Dee”和”John Smith”的哈希值都是152的，但是在对”Sandra Dee”进行哈希的时候发现152已经被占用了，所以往下找发现153没有被占用，所以存放在153上，然后”Ted Baker”哈希到153上，发现已经被占用了，所以往下找，发现154没有被占用，所以值存到了154上。 开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果： 命中，该位置的键和被查找的键相同 未命中，键为空 继续查找，该位置的键和被查找的键不同。 线性探查（Linear Probing）方式虽然简单，但是有一些问题，它会导致同类哈希的聚集。在存入的时候存在冲突，在查找的时候冲突依然存在。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/sort.html":{"url":"data-structure/sort.html","title":"排序","keywords":"","body":" 冒泡排序 基本思想: 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 Java实现 加入标记状态 flag 若在一次冒泡中，没有交换 则说明可以停止 减少运行时 public static void bubbleSort(int[] numbers) { int temp = 0; int size = numbers.length; boolean flag = true; for (int i = 0; i numbers[j + 1]) // 交换两数位置 { temp = numbers[j]; numbers[j] = numbers[j + 1]; numbers[j + 1] = temp; flag = true; } } } } 时间复杂度O(n*n) 选择排序算法 基本思想： 在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 Java 实现 public static void selectSort(int[] numbers) { int size = numbers.length; // 数组长度 int temp = 0; // 中间变量 for (int i = 0; i i; j--) { if (numbers[j] 时间复杂度O(n*n) 性能上优于冒泡排序 交换次数少 插入排序算法 基本思想： 每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。 Java 实现 public static void insertSort(int[] numbers) { int size = numbers.length; int temp = 0; int j = 0; for (int i = 1; i 0 && temp 时间复杂度 O(n*n) 性能上优于冒泡排序和选择排序 希尔排序算法 基本思想： 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 Java 实现 /** * 希尔排序的原理:根据需求，如果你想要结果从小到大排列，它会首先将数组进行分组，然后将较小值移到前面，较大值 * 移到后面，最后将整个数组进行插入排序，这样比起一开始就用插入排序减少了数据交换和移动的次数， * 可以说希尔排序是加强 版的插入排序 拿数组5, 2,8, 9, 1, 3，4来说，数组长度为7，当increment为3时，数组分为两个序列 * 5，2，8和9，1，3，4，第一次排序，9和5比较，1和2比较，3和8比较，4和比其下标值小increment的数组值相比较 * 此例子是按照从小到大排列，所以小的会排在前面，第一次排序后数组为5, 1, 3, 4, 2, 8，9 * 第一次后increment的值变为3/2=1,此时对数组进行插入排序， 实现数组从大到小排 */ public static void shellSort(int[] data) { int j = 0; int temp = 0; // 每次将步长缩短为原来的一半 for (int increment = data.length / 2; increment > 0; increment /= 2) { for (int i = increment; i = increment; j -= increment) { if (temp 时间复杂度O(n^1.5） 堆排序算法 基本思想: 堆排序是一种树形选择排序，是对直接选择排序的有效改进。 堆的定义下：具有n个元素的序列 （h1,h2,...,hn),当且仅当满足（hi>=h2i,hi>=h2i+1）或（hi 思想:初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个 堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。 Java 实现 public static void heapSort(int[] a){ int arrayLength = a.length; // 循环建堆 for (int i = 0; i = 0; i--) { // k保存正在判断的节点 int k = i; // 如果当前k节点的子节点存在 while (k * 2 + 1 时间复杂度O(nlogn）不适合待排序序列较少的情况 快速排序算法 基本思想： 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，则分别对这两部分继续进行排序，直到整个序列有序。 Java 实现 /** * 快速排序 * * @param numbers * 带排序数组 */ public static void quick(int[] numbers) { if (numbers.length > 0) // 查看数组是否为空 { quickSort(numbers, 0, numbers.length - 1); } } /** * * @param numbers * 带排序数组 * @param low * 开始位置 * @param high * 结束位置 */ public static void quickSort(int[] numbers, int low, int high) { if (low >= high) { return; } int middle = getMiddle(numbers, low, high); // 将numbers数组进行一分为二 quickSort(numbers, low, middle - 1); // 对低字段表进行递归排序 quickSort(numbers, middle + 1, high); // 对高字段表进行递归排序 } /** * 查找出中轴（默认是最低位low）的在numbers数组排序后所在位置 * * @param numbers * 带查找数组 * @param low * 开始位置 * @param high * 结束位置 * @return 中轴所在位置 */ public static int getMiddle(int[] numbers, int low, int high) { int temp = numbers[low]; // 数组的第一个作为中轴 while (low temp) { high--; } numbers[low] = numbers[high];// 比中轴小的记录移到低端 while (low 时间复杂度O(nlogn） 快速排序在序列中元素很少时，效率将比较低，不如插入排序，因此一般在序列中元素很少时使用插入排序，这样可以提高整体效率。 归并排序算法 基本思想: 归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 Java 实现 /** * 归并排序 * 简介:将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列 * 时间复杂度为O(nlogn) * 稳定排序方式 * @param nums 待排序数组 * @return 输出有序数组 */ public static int[] sort(int[] nums, int low, int high) { int mid = (low + high) / 2; if (low 时间复杂度O(nlogn） 各种算法的时间复杂度等性能比较 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"data-structure/mass_data_processing.html":{"url":"data-structure/mass_data_processing.html","title":"海量数据处理","keywords":"","body":"一、海量数据处理 所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。 那解决办法呢? 针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/trie树。 针对空间，无非就一个办法：大而化小，分而治之（hash映射）。 二、算法/数据结构基础 1.Bloom Filter Bloom Filter（BF）是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。它是一个判断元素是否存在集合的快速的概率算法。Bloom Filter有可能会出现错误判断，但不会漏掉判断。也就是Bloom Filter判断元素不再集合，那肯定不在。如果判断元素存在集合中，有一定的概率判断错误。因此，Bloom Filter不适合那些“零错误”的应用场合。 而在能容忍低错误率的应用场合下，Bloom Filter比其他常见的算法（如hash，折半查找）极大节省了空间。 适用范围 可以用来实现数据字典，进行数据的判重，或者集合求交集 具体参考：海量数据处理之Bloom Filter详解 2.Hash Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 具体参考：从头到尾解析Hash表算法 3. Bit-map 所谓的Bit-map就是用一个bit位来标记某个元素对应的值。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。 如果说了这么多还没明白什么是Bit-map，那么我们来看一个具体的例子，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0(如下图：) 然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0x01 然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下： 具体参考：数据结构：位图法 4.堆 堆是一种特殊的二叉树，具备以下两种性质 1）每个节点的值都大于（或者都小于，称为最小堆）其子节点的值 2）树是完全平衡的，并且最后一层的树叶都在最左边这样就定义了一个最大堆。 如下图用一个数组来表示堆： 5.trie树 下面我们有and,as,at,cn,com这些关键词，那么如何构建trie树呢？ 从上面的图中，我们或多或少的可以发现一些好玩的特性。 第一：根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 第二：从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。 第三：每个单词的公共前缀作为一个字符节点保存。 适用范围： 前缀统计，词频统计。 具体参考：6天通吃树结构—— 第五天 Trie树 6.外排序 适用范围： 大数据的排序，去重 基本原理及要点： 外部排序的两个独立阶段： 1）首先按内存大小，将外存上含n个记录的文件分成若干长度L的子文件或段。依次读入内存并利用有效的内部排序对他们进行排序，并将排序后得到的有序字文件重新写入外存，通常称这些子文件为归并段。 2）对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件为之。 外排序的优化方法：置换选择 败者树原理，最优归并树 具体参考：选择置换+败者树搞定外部排序 三、面试问题解决 ①、海量日志数据，提取出某日访问百度次数最多的那个IP。 算法思想：分而治之+Hash 1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理； 2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址； 3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址； 4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP； ②、 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。 可以在内存中处理，典型的Top K算法 算法思想：hashmap+堆 1.先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计； 2.借助堆这个数据结构，找出Top K，时间复杂度为O(N*logK)。 或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 ③、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。 算法思想：分而治之 + hash统计 + 堆排序 1.顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 2.对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。 3.取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。 ④、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。 方案1： 算法思想：分而治之 + hash统计 + 堆排序 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件中。这样新生成的文件每个的大小大约也1G，大于1G继续按照上述思路分。 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。 对这10个文件进行归并排序（内排序与外排序相结合）。 方案2： 算法思想：hashmap+堆 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。 ⑤、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url 方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。 算法思想：分而治之 + hash统计 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。 方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。 ⑥、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。 采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。 ⑦、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？ 方案1：申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。 方案2：因为2^32为40亿多，所以给定一个数可能在，也可能不在其中； 这里我们把40亿个数中的每一个用32位的二进制来表示 假设这40亿个数开始放在一个文件中。 然后将这40亿个数分成两类: 1.最高位为0 2.最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数=20亿（这相当于折半了）； 与要查找的数的最高位比较并接着进入相应的文件再查找 再然后把这个文件为又分成两类: 1.次最高位为0 2.次最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数=10亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。 ....... 以此类推，就可以找到了。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"sql/SQL.html":{"url":"sql/SQL.html","title":"SQL","keywords":"","body":"1.创建表 语法 CREATE TABLE ( [列级完整性约束条件] [, [列级完整性约束条件]]…); 列级完整性约束条件有NULL[可为空]、NOT NULL[不为空]、UNIQUE[唯一]，可以组合使用，但是不能重复和对立关系同时存在。 示例 -- 创建学生表 CREATE TABLE Student ( Id INT NOT NULL UNIQUE PRIMARY KEY, Name VARCHAR(20) NOT NULL, Age INT NULL, Gender VARCHAR(4) NULL ); 2.删除表 语法 DROP TABLE ; 示例 -- 删除学生表 DROP TABLE Student; 3.清空表 语法 TRUNCATE TABLE ; 示例 -- 删除学生表 TRUNCATE TABLE Student; 4.修改表 语法 -- 添加列 ALTER TABLE [ADD [列级完整性约束条件]] -- 删除列 ALTER TABLE [DROP COLUMN ] -- 修改列 ALTER TABLE [MODIFY COLUMN [列级完整性约束条件]] 示例 -- 添加学生表`Phone`列 ALTER TABLE Student ADD Phone VARCHAR(15) NULL; -- 删除学生表`Phone`列 ALTER TABLE Student DROP COLUMN Phone; -- 修改学生表`Phone`列 ALTER TABLE Student MODIFY Phone VARCHAR(13) NULL; 5.查询 语法 SELECT [ALL | DISTINCT] [,]… FROM [,]… [WHERE ] [GROUP BY [HAVING ]] [ORDER BY [ASC|DESC]…] SQL查询语句的顺序：SELECT、FROM、WHERE、GROUP BY、HAVING、ORDER BY。SELECT、FROM是必须的，HAVING子句只能与GROUP BY搭配使用。 示例 SELECT * FROM Student WHERE Id>10 GROUP BY Age HAVING AVG(Age) > 20 ORDER BY Id DESC 6.插入 语法 -- 插入不存在的数据 INSERT INTO [(字段名[,字段名]…)] VALUES (常量[,常量]…); -- 将查询的数据插入到数据表中 INSERT INTO [(字段名[,字段名]…)] SELECT 查询语句; 示例 -- 插入不存在的数据 INSERT INTO Student (Name,Age,Gender) VALUES ('Andy',30,'女'); -- 将查询的数据插入到数据表中 INSERT INTO Student (Name,Age,Gender) SELECT Name,Age,Gender FROM Student_T WHERE Id >10; 7.更新 语法 UPDATE SET 列名=值表达式[,列名=值表达式…] [WHERE 条件表达式] 示例 -- 将Id在(10,100)的Age加1 UPDATE Student SET Age= Age+1 WHERE Id>10 AND Id 8.删除 语法 DELETE FROM [WHERE 条件表达式] 示例 -- 删除Id小于10的数据记录 DELETE FROM Student WHERE Id 9.索引 索引是一种特殊的查询表，可以被数据库搜索引擎用来加速数据的检索。简单说来，索引就是指向表中数据的指针。数据库的索引同书籍后面的索引非常相像。 例如，如果想要查阅一本书中与某个特定主题相关的所有页面，你会先去查询索引（索引按照字母表顺序列出了所有主题），然后从索引中找到一页或者多页与该主题相关的页面。 索引能够提高 SELECT 查询和 WHERE 子句的速度，但是却降低了包含 UPDATE 语句或 INSERT 语句的数据输入过程的速度。索引的创建与删除不会对表中的数据产生影响。 创建索引需要使用 CREATE INDEX 语句，该语句允许对索引命名，指定要创建索引的表以及对哪些列进行索引，还可以指定索引按照升序或者降序排列。 同 UNIQUE 约束一样，索引可以是唯一的。这种情况下，索引会阻止列中（或者列的组合，其中某些列有索引）出现重复的条目。 创建索引 语法 CREATE [UNIQUE] [CLUSTER] INDEX ON ([][,[]]…); UNIQUE：表明此索引的每一个索引值只对应唯一的数据记录 CLUSTER：表明建立的索引是聚集索引 次序：可选ASC(升序)或DESC(降序)，默认ASC 示例 -- 建立学生表索引：单一字段Id索引倒序 CREATE UNIQUE INDEX INDEX_SId ON Student (Id DESC); -- 建立学生表索引：多个字段Id、Name索引倒序 CREATE UNIQUE INDEX INDEX_SId_SName ON Student (Id DESC,Name DESC); 删除索引 语法 DROP INDEX ; 示例 -- 删除学生表索引 INDEX_SId DROP INDEX INDEX_SId; 10.视图 视图无非就是存储在数据库中并具有名字的 SQL 语句，或者说是以预定义的 SQL 查询的形式存在的数据表的成分。 视图可以包含表中的所有列，或者仅包含选定的列。视图可以创建自一个或者多个表，这取决于创建该视图的 SQL 语句的写法。 视图，一种虚拟的表，允许用户执行以下操作： 以用户或者某些类型的用户感觉自然或者直观的方式来组织数据； 限制对数据的访问，从而使得用户仅能够看到或者修改（某些情况下）他们需要的数据； 从多个表中汇总数据，以产生报表。 创建视图 语法 CREATE VIEW AS SELECT 查询子句 [WITH CHECK OPTION] 查询子句：子查询可以是任何SELECT语句，但是常不允许含有ORDER BY子句和DISTINCT短语； WITH CHECK OPTION：表示对UPDATE、INSERT、DELETE操作时要保证更新。 更新视图： 视图可以在特定的情况下更新： SELECT 子句不能包含 DISTINCT 关键字 SELECT 子句不能包含任何汇总函数（summary functions） SELECT 子句不能包含任何集合函数（set functions） SELECT 子句不能包含任何集合运算符（set operators） SELECT 子句不能包含 ORDER BY 子句 FROM 子句中不能有多个数据表 WHERE 子句不能包含子查询（subquery） 查询语句中不能有 GROUP BY 或者 HAVING 计算得出的列不能更新 视图必须包含原始数据表中所有的 NOT NULL 列，从而使 INSERT 查询生效。 示例 CREATE VIEW VIEW_Stu_Man AS SELECT * FROM Student WHERE Gender = '男' WITH CHECK OPTION 删除视图 语法 DROP VIEW ; 示例 DROP VIEW VIEW_Stu_Man; 11.ORDER BY ORDER BY 子句根据一列或者多列的值，按照升序或者降序排列数据。某些数据库默认以升序排列查询结果。 语法 SELECT [ALL | DISTINCT] [,]… FROM [,]… [WHERE ] [ORDER BY ] [ASC | DESC]; ORDER BY 子句可以同时使用多个列作为排序条件。无论用哪一列作为排序条件，都要确保该列在存在。 示例 SELECT * FROM CUSTOMERS ORDER BY NAME DESC 12.WHERE WHERE 子句用于有条件地从单个表中取回数据或者将多个表进行合并。 如果条件满足，则查询只返回表中满足条件的值。你可以用 WHERE 子句来过滤查询结果，只获取必要的记录。 WHERE 子句不仅可以用于 SELECT 语句，还可以用于 UPDATE、DELETE 等语句。 语法 SELECT [ALL | DISTINCT] [,]… FROM [,]… WHERE 在指定条件时，可以使用关系运算符和逻辑运算符，例如 >、、=、LIKE、NOT 等。 示例 SELECT ID, NAME, SALARY FROM CUSTOMERS WHERE SALARY > 2000; 13.LIKE LIKE 子句通过通配符来将一个值同其他相似的值作比较。可以同 LIKE 运算符一起使用的通配符有两个： 百分号（%） 下划线（_） 百分号代表零个、一个或者多个字符。下划线则代表单个数字或者字符。两个符号可以一起使用。 语法 % 和 _ 的基本语法如下： SELECT FROM table_name WHERE column LIKE 'XXXX%' SELECT FROM table_name WHERE column LIKE '%XXXX%' SELECT FROM table_name WHERE column LIKE 'XXXX_' SELECT FROM table_name WHERE column LIKE '_XXXX' SELECT FROM table_name WHERE column LIKE '_XXXX_' 你可以将多个条件用 AND 或者 OR　连接在一起。这里，XXXX　为任何数字值或者字符串。 示例 下面这些示例中，每个 WHERE 子句都有不同的 LIKE 子句，展示了 % 和 _ 的用法: 语句 描述 WHERE SALARY LIKE '200%' 找出所有 200 打头的值 WHERE SALARY LIKE '%200%' 找出所有含有 200 的值 WHERE SALARY LIKE '_00%' 找出所有第二位和第三位为 0 的值 WHERE SALARY LIKE '2%%' 找出所有以 2 开始，并且长度至少为 3 的值 WHERE SALARY LIKE '%2' 找出所有以 2 结尾的值 WHERE SALARY LIKE '_2%3' 找出所有第二位为 2，并且以3结束的值 WHERE SALARY LIKE '2___3' 找出所有以 2 开头以 3 结束的五位数 14.HAVING HAVING 子句使你能够指定过滤条件，从而控制查询结果中哪些组可以出现在最终结果里面。 WHERE 子句对被选择的列施加条件，而 HAVING 子句则对 GROUP BY 子句所产生的组施加条件。 语法 下面可以看到 HAVING 子句在 SELECT 查询中的位置： SELECT FROM WHERE GROUP BY HAVING ORDER BY 在 SELECT 查询中，HAVING 子句必须紧随 GROUP BY 子句，并出现在 ORDER BY 子句（如果有的话）之前。带有 HAVING 子句的 SELECT 语句的语法如下所示： SELECT column1, column2 FROM table1, table2 WHERE [ conditions ] GROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2 示例 考虑 CUSTOMERS 表，表中的记录如下所示： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ 下面是一个有关 HAVING 子句使用的实例，该实例将会筛选出出现次数大于或等于 2 的所有记录。 SELECT ID, NAME, AGE, ADDRESS, SALARY FROM CUSTOMERS GROUP BY age HAVING COUNT(age) >= 2; 其执行结果如下所示： +----+--------+-----+---------+---------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+--------+-----+---------+---------+ | 2 | Khilan | 25 | Delhi | 1500.00 | +----+--------+-----+---------+---------+ 15.DISTINCT DISTINCT 关键字同 SELECT 语句一起使用，可以去除所有重复记录，只返回唯一项。 有时候，数据表中可能会有重复的记录。在检索这些记录的时候，应该只取回唯一的记录，而不是重复的。 语法 使用 DISTINCT 关键字去除查询结果中的重复记录的基本语法如下所示： SELECT DISTINCT column1, column2,.....columnN FROM table_name WHERE [condition] 示例 SELECT DISTINCT SALARY FROM CUSTOMERS ORDER BY SALARY 去除（SALARY 字段）重复记录。 16.AND和OR AND 和 OR 运算符可以将多个条件结合在一起，从而过滤 SQL 语句的返回结果。这两个运算符被称作连接运算符。 AND 语法 SELECT column1, column2, columnN FROM table_name WHERE [condition1] AND [condition2]...AND [conditionN]; 将 N 个条件用 AND 运算符结合在一起。对于 SQL 语句要执行的动作来说——无论是事务还是查询，AND 运算符连接的所有条件都必须为 TRUE。 示例 SELECT ID, NAME, SALARY FROM CUSTOMERS WHERE SALARY > 2000 AND age OR 语法 SELECT column1, column2, columnN FROM table_name WHERE [condition1] OR [condition2]...OR [conditionN] 你可以将 N 个条件用 OR 运算符结合在一起。对于 SQL 语句要执行的动作来说——无论是事务还是查询，OR 运算符连接的所有条件中只需要有一个为 TRUE 即可。 示例 SELECT ID, NAME, SALARY FROM CUSTOMERS WHERE SALARY > 2000 OR age 17.UNION UNION 子句/运算符用于将两个或者更多的 SELECT 语句的运算结果组合起来。 在使用 UNION 的时候，每个 SELECT 语句必须有相同数量的选中列、相同数量的列表达式、相同的数据类型，并且它们出现的次序要一致，不过长度不一定要相同。 语法 SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE condition] UNION SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE condition] 这里的条件可以是任何根据你的需要而设的条件。 示例 SELECT Txn_Date FROM Store_Information UNION SELECT Txn_Date FROM Internet_Sales; UNION ALL 子句： UNION ALL 运算符用于将两个 SELECT 语句的结果组合在一起，重复行也包含在内。 其他类似语句 INTERSECT子句： 用于组合两个 SELECT 语句，但是只返回两个 SELECT 语句的结果中都有的行。 EXCEPT 子句： 组合两个 SELECT 语句，并将第一个 SELECT 语句的结果中存在，但是第二个 SELECT 语句的结果中不存在的行返回。 18.JOIN 连接（JOIN） 子句用于将数据库中两个或者两个以上表中的记录组合起来。连接通过共有值将不同表中的字段组合在一起。 考虑下面两个表，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ （b）另一个表是 ORDERS 表： +-----+---------------------+-------------+--------+ |OID | DATE | CUSTOMER_ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用 SELECT 语句将这个两张表连接（JOIN）在一起： SQL> SELECT ID, NAME, AGE, AMOUNT FROM CUSTOMERS, ORDERS WHERE CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句的运行结果如下所示： +----+----------+-----+--------+ | ID | NAME | AGE | AMOUNT | +----+----------+-----+--------+ | 3 | kaushik | 23 | 3000 | | 3 | kaushik | 23 | 1500 | | 2 | Khilan | 25 | 1560 | | 4 | Chaitali | 25 | 2060 | +----+----------+-----+--------+ SQL 连接类型 SQL 中有多种不同的连接： 内连接（INNER JOIN）：当两个表中都存在匹配时，才返回行。 左连接（LEFT JOIN）：返回左表中的所有行，如果左表中行在右表中没有匹配行，则结果中右表中的列返回空值。 右连接（RIGHT JOIN）：恰与左连接相反，返回右表中的所有行，如果右表中行在左表中没有匹配行，则结果中左表中的列返回空值。 全连接（FULL JOIN）：返回左表和右表中的所有行。当某行在另一表中没有匹配行，则另一表中的列返回空值 内连接 语法 SELECT table1.column1, table2.column2... FROM table1 INNER JOIN table2 ON table1.common_field = table2.common_field; 示例 考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用内连接将这两个表连接在一起： SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS INNER JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +----+----------+--------+---------------------+ | ID | NAME | AMOUNT | DATE | +----+----------+--------+---------------------+ | 3 | kaushik | 3000 | 2009-10-08 00:00:00 | | 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | +----+----------+--------+---------------------+ 左连接 语法 SELECT table1.column1, table2.column2... FROM table1 LEFT JOIN table2 ON table1.common_field = table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例 考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用左连接将这两个表连接在一起： SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +----+----------+--------+---------------------+ | ID | NAME | AMOUNT | DATE | +----+----------+--------+---------------------+ | 1 | Ramesh | NULL | NULL | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 | | 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | | 5 | Hardik | NULL | NULL | | 6 | Komal | NULL | NULL | | 7 | Muffy | NULL | NULL | +----+----------+--------+---------------------+ 右连接 语法 SELECT table1.column1, table2.column2... FROM table1 RIGHT JOIN table2 ON table1.common_field = table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例 考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在，让我们用右连接将这两个表连接在一起： SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +------+----------+--------+---------------------+ | ID | NAME | AMOUNT | DATE | +------+----------+--------+---------------------+ | 3 | kaushik | 3000 | 2009-10-08 00:00:00 | | 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | +------+----------+--------+---------------------+ 全连接 语法 SELECT table1.column1, table2.column2... FROM table1 FULL JOIN table2 ON table1.common_field = table2.common_field; 这里，给出的条件可以是任何根据你的需要写出的条件。 示例 考虑如下两个表格，（a）CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | | 4 | Chaitali | 25 | Mumbai | 6500.00 | | 5 | Hardik | 27 | Bhopal | 8500.00 | | 6 | Komal | 22 | MP | 4500.00 | | 7 | Muffy | 24 | Indore | 10000.00 | +----+----------+-----+-----------+----------+ （b）ORDERS 表： +-----+---------------------+-------------+--------+ | OID | DATE | ID | AMOUNT | +-----+---------------------+-------------+--------+ | 102 | 2009-10-08 00:00:00 | 3 | 3000 | | 100 | 2009-10-08 00:00:00 | 3 | 1500 | | 101 | 2009-11-20 00:00:00 | 2 | 1560 | | 103 | 2008-05-20 00:00:00 | 4 | 2060 | +-----+---------------------+-------------+--------+ 现在让我们用全连接将两个表连接在一起： SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS FULL JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID; 上述语句将会产生如下结果： +------+----------+--------+---------------------+ | ID | NAME | AMOUNT | DATE | +------+----------+--------+---------------------+ | 1 | Ramesh | NULL | NULL | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 | | 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | | 5 | Hardik | NULL | NULL | | 6 | Komal | NULL | NULL | | 7 | Muffy | NULL | NULL | | 3 | kaushik | 3000 | 2009-10-08 00:00:00 | | 3 | kaushik | 1500 | 2009-10-08 00:00:00 | | 2 | Khilan | 1560 | 2009-11-20 00:00:00 | | 4 | Chaitali | 2060 | 2008-05-20 00:00:00 | +------+----------+--------+---------------------+ 如果你所用的数据库不支持全连接，比如 MySQL，那么你可以使用 UNION ALL子句来将左连接和右连接结果组合在一起： SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS LEFT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID UNION ALL SELECT ID, NAME, AMOUNT, DATE FROM CUSTOMERS RIGHT JOIN ORDERS ON CUSTOMERS.ID = ORDERS.CUSTOMER_ID 19.常用函数 COUNT函数是 SQL 中最简单的函数了，对于统计由 SELECT 语句返回的记录非常有用。 要理解 COUNT 函数，请考虑 employee_tbl 表，表中的记录如下所示： SELECT * FROM employee_tbl; +------+------+------------+--------------------+ | id | name | work_date | daily_typing_pages | +------+------+------------+--------------------+ | 1 | John | 2007-01-24 | 250 | | 2 | Ram | 2007-05-27 | 220 | | 3 | Jack | 2007-05-06 | 170 | | 3 | Jack | 2007-04-06 | 100 | | 4 | Jill | 2007-04-06 | 220 | | 5 | Zara | 2007-06-06 | 300 | | 5 | Zara | 2007-02-06 | 350 | +------+------+------------+--------------------+ 7 rows in set (0.00 sec) 现在，假设你想要统计上表中记录的总数，那么可以依如下所示步骤达到目的： SELECT COUNT(*) FROM employee_tbl ; +----------+ | COUNT(*) | +----------+ | 7 | +----------+ 1 row in set (0.01 sec) 类似地，如果你想要统计 Zara 的数目，就可以像下面这样： SELECT COUNT(*) FROM employee_tbl WHERE name=\"Zara\"; +----------+ | COUNT(*) | +----------+ | 2 | +----------+ 1 row in set (0.04 sec) 注意：所有的 SQL 查询都是不区分大小写的，因此在 WHERE 子句的条件中，ZARA 和 Zara 是没有任何区别的。 CONCAT 函数用于将两个字符串连接为一个字符串，试一下下面这个例子： SELECT CONCAT('FIRST ', 'SECOND'); +----------------------------+ | CONCAT('FIRST ', 'SECOND') | +----------------------------+ | FIRST SECOND | +----------------------------+ 1 row in set (0.00 sec) 要对 CONCAT 函数有更为深入的了解，请考虑 employee_tbl 表，表中记录如下所示： SELECT * FROM employee_tbl; +------+------+------------+--------------------+ | id | name | work_date | daily_typing_pages | +------+------+------------+--------------------+ | 1 | John | 2007-01-24 | 250 | | 2 | Ram | 2007-05-27 | 220 | | 3 | Jack | 2007-05-06 | 170 | | 3 | Jack | 2007-04-06 | 100 | | 4 | Jill | 2007-04-06 | 220 | | 5 | Zara | 2007-06-06 | 300 | | 5 | Zara | 2007-02-06 | 350 | +------+------+------------+--------------------+ 7 rows in set (0.00 sec) 现在，假设你想要将上表中所有的姓名（name）、id和工作日（work_date）连接在一起，那么可以通过如下的命令来达到目的： SELECT CONCAT(id, name, work_date) FROM employee_tbl; +-----------------------------+ | CONCAT(id, name, work_date) | +-----------------------------+ | 1John2007-01-24 | | 2Ram2007-05-27 | | 3Jack2007-05-06 | | 3Jack2007-04-06 | | 4Jill2007-04-06 | | 5Zara2007-06-06 | | 5Zara2007-02-06 | +-----------------------------+ 7 rows in set (0.00 sec) SUM函数用于找出表中记录在某字段处的总和。 要理解 SUM 函数，请考虑 employee_tbl 表，表中记录如下所示： SELECT * FROM employee_tbl; +------+------+------------+--------------------+ | id | name | work_date | daily_typing_pages | +------+------+------------+--------------------+ | 1 | John | 2007-01-24 | 250 | | 2 | Ram | 2007-05-27 | 220 | | 3 | Jack | 2007-05-06 | 170 | | 3 | Jack | 2007-04-06 | 100 | | 4 | Jill | 2007-04-06 | 220 | | 5 | Zara | 2007-06-06 | 300 | | 5 | Zara | 2007-02-06 | 350 | +------+------+------------+--------------------+ 7 rows in set (0.00 sec) 现在，假设你想要获取 daily_typing_pages 的总和，那么你可以用如下命令来达到目的： SELECT SUM(daily_typing_pages) FROM employee_tbl; +-------------------------+ | SUM(daily_typing_pages) | +-------------------------+ | 1610 | +-------------------------+ 1 row in set (0.00 sec) 你还可以使用 GROUP BY 子句来得出不同记录分组的总和。下面的例子将会计算得出每个人的总和，，你将能够得到每个人打的总页数。 SELECT name, SUM(daily_typing_pages) FROM employee_tbl GROUP BY name; Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer.html":{"url":"algorithm/For-offer.html","title":"剑指offer","keywords":"","body":"一、前言 剑指offer这本书的重要性不言而喻，题目不是很难，主要考察一些基本的算法思路及数据结构。其中很多题目更在面试中高频出现。 本部分内容整理了剑指offer中的所有题目，提供了详细的解题思路及Java代码实现，希望能对大家的面试有帮助！ 二、目录 01.二维数组中的查找 02.替换空格 03.从尾到头打印链表 04.重建二叉树 05.用两个栈实现队列 06.旋转数组的最小数字 07.斐波那契数列 08.二进制中1的个数 09.打印1到最大的n位数 10.在\bO(1)时间删除链表节点 11.调整数组顺序使奇数位于偶数前面 12.链表中倒数第K个节点 13.反转链表 14.合并两个排序的链表 15.树的子结构 16.二叉树的镜像 17.顺时针打印矩阵 18.包含min函数的栈 19.栈的压入、弹出序列 20.从上往下打印二叉树 21.二叉搜索树的后序遍历序列 22.二叉树中和为某一值得路径 23.复杂链表的复制 24.二叉搜索树与双向链表 25.字符串的排列 26.数组中出现次数超过一半的数字 27.最小的k个数 28.连续子数组的最大和 29.求从1到n的整数中1出现的次数 30.把数组排成最小的数 31.丑数 32.第一个只出现一次的字符 33.数组中的逆序对 34.两个链表的第一个公共结点 35.在排序数组中出现的次数 36.二叉树的深度 37.判断平衡二叉树 38.数组中只出现一次的数字 39.和为s的两个数字 40.和为s的连续正数序列 41.翻转单词顺序 42.左旋转字符串 43.n个骰子的点数 44.扑克牌的顺子 45.约瑟夫环问题 46.不用加减乘除做加法 47.把字符串转换成整数 48.树中两个结点的最低公共结点 49.数组中重复的数字 50.构建乘积数组 51.正则表达式匹配 52.表示数值的字符串 53.字符流中第一个不重复的字符 54.链表中环的入口结点 55.删除链表中重复的结点 56.二叉树的下一个结点 57.对称的二叉树 58.把二叉树打印出多行 59.按之字形顺序打印二叉树 60.二叉搜索树的第k个结点 61.数据流中的中位数 62.滑动窗口的最大值 63.矩阵中的路径 64.机器人的运动范围 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/01.html":{"url":"algorithm/For-offer/01.html","title":"01.二维数组中的查找","keywords":"","body":"一、题目 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 二、解题思路 首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束。 如果该数字大于要查找的数字，剔除这个数字所在的列：如果该数字小于要查找的数字，剔除这个数字所在的行。 也就是说如果要查找的数字不在数组的右上角，则每－次都在数组的查找范围中剔除行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。 三、解题代码 public class Test { public static boolean find(int[][] matrix, int number) { // 输入条件判断 if (matrix == null || matrix.length = 0 && row = 0 && col number) { // 如果找到的数比要找的数大，说明要找的数在当前数的左边 col--; // 列数减一，代表向左移动 } else { // 如果找到的数比要找的数小，说明要找的数在当前数的下边 row++; // 行数加一，代表向下移动 } } return false; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/02.html":{"url":"algorithm/For-offer/02.html","title":"02.替换空格","keywords":"","body":"一、题目 请实现一个函数，把字符串中的每个空格替换成\"%20\"，例如“We are happy.”，则输出“We%20are%20happy.”。 二、解题思路 先判断字符串中空格的数量。根据数量判断该字符串有没有足够的空间替换成\"%20\"。 如果有足够空间，计算出需要的空间。根据最终需要的总空间，维护一个指针在最后。从后到前，遇到非空的就把该值挪到指针指向的位置，然后指针向前一位，遇到“ ”，则指针前移，依次替换为“02%”。 三、解题代码 public class Test { /** * 请实现一个函数，把字符串中的每个空格替换成\"%20\"，例如“We are happy.“，则输出”We%20are%20happy.“。 * * @param string 要转换的字符数组 * @param usedLength 已经字符数组中已经使用的长度 * @return 转换后使用的字符长度，-1表示处理失败 */ public static int replaceBlank(char[] string, int usedLength) { // 判断输入是否合法 if (string == null || string.length string.length) { // 如果转换后的长度大于数组的最大长度，直接返回失败 return -1; } // 如果没有空白字符就不用处理 if (whiteCount == 0) { return usedLength; } usedLength--; // 从后向前，第一个开始处理的字符 targetLength--; // 处理后的字符放置的位置 // 字符中有空白字符，一直处理到所有的空白字符处理完 while (usedLength >= 0 && usedLength Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/03.html":{"url":"algorithm/For-offer/03.html","title":"03.从尾到头打印链表","keywords":"","body":"一、题目 输入个链表的头结点，从尾到头反过来打印出每个结点的值。 二、解题思路 使用栈的方式进行。 将链表从头到尾压入栈内，出栈的过程就对应着从尾到头。 三、解题代码 public class Test { /** * 结点对象 */ public static class ListNode { int val; // 结点的值 ListNode nxt; // 下一个结点 } /** * 输入个链表的头结点，从尾到头反过来打印出每个结点的值 * 使用栈的方式进行 * * @param root 链表头结点 */ public static void printListInverselyUsingIteration(ListNode root) { Stack stack = new Stack<>(); while (root != null) { stack.push(root); root = root.nxt; } ListNode tmp; while (!stack.isEmpty()) { tmp = stack.pop(); System.out.print(tmp.val + \" \"); } } /** * 输入个链表的头结点，从尾到头反过来打印出每个结点的值 * 使用递归的方式进行 * * @param root 链表头结点 */ public static void printListInverselyUsingRecursion(ListNode root) { if (root != null) { printListInverselyUsingRecursion(root.nxt); System.out.print(root.val + \" \"); } } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/04.html":{"url":"algorithm/For-offer/04.html","title":"04.重建二叉树","keywords":"","body":"一、题目 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如：前序遍历序列｛ 1, 2, 4, 7, 3, 5, 6, 8｝和中序遍历序列｛4, 7, 2, 1, 5, 3, 8，6}，重建二叉树并输出它的头结点。 二、解题思路 由前序遍历的第一个节点可知根节点。根据根节点，可以将中序遍历划分成左右子树。在前序遍历中找出对应的左右子树，其第一个节点便是根节点的左右子节点。按照上述方式递归便可重建二叉树。 三、解题代码 public class Test { /** * 二叉树节点类 */ public static class BinaryTreeNode { int value; BinaryTreeNode left; BinaryTreeNode right; } /** * 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二节树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 * * @param preorder 前序遍历 * @param inorder 中序遍历 * @return 树的根结点 */ public static BinaryTreeNode construct(int[] preorder, int[] inorder) { // 输入的合法性判断，两个数组都不能为空，并且都有数据，而且数据的数目相同 if (preorder == null || inorder == null || preorder.length != inorder.length || inorder.length pe) { return null; } // 取前序遍历的第一个数字，就是当前的根结点 int value = preorder[ps]; int index = is; // 在中序遍历的数组中找根结点的位置 while (index ie) { throw new RuntimeException(\"Invalid input\"); } // 创建当前的根结点，并且为结点赋值 BinaryTreeNode node = new BinaryTreeNode(); node.value = value; // 递归构建当前根结点的左子树，左子树的元素个数：index-is+1个 // 左子树对应的前序遍历的位置在[ps+1, ps+index-is] // 左子树对应的中序遍历的位置在[is, index-1] node.left = construct(preorder, ps + 1, ps + index - is, inorder, is, index - 1); // 递归构建当前根结点的右子树，右子树的元素个数：ie-index个 // 右子树对应的前序遍历的位置在[ps+index-is+1, pe] // 右子树对应的中序遍历的位置在[index+1, ie] node.right = construct(preorder, ps + index - is + 1, pe, inorder, index + 1, ie); // 返回创建的根结点 return node; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/05.html":{"url":"algorithm/For-offer/05.html","title":"05.用两个栈实现队列","keywords":"","body":"一、题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 二、解题思路 栈1用于存储元素，栈2用于弹出元素，负负得正。 说的通俗一点，现在把数据1、2、3分别入栈一，然后从栈一中出来（3、2、1），放到栈二中，那么，从栈二中出来的数据（1、2、3）就符合队列的规律了，即负负得正。 三、解题代码 public class Test { public static class MList { // 插入栈，只用于插入的数据 private Stack stack1 = new Stack<>(); // 弹出栈，只用于弹出数据 private Stack stack2 = new Stack<>(); public MList() { } // 添加操作，成在队列尾部插入结点 public void appendTail(T t) { stack1.add(t); } // 删除操作，在队列头部删除结点 public T deleteHead() { // 先判断弹出栈是否为空，如果为空就将插入栈的所有数据弹出栈， // 并且将弹出的数据压入弹出栈中 if (stack2.isEmpty()) { while (!stack1.isEmpty()) { stack2.add(stack1.pop()); } } // 如果弹出栈中还没有数据就抛出异常 if (stack2.isEmpty()) { throw new RuntimeException(\"No more element.\"); } // 返回弹出栈的栈顶元素，对应的就是队首元素。 return stack2.pop(); } } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/06.html":{"url":"algorithm/For-offer/06.html","title":"06.旋转数组的最小数字","keywords":"","body":"一、题目 把一个数组最开始的若干个元素搬到数组的末尾， 我们称之数组的旋转。输入一个递增排序的数组的一个旋转， 输出旋转数组的最小元素。例如数组{3,4,5,1,2 ｝为｛ 1,2,3,4,5}的一个旋转，该数组的最小值为1。 二、解题思路 Step1.和二分查找法一样，我们用两个指针分别指向数组的第一个元素和最后一个元素。 Step2.接着我们可以找到数组中间的元素： 如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于该中间元素的后面。我们可以把第一个指针指向该中间元素，这样可以缩小寻找的范围。如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素的前面。 Step3.接下来我们再用更新之后的两个指针，重复做新一轮的查找。 三、解题代码 public class Test { /** * @param numbers 旋转数组 * @return 数组的最小值 */ public static int min(int[] numbers) { // 判断输入是否合法 if (numbers == null || numbers.length == 0) { throw new RuntimeException(\"Invalid input.\"); } // 开始处理的第一个位置 int lo = 0; // 开始处理的最后一个位置 int hi = numbers.length - 1; // 设置初始值 int mi = lo; // 确保lo在前一个排好序的部分，hi在排好序的后一个部分 while (numbers[lo] >= numbers[hi]) { // 当处理范围只有两个数据时，返回后一个结果 // 因为numbers[lo] >= numbers[hi]总是成立，后一个结果对应的是最小的值 if (hi - lo == 1) { return numbers[hi]; } // 取中间的位置 mi = lo + (hi - lo) / 2; // 如果三个数都相等，则需要进行顺序处理，从头到尾找最小的值 if (numbers[mi] == numbers[lo] && numbers[hi] == numbers[mi]) { return minInorder(numbers, lo, hi); } // 如果中间位置对应的值在前一个排好序的部分，将lo设置为新的处理位置 if (numbers[mi] >= numbers[lo]) { lo = mi; } // 如果中间位置对应的值在后一个排好序的部分，将hi设置为新的处理位置 else if (numbers[mi] numbers[i]) { result = numbers[i]; } } return result; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/07.html":{"url":"algorithm/For-offer/07.html","title":"07.斐波那契数列","keywords":"","body":"一、题目 写一个函数，输入n，求斐波那契数列的第n项值。 斐波那契数列的定义如下： 二、解题思路 按照上述递推式，可以使用循环或递归的方式获取第n项式。 三、解题代码 public class Test { /** * 写一个函数，输入n，求斐波那契（Fibonacci) 数列的第n项 * @param n Fibonacci数的项数 * @return 第n项的结果 */ public static long fibonacci(int n) { // 当输入非正整数的时候返回0 if (n Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/08.html":{"url":"algorithm/For-offer/08.html","title":"08.二进制中1的个数","keywords":"","body":"一、题目 请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制1001，有2位1。因此如果输入9，该函数输出2。 二、解题思路 ①位移＋计数 每次右移一位，不断和1进行与运算，直到位0。 ②循环让(n - 1) & n。如果n的二进制表示中有k个1，那么这个方法只需要循环k次即可。其原理是不断清除n的二进制表示中最右边的1，同时累加计数器，直至n为0。因为从二进制的角度讲，n相当于在n - 1的最低位加上1。举个例子，8（1000）= 7（0111）+ 1（0001），所以8 & 7 = （1000）&（0111）= 0（0000），清除了8最右边的1（其实就是最高位的1，因为8的二进制中只有一个1）。再比如7（0111）= 6（0110）+ 1（0001），所以7 & 6 = （0111）&（0110）= 6（0110），清除了7的二进制表示中最右边的1（也就是最低位的1）。 三、解题代码 public class Test { /** * 请实现一个函数， 输入一个整数，输出该数二进制表示中1的个数。 * 例如把9表示成二进制是1001 ，有2位是1. 因此如果输入9，该出2。 * * @param n 待的数字 * @return 数字中二进制表表的1的数目 */ public static int numberOfOne(int n) { // 记录数字中1的位数 int result = 0; // JAVA语言规范中，int整形占四个字节，总计32位 // 对每一个位置与1进行求与操作，再累加就可以求出当前数字的表示是多少位1 for (int i = 0; i >>= 1; } // 返回求得的结果 return result; } /** * @param n 待的数字 * @return 数字中二进制表表的1的数目 */ public static int numberOfOne2(int n) { // 记录数字中1的位数 int result = 0; // 数字的二进制表示中有多少个1就进行多少次操作 while (n != 0) { result++; // 从最右边的1开始，每一次操作都使n的最右的一个1变成了0， // 即使是符号位也会进行操作。 n = (n - 1) & n; } // 返回求得的结果 return result; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/09.html":{"url":"algorithm/For-offer/09.html","title":"09.打印1到最大的n位数","keywords":"","body":"一、题目 输入数字n，按顺序打印出从1到n位最大十进数的数值。比如输入3，则打印出1、2、3一直到最大三位数即999。 二、解题思路 ①使用一个n位的数组来存储每一位的元素。例如n位3,则000表示为[0,0,0]。 使用递归的方式，存放每一位元素值。 ②同上，使用一个n位的数组来存储每一位的元素。然后循环执行加1运算，并在数组中进行模拟进位，直到最高位需要进位，则表示循环结束。 三、解题代码 public class Test { /** * 输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3 一直到最大的3位数即999。 * * @param n 数字的最大位数 */ public static void printOneToNthDigits(int n) { // 输入的数字不能为小于1 if (n = arr.length) { // 可以输出数组的值 printArray(arr); } else { for (int i = 0; i 0); // 如果index=0说明已经处理了最高位，carry>0说明最高位有进位，返回1 if (carry > 0 && index == 0) { return 1; } // 无进位返回0 return 0; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/10.html":{"url":"algorithm/For-offer/10.html","title":"10.在\bO(1)时间删除链表节点","keywords":"","body":"一、题目 给定单向链表的一个头指针和节点指针，定义一个函数在O(1)时间删除该节点。 二、解题思路 由于给定了节点指针，那么要删除该节点。只要把该节点的值替换为下一个节点的值，同时让该节点直接指向下一个节点的下一个节点。相当于顶包代替了下一个节点，该节点自然就不存在。 需要注意的是如果指定节点是头结点，那么直接把头结点定义为下一个节点即可。如果是尾节点，需要循环遍历到该节点，然后让尾节点的上一个节点的指针为空即可。 三、解题代码 public class Test { /** * 链表结点 */ public static class ListNode { int value; // 保存链表的值 ListNode next; // 下一个结点 } /** * 给定单向链表的头指针和一个结点指针，定义一个函数在0(1)时间删除该结点, * 【注意1：这个方法和文本上的不一样，书上的没有返回值，这个因为JAVA引用传递的原因， * 如果删除的结点是头结点，如果不采用返回值的方式，那么头结点永远删除不了】 * 【注意2：输入的待删除结点必须是待链表中的结点，否则会引起错误，这个条件由用户进行保证】 * * @param head 链表表的头 * @param toBeDeleted 待删除的结点 * @return 删除后的头结点 */ public static ListNode deleteNode(ListNode head, ListNode toBeDeleted) { // 如果输入参数有空值就返回表头结点 if (head == null || toBeDeleted == null) { return head; } // 如果删除的是头结点，直接返回头结点的下一个结点 if (head == toBeDeleted) { return head.next; } // 下面的情况链表至少有两个结点 // 在多个节点的情况下，如果删除的是最后一个元素 if (toBeDeleted.next == null) { // 找待删除元素的前驱 ListNode tmp = head; while (tmp.next != toBeDeleted) { tmp = tmp.next; } // 删除待结点 tmp.next = null; } // 在多个节点的情况下，如果删除的是某个中间结点 else { // 将下一个结点的值输入当前待删除的结点 toBeDeleted.value = toBeDeleted.next.value; // 待删除的结点的下一个指向原先待删除引号的下下个结点，即将待删除的下一个结点删除 toBeDeleted.next = toBeDeleted.next.next; } // 返回删除节点后的链表头结点 return head; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/11.html":{"url":"algorithm/For-offer/11.html","title":"11.调整数组顺序使奇数位于偶数前面","keywords":"","body":"一、题目 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位予数组的后半部分。 二、解题思路 这个题目要求把奇数放在数组的前半部分， 偶数放在数组的后半部分，因此所有的奇数应该位于偶数的前面。也就是说我们在扫描这个数组的时候， 如果发现有偶数出现在奇数的前面，我们可以交换它们的顺序，交换之后就符合要求了。 因此我们可以维护两个指针，第一个指针初始化时指向数组的第一个数字，它只向后移动：第二个指针初始化时指向数组的最后一个数字， 它只向前移动。在两个指针相遇之前，第一个指针总是位于第二个指针的前面。如果第一个指针指向的数字是偶数，并且第二个指针指向的数字是奇数，我们就交换这两个数字。 三、解题代码 public class Test { /** * 输入一个整数数组，实现一个函数来调整该数组中数字的顺序， * 使得所有奇数位于数组的前半部分，所有偶数位予数组的后半部分。 * * @param arr 输入的数组 */ public static void reorderOddEven(int[] arr) { // 对于输入的数组为空，或者长度小于2的只接返回 if (arr == null || arr.length Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/12.html":{"url":"algorithm/For-offer/12.html","title":"12.链表中倒数第K个节点","keywords":"","body":"一、题目 输入一个链表，输出该链表中倒数第k 个结点。为了符合大多数人的习惯，本题从1 开始计数，即链表的尾结点是倒数第1 个结点．例如一个链表有6 个结点，从头结点开始它们的值依次是1 、2、3、4、5 、6。这个个链表的倒数第3 个结点是值为4 的结点。 二、解题思路 为了实现只遍历链表一次就能找到倒数第k 个结点，我们可以定义两个指针。第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动；从第k 步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1 ， 当第一个（走在前面的）指针到达链表的尾结点时，第二个指针（走在后面的）指针正好是倒数第k 个结点。 三、解题代码 public class Test { public static class ListNode { int value; ListNode next; } /** * 输入一个键表，输出该链表中倒数第k 个结点．为了符合大多数人的习惯， * 本题从1开始计数，即链表的尾结点是倒数第1个结点．例如一个链表有6个结点， * 从头结点开始它们的值依次是1、2、3、4、5 6。这个链表的倒数第3个结点是值为4的结点． * * @param head 链表的头结点 * @param k 倒数第k个结点 * @return 倒数第k个结点 */ public static ListNode findKthToTail(ListNode head, int k) { // 输入的链表不能为空，并且k大于0 if (k Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/13.html":{"url":"algorithm/For-offer/13.html","title":"13.反转链表","keywords":"","body":"一、题目 定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。 二、解题思路 ①遍历。将指向下一个节点的指针指向上一个节点。 ②递归。先让指向下一个节点的指针为空，然后递归调用，最后再将指向下一个节点的指针指向上一个节点。 三、解题代码 遍历 /** * 反转单链表 * @param head * @return */ private static Node reverseHead(Node head) { if (head == null) { return head; } Node pre = head; Node cur = head.nextNode; Node next = null; while(cur != null){ next = cur.nextNode; cur.nextNode = pre; pre = cur; cur = next; } head.nextNode = null; head = pre; return head; } 递归 /** * 递归反转 * @param head * @return */ private static Node reverseByRecur(Node current) { if (current == null || current.nextNode == null) return current; Node nextNode = current.nextNode; current.nextNode = null; Node reverseRest = reverseByRecur(nextNode); nextNode.nextNode = current; return reverseRest; } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/14.html":{"url":"algorithm/For-offer/14.html","title":"14.合并两个排序的链表","keywords":"","body":"一、题目 输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。 二、解题思路 Step1.定义一个指向新链表的指针，暂且让它指向NULL； Step2.比较两个链表的头结点，让较小的头结点作为新链表的头结点； Step3.有两种方法。 ①递归比较两个链表的其余节点，让较小的节点作为上一个新节点的后一个节点； ②循环比较两个链表的其余节点，让较小的节点作为上一个新节点的后一个节点。直到有一个链表没有节点，然后将新链表的最后一个节点直接指向剩余链表的节点。 三、解题代码 public class Test { public static class ListNode { int value; ListNode next; } /** * 输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的 * * @param head1 第一个有序链表 * @param head2 第二个有序链表 * @return 合并后的有序链表头 */ public static ListNode merge(ListNode head1, ListNode head2) { // 如果第一个链表为空，返回第二个链表头结点 if (head1 == null) { return head2; } // 如果第二个结点为空，返回第一个链表头结点 if (head2 == null) { return head1; } // 创建一个临时结点，用于添加元素时方便 ListNode root = new ListNode(); // 用于指向合并后的新链的尾结点 ListNode pointer = root; // 当两个链表都不为空就进行合并操作 while (head1 != null && head2 != null) { // 下面的操作合并较小的元素 if (head1.value Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/15.html":{"url":"algorithm/For-offer/15.html","title":"15.树的子结构","keywords":"","body":"一、题目 输入两棵二叉树A 和B，判断B 是不是A 的子结构。 二、解题思路 要查找树A 中是否存在和树B 结构一样的子树，我们可以分成两步： 第一步在树A 中找到和B 的根结点的值一样的结点R， 第二步再判断树A 中以R 为根结点的子树是不是包含和树B 一样的结构。 三、解题代码 public class Test { /** * 二叉树的树结点 */ public static class BinaryTreeNode { int value; BinaryTreeNode left; BinaryTreeNode right; } /** * 输入两棵二叉树A和B，判断B是不是A的子结构。 * 该方法是在A树中找到一个与B树的根节点相等的元素的结点， * 从这个相等的结点开始判断树B是不是树A的子结构，如果找到其的一个就返回， * 否则直到所有的结点都找完为止。 * * @param root1 树A的根结点 * @param root2 树B的根结点 * @return true：树B是树A的子结构，false：树B是不树A的子结构 */ public static boolean hasSubtree(BinaryTreeNode root1, BinaryTreeNode root2) { // 只要两个对象是同一个就返回true if (root1 == root2) { return true; } // 只要树B的根结点点为空就返回true if (root2 == null) { return true; } // 树B的根结点不为空，如果树A的根结点为空就返回false if (root1 == null) { return false; } // 记录匹配结果 boolean result = false; // 如果结点的值相等就，调用匹配方法 if (root1.value == root2.value) { result = match(root1, root2); } // 如果匹配就直接返回结果 if (result) { return true; } // 如果不匹配就找树A的左子结点和右子结点进行判断 return hasSubtree(root1.left, root2) || hasSubtree(root1.right, root2); } /** * 从树A根结点root1和树B根结点root2开始，一个一个元素进行判断，判断B是不是A的子结构 * * @param root1 树A开始匹配的根结点 * @param root2 树B开始匹配的根结点 * @return 树B是树A的子结构，false：树B是不树A的子结构 */ public static boolean match(BinaryTreeNode root1, BinaryTreeNode root2) { // 只要两个对象是同一个就返回true if (root1 == root2) { return true; } // 只要树B的根结点点为空就返回true if (root2 == null) { return true; } // 树B的根结点不为空，如果树A的根结点为空就返回false if (root1 == null) { return false; } // 如果两个结点的值相等，则分别判断其左子结点和右子结点 if (root1.value == root2.value) { return match(root1.left, root2.left) && match(root1.right, root2.right); } // 结点值不相等返回false return false; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/16.html":{"url":"algorithm/For-offer/16.html","title":"16.二叉树的镜像","keywords":"","body":"一、题目 请完成一个函数，输入一个二叉树，该函数输出它的镜像。 二、解题思路 先前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子结点。当交换完所有非叶子结点的左右子结点之后，就得到了树的镜像。 三、解题代码 public class Test { /** * 二叉树的树结点 */ public static class BinaryTreeNode { int value; BinaryTreeNode left; BinaryTreeNode right; } /** * 请完成一个函数，输入…个二叉树，该函数输出它的镜像 * * @param node 二叉树的根结点 */ public static void mirror(BinaryTreeNode node) { // 如果当前结点不为空则进行操作 if (node != null) { // 下面是交换结点左右两个子树 BinaryTreeNode tmp = node.left; node.left = node.right; node.right = tmp; // 对结点的左右两个子树进行处理 mirror(node.left); mirror(node.right); } } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/17.html":{"url":"algorithm/For-offer/17.html","title":"17.顺时针打印矩阵","keywords":"","body":"一、题目 输入一个矩阵，按照从外向里以顺时针的顺序依次扫印出每一个数字。 二、解题思路 把打印一圈分为四步：第一步从左到右打印一行，第二步从上到下打印一列，第三步从右到左打印一行，第四步从下到上打印一列。每一步我们根据起始坐标和终止坐标用一个循环就能打印出一行或者一列。 不过值得注意的是，最后一圈有可能退化成只有一行、只有一列，甚至只有一个数字，因此打印这样的一圈就不再需要四步。 因此我们要仔细分析打印时每一步的前提条件。第一步总是需要的， 因为打印一圈至少有一步。如果只有一行，那么就不用第二步了。也就是需要第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条件是圈内至少有两行两列，也就是说除了要求终止行号大于起始行号之外，还要求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少有三行两列，因此要求终止行号比起始行号至少大2 ， 同时终止列号大于起始列号。 三、解题代码 public class Test { /** * 输入一个矩阵，按照从外向里以顺时针的顺序依次打印每一个数字 * * @param numbers 输入的二维数组，二维数组必须是N*M的，否则分出错 */ public static void printMatrixClockWisely(int[][] numbers) { // 输入的参数不能为空 if (numbers == null) { return; } // 记录一圈（环）的开始位置的行 int x = 0; // 记录一圈（环）的开始位置的列 int y = 0; // 对每一圈（环）进行处理， // 行号最大是(numbers.length-1)/2 // 列号最大是(numbers[0].length-1)/2 while (x * 2 x) { // 因为右边那一列的最上面那一个已经被输出了，所以行呈从x+1开始， // 输出包括右边那列的最下面那个 for (int i = x + 1; i x && cols - 1 - y > y) { // 因为环的左下角的位置已经输出了，所以列号从cols-y-2开始 for (int i = cols - y - 2; i >= y; i--) { System.out.print(numbers[rows - 1 - x][i] + \" \"); } } // 环的宽度至少是2并且环的高度至少是3才会输出最左边那一列 // rows-x-1：表示的是环最下的那一行的行号 if (cols - 1 - y > y && rows - 1 - x > x + 1) { // 因为最左边那一列的第一个和最后一个已经被输出了 for (int i = rows - 1 - x - 1; i >= x + 1; i--) { System.out.print(numbers[i][y] + \" \"); } } } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/18.html":{"url":"algorithm/For-offer/18.html","title":"18.包含min函数的栈","keywords":"","body":"一、题目 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小数的min 函数。在该栈中，调用min、push 及pop的时间复杂度都是O(1)。 二、解题思路 把每次的最小元素（之前的最小元素和新压入战的元素两者的较小值）都保存起来放到另外一个辅助栈里。 如果每次都把最小元素压入辅助栈， 那么就能保证辅助栈的栈顶一直都是最小元素．当最小元素从数据栈内被弹出之后，同时弹出辅助栈的栈顶元素，此时辅助栈的新栈顶元素就是下一个最小值。 三、解题代码 public class MinStack { private Stack stack = new Stack(); private Stack minStack = new Stack(); //辅助栈：栈顶永远保存stack中当前的最小的元素 public void push(int data) { stack.push(data); //直接往栈中添加数据 //在辅助栈中需要做判断 if (minStack.size() == 0 || data Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/19.html":{"url":"algorithm/For-offer/19.html","title":"19.栈的压入、弹出序列","keywords":"","body":"一、题目 输入两个整数序列，第一个序列表示栈的压入顺序，请判断二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。 二、解题思路 解决这个问题很直观的想法就是建立一个辅助栈，把输入的第一个序列中的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。 判断一个序列是不是栈的弹出序列的规律：如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果下一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。 三、解题代码 public class StackTest { //方法：data1数组的顺序表示入栈的顺序。现在判断data2的这种出栈顺序是否正确 public static boolean sequenseIsPop(int[] data1, int[] data2) { Stack stack = new Stack(); //这里需要用到辅助栈 for (int i = 0, j = 0; i 0 && stack.peek() == data2[j]) { stack.pop(); j++; } } return stack.size() == 0; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/20.html":{"url":"algorithm/For-offer/20.html","title":"20.从上往下打印二叉树","keywords":"","body":"一、题目 从上往下打印出二叉树的每个结点，同一层的结点按照从左向右的顺序打印。 二、解题思路 这道题实质是考查树的遍历算法。从上到下打印二叉树的规律：每一次打印一个结点的时候，如果该结点有子结点， 则把该结点的子结点放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的结点都被打印出来为止。 三、解题代码 public class Test { /** * 二叉树的树结点 */ public static class BinaryTreeNode { int value; BinaryTreeNode left; BinaryTreeNode right; } /** * 从上往下打印出二叉树的每个结点，向一层的结点按照从左往右的顺序打印。 * 例如下的二叉树， * 8 * / \\ * 6 10 * / \\ / \\ * 5 7 9 11 * 则依次打印出8、6、10、5、3 、9、11. * * @param root 树的结点 */ public static void printFromToBottom(BinaryTreeNode root) { // 当结点非空时才进行操作 if (root != null) { // 用于存放还未遍历的元素 Queue list = new LinkedList<>(); // 将根结点入队 list.add(root); // 用于记录当前处理的结点 BinaryTreeNode curNode; // 队列非空则进行处理 while (!list.isEmpty()) { // 删除队首元素 curNode = list.remove(); // 输出队首元素的值 System.out.print(curNode.value + \" \"); // 如果左子结点不为空，则左子结点入队 if (curNode.left != null) { list.add(curNode.left); } // 如果右子结点不为空，则左子结点入队 if (curNode.right != null) { list.add(curNode.right); } } } } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/21.html":{"url":"algorithm/For-offer/21.html","title":"21.二叉搜索树的后序遍历序列","keywords":"","body":"一、题目 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true。否则返回false。假设输入的数组的任意两个数字都互不相同。 二、解题思路 在后序遍历得到的序列中， 最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分： 第一部分是左子树结点的值，它们都比根结点的值小： 第二部分是右子树结点的值，它们都比根结点的值大。 三、解题代码 public class Test { /** * 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。 * 如果是则返回true。否则返回false。假设输入的数组的任意两个数字都互不相同。 * * @param sequence 某二叉搜索树的后序遍历的结果 * @return true：该数组是某二叉搜索树的后序遍历的结果。false：不是 */ public static boolean verifySequenceOfBST(int[] sequence) { // 输入的数组不能为空，并且有数据 if (sequence == null || sequence.length end）就返回true if (start >= end) { return true; } // 从左向右找第一个不小于根结点（sequence[end]）的元素的位置 int index = start; while (index sequence[end]) { index++; } // 如果[index, end-1]中有小于等于根结点的元素， // 不符合二叉搜索树的定义，返回false if (index != end - 1) { return false; } // 执行到此处说明直到目前为止，还是合法的 // [start, index-1]为根结点左子树的位置 // [index, end-1]为根结点右子树的位置 index = right; return verifySequenceOfBST(sequence, start, index - 1) && verifySequenceOfBST(sequence, index, end - 1); } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/22.html":{"url":"algorithm/For-offer/22.html","title":"22.二叉树中和为某一值得路径","keywords":"","body":"一、题目 输入一棵二叉树和一个整数， 打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 二、解题思路 由于路径是从根结点出发到叶结点， 也就是说路径总是以根结点为起始点，因此我们首先需要遍历根结点。在树的前序、中序、后序三种遍历方式中，只有前序遍历是首先访问根结点的。 当用前序遍历的方式访问到某一结点时， 我们把该结点添加到路径上，并累加该结点的值。如果该结点为叶结点并且路径中结点值的和刚好等于输入的整数， 则当前的路径符合要求，我们把它打印出来。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，递归函数将自动回到它的父结点。因此我们在函数退出之前要在路径上删除当前结点并减去当前结点的值，以确保返回父结点时路径刚好是从根结点到父结点的路径。 不难看出保存路径的数据结构实际上是一个枝， 因为路径要与递归调用状态一致， 而递归调用的本质就是一个压栈和出栈的过程。 三、解题代码 public class Test { /** * 二叉树的树结点 */ public static class BinaryTreeNode { int value; BinaryTreeNode left; BinaryTreeNode right; } /** * 输入一棵二叉树和一个整数， 打印出二叉树中结点值的和为输入整数的所有路径。 * 从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 * * @param root 树的根结点 * @param expectedSum 要求的路径和 */ public static void findPath(BinaryTreeNode root, int expectedSum) { // 创建一个链表，用于存放根结点到当前处理结点的所经过的结点 List list = new ArrayList<>(); // 如果根结点不为空，就调用辅助处理方法 if (root != null) { findPath(root, 0, expectedSum, list); } } /** * @param root 当前要处理的结点 * @param curSum 当前记录的和（还未加上当前结点的值） * @param expectedSum 要求的路径和 * @param result 根结点到当前处理结点的所经过的结点，（还未包括当前结点） */ public static void findPath(BinaryTreeNode root, int curSum, int expectedSum, List result) { // 如果结点不为空就进行处理 if (root != null) { // 加上当前结点的值 curSum += root.value; // 将当前结点入队 result.add(root.value); // 如果当前结点的值小于期望的和 if (curSum Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/23.html":{"url":"algorithm/For-offer/23.html","title":"23.复杂链表的复制","keywords":"","body":"一、题目 请实现函数ComplexListNode clone(ComplexListNode head),复制一个复杂链表。在复杂链表中，每个结点除了有一个next 域指向下一个结点外，还有一个sibling 指向链表中的任意结点或者null。 二、解题思路 在不用辅助空间的情况下实现O(n)的时间效率。 第一步：仍然是根据原始链表的每个结点N 创建对应的N’。把N’链接在N的后面。 第二步：设置复制出来的结点的sibling。假设原始链表上的N的sibling指向结点S，那么其对应复制出来的N’是N的next指向的结点，同样S’也是S的next指向的结点。 第三步：把这个长链表拆分成两个链表。把奇数位置的结点用next . 链接起来就是原始链表，把偶数位置的结点用next 链接起来就是复制 出来的链表。 三、解题代码 public class Test { /** * 复杂链表结点 */ public static class ComplexListNode { int value; ComplexListNode next; ComplexListNode sibling; } /** * 实现函复制一个复杂链表。在复杂链表中，每个结点除了有一个next字段指向下一个结点外， * 还有一个sibling字段指向链表中的任意结点或者NULL * * @param head 链表表头结点 * @return 复制结点的头结点 */ public static ComplexListNode clone(ComplexListNode head) { // 如果链表为空就直接返回空 if (head == null) { return null; } // 先复制结点 cloneNodes(head); // 再链接sibling字段 connectNodes(head); // 将整个链表拆分，返回复制链表的头结点 return reconnectNodes(head); } /** * 复制一个链表，并且将复制后的结点插入到被复制的结点后面，只链接复制结点的next字段 * * @param head 待复制链表的头结点 */ public static void cloneNodes(ComplexListNode head) { // 如果链表不空，进行复制操作 while (head != null) { // 创建一个新的结点 ComplexListNode tmp = new ComplexListNode(); // 将被复制结点的值传给复制结点 tmp.value = head.value; // 复制结点的next指向下一个要被复制的结点 tmp.next = head.next; // 被复制结点的next指向复制结点 head.next = tmp; // 到些处就已经完成了一个结点的复制并且插入到被复制结点的后面 // heed指向下一个被复制结点的位置 head = tmp.next; } } /** * 设置复制结点的sibling字段 * * @param head 链表的头结 */ public static void connectNodes(ComplexListNode head) { // 如链表不为空 while (head != null) { // 当前处理的结点sibling字段不为空，则要设置其复制结点的sibling字段 if (head.sibling != null) { // 复制结点的sibling指向被复制结点的sibling字段的下一个结点 // head.next：表求复制结点， // head.sibling：表示被复制结点的sibling所指向的结点， // 它的下一个结点就是它的复制结点 head.next.sibling = head.sibling.next; } // 指向下一个要处理的复制结点 head = head.next.next; } } /** * 刚复制结点和被复制结点拆开，还原被复制的链表，同时生成复制链表 * * @param head 链表的头结点 * @return 复制链表的头结点 */ public static ComplexListNode reconnectNodes(ComplexListNode head) { // 当链表为空就直接返回空 if (head == null) { return null; } // 用于记录复制链表的头结点 ComplexListNode newHead = head.next; // 用于记录当前处理的复制结点 ComplexListNode pointer = newHead; // 被复制结点的next指向下一个原链表结点 head.next = newHead.next; // 指向新的被复制结点 head = head.next; while (head != null) { // pointer指向复制结点 pointer.next = head.next; pointer = pointer.next; // head的下一个指向复制结点的下一个结点，即原来链表的结点 head.next = pointer.next; // head指向下一个原来链表上的结点 head = pointer.next; } // 返回复制链表的头结点 return newHead; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/24.html":{"url":"algorithm/For-offer/24.html","title":"24.二叉搜索树与双向链表","keywords":"","body":"一、题目 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 二、解题思路 在二叉树中，每个结点都有两个指向子结点的指针。在双向链表中，每个结点也有两个指针，它们分别指向前一个结点和后一个结点。由于这两种结点的结构相似，同时二叉搜索树也是一种排序的数据结构，因此在理论上有可能实现二叉搜索树和排序的双向链表的转换。 在搜索二叉树中，左子结点的值总是小于父结点的值，右子结点的值总是大于父结点的值。因此我们在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向后一个结点指针。接下来我们考虑该如何转换。 由于要求转换之后的链表是排好序的，我们可以中序遍历树中的每一个结点， 这是因为中序遍历算法的特点是按照从小到大的顺序遍历二叉树的每一个结点。当遍历到根结点的时候，我们把树看成三部分：根结点，左子树，右子树。根据排序链表的定义，根结点将和它的左子树的最大一个结点链接起来，同时它还将和右子树最小的结点链接起来。 三、解题代码 public class Test { /** * 二叉树的树结点 */ public static class BinaryTreeNode { int value; BinaryTreeNode left; BinaryTreeNode right; } /** * 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。 * 要求不能创建任何新的结点，只能调整树中结点指针的指向。 * * @param root 二叉树的根结点 * @return 双向链表的头结点 */ public static BinaryTreeNode convert(BinaryTreeNode root) { // 用于保存处理过程中的双向链表的尾结点 BinaryTreeNode[] lastNode = new BinaryTreeNode[1]; convertNode(root, lastNode); // 找到双向链表的头结点 BinaryTreeNode head = lastNode[0]; while (head != null && head.left != null) { head = head.left; } return head; } /** * 链表表转换操作 * * @param node 当前的根结点 * @param lastNode 已经处理好的双向链表的尾结点，使用一个长度为1的数组，类似C++中的二级指针 */ public static void convertNode(BinaryTreeNode node, BinaryTreeNode[] lastNode) { // 结点不为空 if (node != null) { // 如果有左子树就先处理左子树 if (node.left != null) { convertNode(node.left, lastNode); } // 将当前结点的前驱指向已经处理好的双向链表（由当前结点的左子树构成）的尾结点 node.left = lastNode[0]; // 如果左子树转换成的双向链表不为空，设置尾结点的后继 if (lastNode[0] != null) { lastNode[0].right = node; } // 记录当前结点为尾结点 lastNode[0] = node; // 处理右子树 if (node.right != null) { convertNode(node.right, lastNode); } } } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/25.html":{"url":"algorithm/For-offer/25.html","title":"25.字符串的排列","keywords":"","body":"一、题目 输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc。则打印出由字符a、b、c 所能排列出来的所有字符串abc、acb、bac 、bca、cab 和cba 。 二、解题思路 把一个字符串看成由两部分组成：第一部分为它的第一个字符，第二部分是后面的所有字符。 我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。这个时候我们仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。 这其实是很典型的递归思路。 三、解题代码 public class Test { /** * 题目：输入一个字符串，打印出该字符事中字符的所有排列。例如输入字符串abc。 * 则打印出由字符a、b、c 所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。 * * @param chars 待排序的字符数组 */ public static void permutation(char[] chars) { // 输入较验 if (chars == null || chars.length Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/26.html":{"url":"algorithm/For-offer/26.html","title":"26.数组中出现次数超过一半的数字","keywords":"","body":"一、题目 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 二、解题思路 解法一：基于Partition 函数的O(n)算法 数组中有一个数字出现的次数超过了数组长度的一半。如果把这个数组排序，那么排序之后位于数组中间的数字一定就是那个出现次数超过数组长度一半的数字。也就是说，这个数字就是统计学上的中位数，即长度为n 的数组中第n/2 大的数字。 这种算法是受快速排序算法的启发。在随机快速排序算法中，我们先在数组中随机选择一个数字，然后调整数组中数字的顺序， 使得比选中的数字小数字都排在它的左边，比选中的数字大的数字都排在它的右边。如果这个选中的数字的下标刚好是n/2，那么这个数字就是数组的中位数。如果它的下标大于n/2 ，那么中位数应该位于它的左边，我们可以接着在它的左边部分的数组中查找。如果它的下标小于n/2，那么中位数应该位于它的右边，我们可以接着在它的右边部分的数组中查找。这是一个典型的递归过程。 解法二：根据数组组特点找出O(n)的算法 数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此我们可以考虑在遍历数组的时候保存两个值： 一个是数组中的一个数字， 一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果下一个数字和我们之前保存的数字不同，则次数减1 。如果次数为零，我们需要保存下一个数字，并把次数设为1 。由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1 时对应的数字。 本题采用第二种实现方式 三、解题代码 public class Test { /** * 题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字 * * @param numbers 输入数组 * @return 找到的数字 */ public static int moreThanHalfNum(int[] numbers) { // 输入校验 if (numbers == null || numbers.length numbers.length / 2) { return result; } // 否则输入异常 else { throw new IllegalArgumentException(\"invalid input\"); } } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/27.html":{"url":"algorithm/For-offer/27.html","title":"27.最小的k个数","keywords":"","body":"一、题目 输入n个整数，找出其中最小的k个数。 例子说明： 例如输入4 、5 、1、6、2、7、3 、8 这8 个数字，则最小的4 个数字是1 、2、3 、4 二、解题思路 解法一：O(n)时间算法，只有可以修改输入数组时可用。 可以基于Partition函数来解决这个问题。如果基于数组的第k个数字来调整，使得比第k个数字小的所有数字都位于数组的左边，比第k个数字大的所有数字都位于数组的右边。这样调整之后，位于数组中左边的k个数字就是最小的k 个数字（这k 个数字不一定是排序的〉。 解法二： O（nlogk）的算法，精剧适合处理海量数据。 先创建一个大小为k的数据容器来存储最小的k个数字，接下来我们每次从输入的n个整数中读入一个数．如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中：如果容器中己有k 数字了，也就是容器己满，此时我们不能再插入新的数字而只能替换已有的数字。找出这己有的k 个数中的最大值，然后1在这次待插入的整数和最大值进行比较。如果待插入的值比当前己有的最大值小，则用这个数替换当前已有的最大值：如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。 因此当容器满了之后，我们要做3 件事情： 一是在k 个整数中找到最大数： 二是有可能在这个容器中删除最大数： 三是有可能要插入一个新的数字。我们可以使用一个大顶堆在O(logk）时间内实现这三步操作。 三、解题代码 public class Test { /** * 大顶堆 * * @param 参数化类型 */ private final static class MaxHeap> { // 堆中元素存放的集合 private List items; // 用于计数 private int cursor; /** * 构造一个椎，始大小是32 */ public MaxHeap() { this(32); } /** * 造诣一个指定初始大小的堆 * * @param size 初始大小 */ public MaxHeap(int size) { items = new ArrayList<>(size); cursor = -1; } /** * 向上调整堆 * * @param index 被上移元素的起始位置 */ public void siftUp(int index) { T intent = items.get(index); // 获取开始调整的元素对象 while (index > 0) { // 如果不是根元素 int parentIndex = (index - 1) / 2; // 找父元素对象的位置 T parent = items.get(parentIndex); // 获取父元素对象 if (intent.compareTo(parent) > 0) { //上移的条件，子节点比父节点大 items.set(index, parent); // 将父节点向下放 index = parentIndex; // 记录父节点下放的位置 } else { // 子节点不比父节点大，说明父子路径已经按从大到小排好顺序了，不需要调整了 break; } } // index此时记录是的最后一个被下放的父节点的位置（也可能是自身），所以将最开始的调整的元素值放入index位置即可 items.set(index, intent); } /** * 向下调整堆 * * @param index 被下移的元素的起始位置 */ public void siftDown(int index) { T intent = items.get(index); // 获取开始调整的元素对象 int leftIndex = 2 * index + 1; // // 获取开始调整的元素对象的左子结点的元素位置 while (leftIndex 0) { // 找出两个子节点中的最大子结点 maxChild = rightChild; maxIndex = rightIndex; } } // 如果最大子节点比父节点大，则需要向下调整 if (maxChild.compareTo(intent) > 0) { items.set(index, maxChild); // 将子节点向上移 index = maxIndex; // 记录上移节点的位置 leftIndex = index * 2 + 1; // 找到上移节点的左子节点的位置 } else { // 最大子节点不比父节点大，说明父子路径已经按从大到小排好顺序了，不需要调整了 break; } } // index此时记录是的最后一个被上移的子节点的位置（也可能是自身），所以将最开始的调整的元素值放入index位置即可 items.set(index, intent); } /** * 向堆中添加一个元素 * * @param item 等待添加的元素 */ public void add(T item) { items.add(item); // 将元素添加到最后 siftUp(items.size() - 1); // 循环上移，以完成重构 } /** * 删除堆顶元素 * * @return 堆顶部的元素 */ public T deleteTop() { if (items.isEmpty()) { // 如果堆已经为空，就报出异常 throw new RuntimeException(\"The heap is empty.\"); } T maxItem = items.get(0); // 获取堆顶元素 T lastItem = items.remove(items.size() - 1); // 删除最后一个元素 if (items.isEmpty()) { // 删除元素后，如果堆为空的情况，说明删除的元素也是堆顶元素 return lastItem; } items.set(0, lastItem); // 将删除的元素放入堆顶 siftDown(0); // 自上向下调整堆 return maxItem; // 返回堆顶元素 } /** * 获取下一个元素 * * @return 下一个元素对象 */ public T next() { if (cursor >= items.size()) { throw new RuntimeException(\"No more element\"); } return items.get(cursor); } /** * 判断堆中是否还有下一个元素 * * @return true堆中还有下一个元素，false堆中无下五元素 */ public boolean hasNext() { cursor++; return cursor maxHeap = new MaxHeap<>(output.length); for (int i : input) { if (maxHeap.size() i) { maxHeap.deleteTop(); maxHeap.add(i); } } } for (int i = 0; maxHeap.hasNext(); i++) { output[i] = maxHeap.next(); } } /** * 题目： 输入n个整数，找出其中最小的k个数。 * 【第一种解法】 * @param input 输入数组 * @param output 输出数组 */ public static void getLeastNumbers(int[] input, int[] output) { if (input == null || output == null || output.length = tmp) { end--; } input[start] = input[end]; while (start Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/28.html":{"url":"algorithm/For-offer/28.html","title":"28.连续子数组的最大和","keywords":"","body":"一、题目 输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。 例子说明： 例如输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为｛3, 10, -4, 7, 2}。因此输出为该子数组的和18 。 二、解题思路 解法一：举例分析数组的规律。 我们试着从头到尾逐个累加示例数组中的每个数字。初始化和为0。第一步加上第一个数字1， 此时和为1。接下来第二步加上数字-2，和就变成了-1。第三步刷上数字3。我们注意到由于此前累计的和是－1 ，小于0，那如果用-1 加上3 ，得到的和是2 ， 比3 本身还小。也就是说从第一个数字开始的子数组的和会小于从第三个数字开始的子数组的和。因此我们不用考虑从第一个数字开始的子数组，之前累计的和也被抛弃。 我们从第三个数字重新开始累加，此时得到的和是3 。接下来第四步加10，得到和为13 。第五步加上-4， 和为9。我们发现由于-4 是一个负数，因此累加-4 之后得到的和比原来的和还要小。因此我们要把之前得到的和13 保存下来，它有可能是最大的子数组的和。第六步加上数字7，9 加7 的结果是16，此时和比之前最大的和13 还要大， 把最大的子数组的和由13更新为16。第七步加上2，累加得到的和为18，同时我们也要更新最大子数组的和。第八步加上最后一个数字-5，由于得到的和为13 ，小于此前最大的和18，因此最终最大的子数组的和为18 ，对应的子数组是｛3, 10, -4, 7, 2｝。 解法二： 应用动态归划法。 可以用动态规划的思想来分析这个问题。如果用函数f(i)表示以第i个数字结尾的子数组的最大和，那么我们需要求出max[f(i)]，其中0 这个公式的意义：当以第i-1 个数字结尾的子数组中所有数字的和小于0时，如果把这个负数与第i个数累加，得到的结果比第i个数字本身还要小，所以这种情况下以第i个数字结尾的子数组就是第i个数字本身。如果以第i-1 个数字结尾的子数组中所有数字的和大于0 ,与第i 个数字累加就得到以第i个数字结尾的子数组中所有数字的和。 三、解题代码 public class Test { /** * 输入一个整型数组，数组里有正数也有负数。数组中一个或连 * 续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。 * * @param arr 输入数组 * @return 最大的连续子数组和 */ public static int findGreatestSumOfSubArray(int[] arr) { // 参数校验 if (arr == null || arr.length Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/29.html":{"url":"algorithm/For-offer/29.html","title":"29.求从1到n的整数中1出现的次数","keywords":"","body":"一、题目 输入一个整数n，求从1 到n这n个整数的十进制表示中1 出现的次数。 举例说明： 例如输入12 ，从1 到12 这些整数中包含1 的数字有1、10、11 和12，1 一共出现了5 次。 二、解题思路 第一种：不考虑时间效率的解法 累加1 到n 中每个整数中1出现的次数。我们可以每次通过对10 求余数判断整数的个位数字是不是1 。如果这个数字大于10，除以10 之后再判断个位数字是不是1 。 第二种：从数字规律着手明显提高时间效率的解法 21345 作为例子来分析。我们把从1 到21345 的所有数字分为两段， 一段是从1 到1345，另一段是从1346 到21345。 我们先看从01346 到21345 中1 出现的次数。1 的出现分为两种情况。首先分析1出现在最高位（本例中是万位）的情况。从01346 到21345 的数字中， 1出现在10000～19999 这10000 个数字的万位中， 一共出现了10000(10^4)个。 值得注意的是， 并不是对所有5 位数而言在万位出现的次数都是10000 个。对于万位是1 的数字比如输入12345, 1 只出现在10000～ 12345 的万位，出现的次数不是10^4 次，而是2346 次，也就是除去最高数字之后剩下的数字再加上1 （即2345+1=2346 次）。 接下来分析1出现在除最高位之外的其他四位数中的情况。例子中01346～21345 这20000 个数字中后4 位中1 出现的次数是2000 次。由于最高位是2，我们可以再把1346～21345 分成两段， 01346～11345 和11346～21345 。每一段剩下的4 位数字中， 选择其中一位是1 ，其余三位可以在0～9 这10 个数字中任意选择，因此根据排列组合原则，总共出现的次数是2*10^3=2000，一共有4位可以选择，所以一共是8000。 至于从1 到1345 中1 出现的次数，我们就可以用递归求得了。这也是我们为什么要把1～21345 分成1～ 1345 和1346～21345 两段的原因。因为把21345 的最高位去掉就变成1345 ，便于我们采用递归的思路。 三、解题代码 public class Test { /** * 题目：输入一个整数n求从1 到n这n个整数的十进制表示中1 出现的次数。 * @param n 最大的数字 * @return 1-n中，各个数位1出现的次数 */ public static int numberOf1Between1AndN(int n) { if (n = numbers.length || curIdx 0) { return 1; } // 假设numbers是21345 // numFirstDigit是数字10000-19999的第一个位中的数目 int numFirstDigit = 0; // 如果最高位不是1，如21345，在[1236, 21345]中，最高位1出现的只在[10000, 19999]中，出现1的次数是10^4方个 if (first > 1) { numFirstDigit = powerBase10(length - 1); } // 如果最高位是1，如12345，在[2346, 12345]中，最高位1出现的只在[10000, 12345]中，总计2345+1个 else if (first == 1) { numFirstDigit = atoi(numbers, curIdx + 1) + 1; } // numOtherDigits，是[1346, 21345]中，除了第一位之外（不看21345中的第一位2）的数位中的1的数目 int numOtherDigits = first * (length - 1) * powerBase10(length - 2); // numRecursive是1-1234中1的的数目 int numRecursive = numberOf1(numbers, curIdx + 1); return numFirstDigit + numOtherDigits + numRecursive; } /** * 将数字数组转换成数值，如{1, 2, 3, 4, 5}，i = 2，结果是345 * @param numbers 数组 * @param i 开始黑气的位置 * @return 转换结果 */ private static int atoi(int[] numbers, int i) { int result = 0; for (int j = i; j Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/30.html":{"url":"algorithm/For-offer/30.html","title":"30.把数组排成最小的数","keywords":"","body":"一、题目 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 例子说明： 例如输入数组{3， 32, 321}，则扫描输出这3 个数字能排成的最小数字321323。 二、解题思路 第一种：直观解法 先求出这个数组中所有数字的全排列，然后把每个排列拼起来，最后求出拼起来的数字的最小值。 第二种：排序解法 找到一个排序规则，数组根据这个规则排序之后能排成一个最小的数字。要确定排序规则，就要比较两个数字，也就是给出两个数字m 和n，我们需要确定一个规则判断m 和n 哪个应该排在前面，而不是仅仅比较这两个数字的值哪个更大。 根据题目的要求，两个数字m 和n能拼接成数字m和m。如果mn ”及“＝”表示常规意义的数值的大小关系，而文字“大于”、“小于”、“等于”表示我们新定义的大小关系。 接下来考虑怎么去拼接数字，即给出数字m和n，怎么得到数字m和m 并比较它们的大小。直接用数值去计算不难办到，但需要考虑到一个潜在的问题就是m 和n 都在int 能表达的范围内，但把它们拼起来的数字mn 和nm 用int 表示就有可能溢出了，所以这还是一个隐形的大数问题。 一个非常直观的解决大数问题的方法就是把数字转换成字符串。另外，由于把数字m 和n 拼接起来得到mn 和nm，它们的位数肯定是相同的，因此比较它们的大小只需要按照字符串大小的比较规则就可以了。 三、解题代码 public class Test { /** * 自定义的排序比较器，实现算法说明的排序原理 */ private static class MComparator implements Comparator { @Override public int compare(String o1, String o2) { if (o1 == null || o2 == null) { throw new IllegalArgumentException(\"Arg should not be null\"); } String s1 = o1 + o2; String s2 = o2 + o1; return s1.compareTo(s2); } } /** * 快速排序算法 * * @param array 待排序数组 * @param start 要排序的起始位置 * @param end 要排序的结束位置 * @param comparator 自定义的比较器 */ private static void quickSort(String[] array, int start, int end, Comparator comparator) { if (start = 0) { end--; } array[start] = array[end]; while (start Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/31.html":{"url":"algorithm/For-offer/31.html","title":"31.丑数","keywords":"","body":"一、题目 我们把只包含因子2、3 和5 的数称作丑数（Ugly Number）。求从小到大的顺序的第1500个丑数。 举例说明： 例如6、8 都是丑数，但14 不是，它包含因子7。习惯上我们把1 当做第一个丑数。 二、解题思路 第一种：逐个判断每个数字是不是丑数的解法，直观但不够高效。 第二种：创建数组保存已经找到丑数，用空间换时间的解法。 根据丑数的定义， 丑数应该是另一个丑数乘以2、3 或者5 的结果（1除外）。因此我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2、3或者5得到的。 这种思路的关键在于怎样确保数组里面的丑数是排好序的。假设数组中已经有若干个丑数排好序后存放在数组中，并且把己有最大的丑数记做M，我们接下来分析如何生成下一个丑数。该丑数肯定是前面某一个丑数乘以2、3 或者5 的结果， 所以我们首先考虑把已有的每个丑数乘以2。在乘以2 的时候能得到若干个小于或等于M 的结果。由于是按照顺序生成的，小于或者等于M 肯定己经在数组中了，我们不需再次考虑：还会得到若干个大于M 的结果，但我们只需要第一个大于M 的结果，因为我们希望丑数是按从小到大的顺序生成的，其他更大的结果以后再说。我们把得到的第一个乘以2 后大于M 的结果记为M2，同样，我们把已有的每一个丑数乘以3 和5，能得到第一个大于M 的结果M3 和M5，那么下一个丑数应该是M2、M3 和M5这3个数的最小者。 前面分析的时候，提到把已有的每个丑数分别都乘以2、3 和5。事实上这不是必须的，因为已有的丑数是按顺序存放在数组中的。对乘以2而言， 肯定存在某一个丑数T2，排在它之前的每一个丑数乘以2 得到的结果都会小于已有最大的丑数，在它之后的每一个丑数乘以2 得到的结果都会太大。我们只需记下这个丑数的位置， 同时每次生成新的丑数的时候，去更新这个T2。对乘以3 和5 而言， 也存在着同样的T3和T5。 三、解题代码 public class Test { /** * 判断一个数是否只有2，3，5因子（丑数） * * @param num 待判断的数，非负 * @return true是丑数，false丑数 */ private static boolean isUgly(int num) { while (num % 2 == 0) { num /= 2; } while (num % 3 == 0) { num /= 3; } while (num % 5 == 0) { num /= 5; } return num == 1; } /** * 找第index个丑数，速度太慢 * * @param index 第index个丑数 * @return 对应的丑数值 */ public static int getUglyNumber(int index) { if (index Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/32.html":{"url":"algorithm/For-offer/32.html","title":"32.第一个只出现一次的字符","keywords":"","body":"一、题目 在字符串中找出第一个只出现一次的字符。 二、解题思路 第一种：直接求解： 从头开始扫描这个字符串中的每个字符。当访问到某字符时拿这个字符和后面的每个字符相比较，如果在后面没有发现重复的字符，则该字符就是只出现一次的字符。如果字符串有n个字符，每个字符可能与后面的O(n）个字符相比较，因此这种思路的时间复杂度是O(n^2)。 第二种：记录法 由于题目与字符出现的次数相关， 我们是不是可以统计每个字符在该字符串中出现的次数？要达到这个目的，我们需要一个数据容器来存放每个字符的出现次数。在这个数据容器中可以根据字符来查找它出现的次数，也就是说这个容器的作用是把一个字符映射成二个数字。在常用的数据容器中， 哈希表正是这个用途。 为了解决这个问题，我们可以定义哈希表的键（Key）是字符， 而值(Value ）是该字符出现的次数。同时我们还需要从头开始扫描字符串两次。第一次扫描字符串时，每扫描到一个字符就在哈希表的对应项中把次数加1 。接下来第二次扫描时， 每扫描到一个字符就能从哈希表中得到该字符出现的次数。这样第一个只出现一次的字符就是符合要求的输出。 第一次扫描时，在哈希表中更新一个字符出现的次数的时间是O(n) 。如果字符串长度为n， 那么第一次扫描的时间复杂度是O(n)。第二次扫描时，同样0(1)能读出一个字符出现的次数，所以时间复杂度仍然是O(n)。这样算起来，总的时间复杂度是O(n)。 三、解题代码 public class Test { public static char firstNotRepeatingChar(String s) { if (s == null || s.length() map = new LinkedHashMap<>(); for (int i = 0; i > entrySet = map.entrySet(); // 记录只出现一次的字符的索引 int idx = Integer.MAX_VALUE; // 记录只出现一次的字符 char result = '\\0'; // 找最小索引对应的字符 for (Map.Entry entry : entrySet) { if (entry.getValue() >= 0 && entry.getValue() Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/33.html":{"url":"algorithm/For-offer/33.html","title":"33.数组中的逆序对","keywords":"","body":"一、题目 在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 举例分析 例如在数组｛7, 5, 6, 4 中， 一共存在5 个逆序对，分别是（7, 6）、（7，5），(7, 4）、（6, 4）和（5, 4）。 二、解题思路 第一种：直接求解 顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有n 个数字。由于每个数字都要和O(n）个数字作比较， 因此这个算法的时间复杂度是O(n^2)。 第二种：分析法 我们以数组｛7, 5, 6, 4｝为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不能拿它和后面的每一个数字作比较，否则时间复杂度就是O(n^2)，因此我们可以考虑先比较两个相邻的数字。 　　如图5 . 1 ( a )和图5.1 ( b）所示，我们先把数组分解成两个长度为2的子数组， 再把这两个子数组分别拆分成两个长度为1 的子数组。接下来一边合并相邻的子数组， 一边统计逆序对的数目。在第一对长度为1 的子数组｛7｝、｛5｝中7 大于5 ， 因此（7, 5）组成一个逆序对。同样在第二对长度为1 的子数组｛6｝、｛4｝中也有逆序对（6, 4）。由于我们已经统计了这两对子数组的逆序对，因此需要把这两对子数组排序（ 图5.1 ( c）所示），以免在以后的统计过程中再重复统计。 注　图中省略了最后一步， 即复制第二个子数组最后剩余的4 到辅助数组中. (a) P1指向的数字大于P2指向的数字，表明数组中存在逆序对．P2 指向的数字是第二个子数组的第二个数字， 因此第二个子数组中有两个数字比7 小． 把逆序对数目加2，并把7 复制到辅助数组，向前移动P1和P3. (b) P1指向的数字小子P2 指向的数字，没有逆序对．把P2 指向的数字复制到辅助数组，并向前移动P2 和P3 . (c) P1指向的数字大于P2 指向的数字，因此存在逆序对． 由于P2 指向的数字是第二个子数组的第一个数字，子数组中只有一个数字比5 小． 把逆序对数目加1 ，并把5复制到辅助数组，向前移动P1和P3 . 接下来我们统计两个长度为2 的子数组之间的逆序对。我们在图5.2 中细分图5.1 ( d）的合并子数组及统计逆序对的过程。 我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个子数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数（如图5.2 (a)和图5.2 (c)所示）。如果第一个数组中的数字小于或等于第二个数组中的数字，则不构成逆序对（如图5.2 (b)所示〉。每一次比较的时候，我们都把较大的数字从后往前复制到一个辅助数组中去，确保辅助数组中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。 经过前面详细的诗论， 我们可以总结出统计逆序对的过程：先把数组分隔成子数组，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个排序的过程实际上就是归并排序。 三、解题代码 public class Test { public static int inversePairs(int[] data) { if (data == null || data.length = start && j >= start + length + 1) { if (data[i] > data[j]) { copy[indexCopy] = data[i]; indexCopy--; i--; count += j - (start + length); // 对应的逆序数 } else { copy[indexCopy] = data[j]; indexCopy--; j--; } } for (; i >= start;) { copy[indexCopy] = data[i]; indexCopy--; i--; } for (; j >= start + length + 1;) { copy[indexCopy] = data[j]; indexCopy--; j--; } return count + left + right; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/34.html":{"url":"algorithm/For-offer/34.html","title":"34.两个链表的第一个公共结点","keywords":"","body":"一、题目 输入两个链表，找出它们的第一个公共结点。 二、解题思路 第一种：直接法 在第一个链表上顺序遍历每个结点，每遍历到一个结点的时候，在第二个链表上顺序遍历每个结点。如果在第二个链表上有一个结点和第一个链表上的结点一样，说明两个链表在这个结点上重合，于是就找到了它们的公共结点。如果第一个链表的长度为m，第二个链表的长度为n，显然该方法的时间复杂度是O(mn） 。 第二种：使用栈 所以两个有公共结点而部分重舍的链衰，拓扑形状看起来像一个Y， 而不可能像X（如图5.3 所示）。 经过分析我们发现，如果两个链表有公共结点，那么公共结点出现在两个链表的尾部。如果我们从两个链衰的尾部开始往前比较，最后一个相同的结点就是我们要找的结点。 在上述思路中，我们需要用两个辅助钱。如果链表的长度分别为m 和n，那么空间复杂度是O(m+n）。这种思路的时间复杂度也是O(m+n）。和最开始的蛮力法相比，时间效率得到了提高，相当于是用空间消耗换取了时间效率。 第三种：先行法 在图5.3 的两个链表中，我们可以先遍历一次得到它们的长度分别为5 和4， 也就是较长的链表与较短的链表相比多一个结点。第二次先在长的链表上走1 步，到达结点2。接下来分别从结点2 和结点4 出发同时遍历两个结点， 直到找到它们第一个相同的结点6，这就是我们想要的结果。 第三种思路和第二种思路相比，时间复杂度都一样， 但我们不再需要辅助的拢，因此提高了空间效率。 三、解题代码 public class Test { /** * 链表结点类 */ private static class ListNode { int val; ListNode next; public ListNode() { } public ListNode(int val) { this.val = val; } @Override public String toString() { return val + \"\"; } } /** * 找两个结点的第一个公共结点，如果没有找到返回null，方法比较好，考虑了两个链表中有null的情况 * * @param head1 第一个链表 * @param head2 第二个链表 * @return 找到的公共结点，没有返回null */ public static ListNode findFirstCommonNode(ListNode head1, ListNode head2) { int length1 = getListLength(head1); int length2 = getListLength(head2); int diff = length1 - length2; ListNode longListHead = head1; ListNode shortListHead = head2; if (diff Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/35.html":{"url":"algorithm/For-offer/35.html","title":"35.在排序数组中出现的次数","keywords":"","body":"一、题目 统计一个数字：在排序数组中出现的次数。 举例说明 例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字3 ，由于3 在这个数组中出现了4 次，因此输出4 。 二、解题思路 利用改进的二分算法。 如何用二分查找算法在数组中找到第一个k，二分查找算法总是先拿数组中间的数字和k作比较。如果中间的数字比k大，那么k只有可能出现在数组的前半段，下一轮我们只在数组的前半段查找就可以了。如果中间的数字比k小，那么k只有可能出现在数组的后半段，下一轮我们只在数组的后半乓查找就可以了。如果中间的数字和k 相等呢？我们先判断这个数字是不是第一个k。如果位于中间数字的前面一个数字不是k,此时中间的数字刚好就是第一个k。如果中间数字的前面一个数字也是k，也就是说第一个k肯定在数组的前半段， 下一轮我们仍然需要在数组的前半段查找。 同样的思路在排序数组中找到最后一个k。如果中间数字比k大，那么k只能出现在数组的前半段。如果中间数字比k小，k就只能出现在数组的后半段。如果中间数字等于k呢？我们需要判断这个k是不是最后一个k，也就是中间数字的下一个数字是不是也等于k。如果下一个数字不是k，则中间数字就是最后一个k了：否则下一轮我们还是要在数组的后半段中去查找。 三、解题代码 public class Test { /** * 找排序数组中k第一次出现的位置 * * @param data * @param k * @param start * @param end * @return */ private static int getFirstK(int[] data, int k, int start, int end) { if (data == null || data.length end) { return -1; } int midIdx = start + (end - start) / 2; int midData = data[midIdx]; if (midData == k) { if (midIdx > 0 && data[midIdx - 1] != k || midIdx == 0) { return midIdx; } else { end = midIdx - 1; } } else if (midData > k) { end = midIdx - 1; } else { start = midIdx + 1; } return getFirstK(data, k, start, end); } /** * 找排序数组中k最后一次出现的位置 * * @param data * @param k * @param start * @param end * @return */ private static int getLastK(int[] data, int k, int start, int end) { if (data == null || data.length end) { return -1; } int midIdx = start + (end - start) / 2; int midData = data[midIdx]; if (midData == k) { if (midIdx + 1 0) { int first = getFirstK(data, k, 0, data.length - 1); int last = getLastK(data, k, 0, data.length - 1); if (first > -1 && last > -1) { number = last - first + 1; } } return number; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/36.html":{"url":"algorithm/For-offer/36.html","title":"36.二叉树的深度","keywords":"","body":"一、题目 输入一棵二叉树的根结点，求该树的深度。从根结点到叶子点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 二、解题思路 如果一棵树只有一个结点，它的深度为1。 如果根结点只有左子树而没有右子树， 那么树的深度应该是其左子树的深度加1，同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1. 如果既有右子树又有左子树， 那该树的深度就是其左、右子树深度的较大值再加1。 三、解题代码 public static int treeDepth(BinaryTreeNode root) { if (root == null) { return 0; } int left = treeDepth(root.left); int right = treeDepth(root.right); return left > right ? (left + 1) : (right + 1); } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/37.html":{"url":"algorithm/For-offer/37.html","title":"37.判断平衡二叉树","keywords":"","body":"一、题目 输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1 ，那么它就是一棵平衡二叉树。 二、解题思路 解法一：需要重蟹遍历结点多次的解法 在遍历树的每个结点的时候，调用函数treeDepth得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过1 ，按照定义它就是一棵平衡的二叉树。 解法二：每个结点只遍历一次的解法 用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前我们就已经遍历了它的左右子树。只要在遍历每个结点的时候记录它的深度（某一结点的深度等于它到叶节点的路径的长度），我们就可以一边遍历一边判断每个结点是不是平衡的。 三、解题代码 public class Test { private static class BinaryTreeNode { int val; BinaryTreeNode left; BinaryTreeNode right; public BinaryTreeNode() { } public BinaryTreeNode(int val) { this.val = val; } } public static int treeDepth(BinaryTreeNode root) { if (root == null) { return 0; } int left = treeDepth(root.left); int right = treeDepth(root.right); return left > right ? (left + 1) : (right + 1); } /** * 判断是否是平衡二叉树，第一种解法 * * @param root * @return */ public static boolean isBalanced(BinaryTreeNode root) { if (root == null) { return true; } int left = treeDepth(root.left); int right = treeDepth(root.right); int diff = left - right; if (diff > 1 || diff = -1 && diff right[0] ? left[0] : right[0]); return true; } } return false; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/38.html":{"url":"algorithm/For-offer/38.html","title":"38.数组中只出现一次的数字","keywords":"","body":"一、题目 一个整型数组里除了两个数字之外，其他的数字都出现了两次，请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 举例说明 例如输入数组｛2, 4, 3, 6, 3, 2, 5 }，因为只有4 、6 这两个数字只出现一次，其他数字都出现了两次，所以输出4和6 。 二、解题思路 这两个题目都在强调一个（或两个）数字只出现一次，其他的出现两次。这有什么意义呢？我们想到异或运算的一个性质：任何一个数字异或它自己都等于0。也就是说， 如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些成对出现两次的数字全部在异或中抵消了。 想明白怎么解决这个简单问题之后，我们再回到原始的问题，看看能不能运用相同的思路。我们试着把原数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现两次。如果能够这样拆分成两个数组， 我们就可以按照前面的办法分别找出两个只出现一次的数字了。 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于这两个数字肯定不一样，那么异或的结果肯定不为0，也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第n 位。现在我们以第n位是不是１为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第n 位都是1 ， 而第二个子数组中每个数字的第n 位都是0。由于我们分组的标准是数字中的某一位是1 还是0 ， 那么出现了两次的数字肯定被分配到同一个子数组。因为两个相同的数字的任意一位都是相同的，我们不可能把两个相同的数字分配到两个子数组中去，于是我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。我们已经知道如何在数组中找出唯一一个只出现一次数字， 因此到此为止所有的问题都已经解决了。 三、解题代码 public class Test { public static int[] findNumbersAppearanceOnce(int[] data) { int[] result = {0, 0}; if (data == null || data.length >>= 1; index++; } return index; } private static boolean isBit1(int num, int indexBit) { num >>>= indexBit; return (num & 1) == 1; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/39.html":{"url":"algorithm/For-offer/39.html","title":"39.和为s的两个数字","keywords":"","body":"一、题目 输入一个递增排序的数组和一个数字s，在数组中查找两个数，得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。 举例说明 例如输入数组｛1 、2 、4、7 、11 、15 ｝和数字15. 由于4+ 11 = 15 ，因此输出4 和11 。 二、解题思路 我们先在数组中选择两个数字，如果它们的和等于输入的s，我们就找到了要找的两个数字。如果和小于s 呢？我们希望两个数字的和再大一点。由于数组已经排好序了，我们可以考虑选择较小的数字后面的数字。因为排在后面的数字要大一些，那么两个数字的和也要大一些， 就有可能等于输入的数字s 了。同样， 当两个数字的和大于输入的数字的时候，我们可以选择较大数字前面的数字，因为排在数组前面的数字要小一些。 三、解题代码 /** * 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得得它们的和正好是s。 * 如果有多对数字的和等于s，输出任意一对即可。 * * @param data * @param sum * @return */ public static List findNumbersWithSum(int[] data, int sum) { List result = new ArrayList<>(2); if (data == null || data.length Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/40.html":{"url":"algorithm/For-offer/40.html","title":"40.和为s的连续正数序列","keywords":"","body":"一、题目 输入一个正数s，打印出所有和为s 的连续正数序列（至少两个数）。 举例说明 例如输入15，由于1+2+3+4+5=4＋5+6＝7+8=15，所以结果打出3 个连续序列1～5、4～6 和7～8。 二、解题思路 考虑用两个数small 和big 分别表示序列的最小值和最大值。首先把small 初始化为1, big 初始化为2。如果从small 到big 的序列的和大于s，我们可以从序列中去掉较小的值，也就是增大small 的值。如果从small 到big 的序列的和小于s，我们可以增大big，让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加small 到(1+s)/2 为止。 以求和为9 的所有连续序列为例，我们先把small 初始化为1, big 初始化为2。此时介于small 和big 之间的序列是｛1，2}，序列的和为3，小于9，所以我们下一步要让序列包含更多的数字。我们把big 增加1 变成3,此时序列为{1，2，3}。由于序列的和是6，仍然小于9，我们接下来再增加big 变成4，介于small 和big 之间的序列也随之变成｛ l, 2, 3, 4｝。由于列的和10 大于9，我们要删去去序列中的一些数字， 于是我们增加small 变成2，此时得到的序列是｛2, 3, 4｝， 序列的和E好是9。我们找到了第一个和为9 的连续序列，把它打印出来。接下来我们再增加big，重复前面的过程，可以找到第二个和为9 的连续序列｛4，5}。 三、解题代码 public static List> findContinuousSequence(int sum) { List> result = new ArrayList<>(); if (sum list = new ArrayList<>(2); for (int i = small; i sum && small list = new ArrayList<>(2); for (int i = small; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/41.html":{"url":"algorithm/For-offer/41.html","title":"41.翻转单词顺序","keywords":"","body":"一、题目 输入一个英文句子，翻转句子中单词的顺序，但单词内字的顺序不变。为简单起见，标点符号和普通字母一样处理。 举例说明 例如输入字符串”I am a student. ”，则输出”student. a am I”。 二、解题思路 第一步翻转句子中所有的字符。比如翻转“I am a student. ”中所有的字符得到”.tneduts a m a I”，此时不但翻转了句子中单词的顺序，连单词内的字符顺序也被翻转了。第二步再翻转每个单词中字符的顺序，就得到了”student. a am I”。这正是符合题目要求的输出。 三、解题代码 /** * 题目一：输入一个英文句子，翻转句子中单词的顺序，但单词内字啊的顺序不变。 * 为简单起见，标点符号和普通字母一样处理。 * * @param data * @return */ public static char[] reverseSentence(char[] data) { if (data == null || data.length data.length || start > end) { return; } while (start Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/42.html":{"url":"algorithm/For-offer/42.html","title":"42.左旋转字符串","keywords":"","body":"一、题目 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。 举例说明 比如输入字符串”abcdefg”和数字2，该函数将返回左旋转2 位得到的结”cdefgab”。 二、解题思路 以”abcdefg”为例，我们可以把它分为两部分。由于想把它的前两个字符移到后面，我们就把前两个字符分到第一部分，把后面的所有字符都分到第二部分。我们先分别翻转这两部分，于是就得到”bagfedc”。接下来我们再翻转整个字符串， 得到的”cdefgab”就是把原始字符串左旋转2 位的结果。 三、解题代码 /** * 题目二：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。 * 请定义一个函数实现字符串左旋转操作的功能。 * @param data * @param n * @return */ public static char[] leftRotateString(char[] data, int n) { if (data == null || n data.length) { return data; } reverse(data, 0, data.length - 1); reverse(data, 0, data.length - n - 1); reverse(data, data.length - n, data.length - 1); return data; } /** * 将data中start到end之间的数字反转 * * @param data * @param start * @param end */ public static void reverse(char[] data, int start, int end) { if (data == null || data.length data.length || start > end) { return; } while (start Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/43.html":{"url":"algorithm/For-offer/43.html","title":"43.n个骰子的点数","keywords":"","body":"一、题目 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s 的所有可能的值出现的概率。 二、解题思路 解法一：基于通归求解，时间效率不够高。 先把n个骰子分为两堆：第一堆只有一个，另一个有n- 1 个。单独的那一个有可能出现从1 到6 的点数。我们需要计算从1 到6 的每一种点数和剩下的n-1 个骰子来计算点数和。接下来把剩下的n-1个骰子还是分成两堆，第一堆只有一个， 第二堆有n-2 个。我们把上一轮那个单独骰子的点数和这一轮单独骰子的点数相加， 再和剩下的n-2 个骰子来计算点数和。分析到这里，我们不难发现这是一种递归的思路，递归结束的条件就是最后只剩下一个骰子。 我们可以定义一个长度为6n-n+1 的数组， 和为s 的点数出现的次数保存到数组第s-n个元素里。 解法二：基于循环求解，时间性能好 我们可以考虑用二维数组来存储骰子点数的每一个总数出现的次数。在一次循环中， 第一个数组中的第n 个数字表示骰子和为n 出现的次数。在下一循环中，我们加上一个新的骰子，此时和为n 的骰子出现的次数应该等于上一次循环中骰子点数和为n-1 、n-2 、n-3 、n-4, n-5 与n-6 的次数的总和，所以我们把另一个数组的第n个数字设为前一个数组对应的第n-1 、n-2 、n-3 、n-4、n-5与n-6之和。 三、解题代码 public class Test { /** * 基于通归求解 * * @param number 色子个数 * @param max 色子的最大值 */ public static void printProbability(int number, int max) { if (number Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/44.html":{"url":"algorithm/For-offer/44.html","title":"44.扑克牌的顺子","keywords":"","body":"一、题目 从扑克牌中随机抽5张牌，判断是不是一个顺子， 即这5张牌是不是连续的。2～10为数字本身， A为1。 J为11、Q为12、 为13。小王可以看成任意数字。 二、解题思路 我们可以把5张牌看成由5个数字组成的数组。大、小王是特殊的数字，我们不妨把它们都定义为0，这样就能和其他扑克牌区分开来了。 接下来我们分析怎样判断5个数字是不是连续的，最直观的方法是把数组排序。值得注意的是，由于0可以当成任意数字，我们可以用0去补满数组中的空缺。如果排序之后的数组不是连续的，即相邻的两个数字相隔若干个数字，但只要我们有足够的。可以补满这两个数字的空缺，这个数组实际上还是连续的。举个例子，数组排序之后为{0，1，3，4，5}在1和3之间空缺了一个2，刚好我们有一个0，也就是我们可以把它当成2去填补这个空缺。 于是我们需要做3 件事情： 首先把数组排序，再统计数组中0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如果空缺的总数小于或者等于0 的个数，那么这个数组就是连续的：反之则不连续。 最后，我们还需要注意一点： 如果数组中的非0 数字重复出现，则该数组不是连续的。换成扑克牌的描述方式就是如果一副牌里含有对子，则不可能是顺子。 三、解题代码 public class Test { /** * 题目：从扑克牌中随机抽5张牌，判断是不是一个顺子， 即这5张牌是不是连续的。 * 2～10为数字本身， A为1。 J为11、Q为12、 为13。小王可以看成任意数字。 * @param numbers * @return */ public static boolean isContinuous(int[] numbers) { if (numbers == null || numbers.length != 5) { return false; } // 对元素进行排序 Arrays.sort(numbers); int numberOfZero = 0; int numberOfGap = 0; for (int i = 0; i 2) { return false; } // 第一个非0元素的位置 int small = numberOfZero; int big = small + 1; while (big Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/45.html":{"url":"algorithm/For-offer/45.html","title":"45.约瑟夫环问题","keywords":"","body":"一、题目 0, 1, … , n-1 这n个数字排成一个圈圈，从数字0开始每次从圆圏里删除第m个数字。求出这个圈圈里剩下的最后一个数字。 二、解题思路 创建一个总共有n 个结点的环形链表，然后每次在这个链表中删除第m 个结点。 三、解题代码 public static int lastRemaining(int n, int m) { if (n list = new LinkedList<>(); for (int i = 0; i 1) { // 只要移动m-1次就可以移动到下一个要删除的元素上 for (int i = 1; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/46.html":{"url":"algorithm/For-offer/46.html","title":"46.不用加减乘除做加法","keywords":"","body":"一、题目 写一个函数，求两个整数之和，要求在函数体内不得使用＋、－、×、÷四则运算符号。 二、解题思路 5 的二进制是101, 17 的二进制是10001 。 试着把计算分成三步： 第一步各位相加但不计进位， 得到的结果是10100 （ 最后一位两个数都是1,相加的结果是二进制的10 ）。这一步不计进位， 因此结果仍然是0 。 第二步记下进位。在这个例子中只在最后一位相加时产生一个进位，结果是二进制的10 。 第三步把前两步的结果相加，得到的结果是10110 ， 转换成十进制正好是22。由此可见三步走的策略对二进制也是适用的。 接下来我们试着把二进制的加法用位运算来替代。 第一步不考虑进位对每一位相加。0加0 、1加1的结果都0。 0加1 、1 加0的结果都是1 。我们注意到，这和异或的结果是一样的。对异或而言， 0和0、1和1异或的结果是0， 而0和1 、1和0的异或结果是1 。 接着考虑第二步进位，对加0 、0 加1 、1加0而言， 都不会产生进位，只有1加1 时，会向前产生一个进位。此时我们可以想象成是两个数先做位与运算，然后再向左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0。 第三步把前两个步骤的结果相加。第三步相加的过程依然是重复前面两步， 直到不产生进位为止。 三、解题代码 public class Test { public static int add(int x, int y) { int sum; int carry; do { sum = x ^ y; // x&y的某一位是1说明，它是它的前一位的进位，所以向左移动一位 carry = (x & y) Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/47.html":{"url":"algorithm/For-offer/47.html","title":"47.把字符串转换成整数","keywords":"","body":"一、题目 实现一个函数stringToInt,实现把字符串转换成整数这个功能，不能使用atoi或者其他类似的库函数。 二、解题代码 这看起来是很简单的题目，实现基本功能 ，大部分人都能用10行之内的代码解决。可是，当我们要把很多特殊情况即测试用例都考虑进去，却不是件容易的事。解决数值转换问题本身并不难，但我希望在写转换数值的代码之前，应聘者至少能把空指针，空字符串”“，正负号，溢出等方方面面的测试用例都考虑到，并且在写代码的时候对这些特殊的输入都定义好合理的输出。当然，这些输出并不一定要和atoi完全保持一致，但必须要有显式的说明，和面试官沟通好。 这个应聘者最大的问题就是还没有养成在写代码之前考虑所有可能的测试用例的习惯，逻辑不够严谨，因此一开始的代码只处理了最基本的数值转换。后来我每次提醒他一处特殊的测试用例之后，他改一处代码。尽管他已经做了两次修改，但仍然有不少很明显的漏洞，特殊输入空字符串”“，边界条件比如最大的正整数与最小的负整数等。由于这道题思路本身不难，因此我希望他把问题考虑得极可能周到，代码尽量写完整。 三、解题思路 public class Test { /** * 题目：实现一个函数stringToInt,实现把字符串转换成整数这个功能， * 不能使用atoi或者其他类似的库函数。 * * @param num * @return */ public static int stringToInt(String num) { if (num == null || num.length() = '0') { return parseString(num, 0, true); } else { throw new NumberFormatException(num); } } /** * 判断字符是否是数字 * * @param c 字符 * @return true是，false否 */ private static boolean isDigit(char c) { return c >= '0' && c = num.length()) { throw new NumberFormatException(num); } int result; long tmp = 0; while (index 0x8000_0000L) { throw new NumberFormatException(num); } index++; } if (positive) { if (tmp >= 0x8000_0000L) { throw new NumberFormatException(num); } else { result = (int) tmp; } } else { if (tmp == 0x8000_0000L) { result = 0x8000_0000; } else { result = (int) -tmp; } } return result; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/48.html":{"url":"algorithm/For-offer/48.html","title":"48.树中两个结点的最低公共结点","keywords":"","body":"一、题目 求树中两个结点的最低公共祖先，此树不是二叉树，并且没有指向父节点的指针。 二、解题思路 我们首先得到一条从根结点到树中某一结点的路径，这就要求在遍历的时候，有一个辅助内存来保存路径． 比如我们用前序遍历的方法来得到从根结点到H 的路径的过程是这样的：（ 1 ）遍历到A，把A 存放到路径中去，路径中只有一个结点A; ( 2 ）遍历到B，把B 存到路径中去，此时路径为A->B; ( 3 ）遍历到D，把D 存放到路径中去，此，时路径为A->B->D; ( 4 ） 遍历到F，把F 存放到路径中去，此时路径为A->B->D->F;( 5) F 已经没有子结点了，因此这条路径不可能到这结点H. 把F 从路径中删除，变成A->B->D; ( 6 ）遍历G. 和结点F 一样，这条路径也不能到达H. 边历完G 之后，路径仍然是A->B->D; ( 7 ）由于D 的所有子结点都遍历过了，不可能到这结点H，因此D 不在从A 到H 的路径中，把D 从路径中删除，变成A->B; ( 8 ）遥历E，把E 加入到路径中，此时路径变成A->B->E, ( 9 ）遍历H，已经到达目标给点， A->B->E 就是从根结点开始到达H 必须经过的路径。 同样，我们也可以得到从根结点开始到达F 必须经过的路径是A->B。接着，我们求出这两个路径的最后公共结点，也就是B. B这个结点也是F 和H 的最低公共祖先． 为了得到从根结点开始到输入的两个结点的两条路径，需要遍历两次树，每边历一次的时间复杂度是O(n)。 三、解题代码 public class Test{ /** * 树的结点定义 */ private static class TreeNode { int val; List children = new LinkedList<>(); public TreeNode() { } public TreeNode(int val) { this.val = val; } @Override public String toString() { return val + \"\"; } } /** * 找结点的路径 * * @param root 根结点 * @param target 目标结点 * @param path 从根结点到目标结点的路径 */ public static void getNodePath(TreeNode root, TreeNode target, List path) { if (root == null) { return; } // 添加当前结点 path.add(root); List children = root.children; // 处理子结点 for (TreeNode node : children) { if (node == target) { path.add(node); return; } else { getNodePath(node, target, path); } } // 现场还原 path.remove(path.size() - 1); } /** * 找两个路径中的最后一个共同的结点 * * @param p1 路径1 * @param p2 路径2 * @return 共同的结点，没有返回null */ public static TreeNode getLastCommonNode(List p1, List p2) { Iterator ite1 = p1.iterator(); Iterator ite2 = p2.iterator(); TreeNode last = null; while (ite1.hasNext() && ite2.hasNext()) { TreeNode tmp = ite1.next(); if (tmp == ite2.next()) { last = tmp; } } return last; } /** * 找树中两个结点的最低公共祖先 * @param root 树的根结点 * @param p1 结点1 * @param p2 结点2 * @return 公共结点，没有返回null */ public static TreeNode getLastCommonParent(TreeNode root, TreeNode p1, TreeNode p2) { if (root == null || p1 == null || p2 == null) { return null; } List path1 = new LinkedList<>(); getNodePath(root, p1, path1); List path2 = new LinkedList<>(); getNodePath(root, p2, path2); return getLastCommonNode(path1, path2); } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/49.html":{"url":"algorithm/For-offer/49.html","title":"49.数组中重复的数字","keywords":"","body":"一、题目 在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 举例说明 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。 二、解题思路 解决这个问题的一个简单的方法是先把输入的数组排序。从排序的数组中找出重复的数字时间很容易的事情，只需要从头到尾扫描排序后的数组就可以了。排序一个长度为n的数组需要O(nlogn)的时间。 还可以利用哈希表来解决这个问题。从头到尾按顺序扫描数组的每个数，每扫描一个数字的时候，都可以用O(1)的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入到哈希表里。如果哈希表里已经存在该数字了，那么就找到一个重复的数字。这个算法的时间复杂度是O(n)，但它提高时间效率是以一个大小为O(n)的哈希表为代价的。我们再看看有没有空间复杂度为O(1)的算法。 我们注意到数组中的数字都在0到n-1中。如果这个数组中没有重复的数字，那么当数组排序之后数字i将出现在下标为i的位置。由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。 现在让我们重排这个数组，依然从头到尾一次扫描这个数组中的每个数字。当扫描到下标为i的数字时，首先比较这个数字（用m表示）是不是等于i。如果是，接着扫描下一个数字。如果不是，再拿它和第m个数字进行比较。 如果它和第m个数字相等，就找到了一个重复的数字（该数字在下标为i和m的位置都出现了）。如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重读这个比较、交换的过程，直到我们发现一个重复的数字。 以数组{2,3,1,0,2,5,3}为例来分析找到重复数字的步骤。数组的第0个数字（从0开始计数，和数组的下标保持一致）是2，与它的下标不相等，于是把它和下标为2的数字1交换。交换之后的数组是{1,3,2,0,2,5,3}。此时第0个数字是1，仍然与它的下标不相等，继续把它和下标为1的数字3交换，得到数组{3,1,2,0,2,5,3}.接下来继续交换第0个数字3和第3个数字0，得到数组{0,1,2,3,2,5,3}。此时第0个数字的数值为0，接着扫描下一个数字。在接下来的几个数字中，下标为1,2,3的三个数字分别为1,2,3，它们的下标和数值都分别相等，因此不需要做任何操作。接下来扫描到下标为4的数字2.由于它的数值与它的下标不相等，再比较它和下标为2的数字。注意到此时数组中下标为2的数字也是2，也就是数字在下标为2和下标为4的两个位置都出现了，因此找到一个重复的数字。 三、解题代码 public class Test{ /** * 题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的， * 但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 * 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者。 * * @param number * @return */ public static int duplicate(int[] number) { if (number == null || number.length = number.length) { return -1; } } for (int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/50.html":{"url":"algorithm/For-offer/50.html","title":"50.构建乘积数组","keywords":"","body":"一、题目 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1],不能使用除法。 二、解题思路 B[i]的值可以看作下图的矩阵中每行的乘积。 下三角用连乘可以很容求得，上三角，从下向上也是连乘。 因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。 三、解题代码 public class Test{ public static double[] multiply(double[] data) { if (data == null || data.length = 0; i--) { tmp *= data[i + 1]; result[i] *= tmp; } return result; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/51.html":{"url":"algorithm/For-offer/51.html","title":"51.正则表达式匹配","keywords":"","body":"一、题目 请实现一个函数用来匹配包含 . 和 的正则表达式。模式中的字符’.’表示任意一个字符，而 表示它前面的字符可以出现任意次（含0次）。本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串“aaa”与模式“a.a”和“abaca”匹配，但与“aa.a”及“ab*a”均不匹配。 二、解题思路 假设字符串为str，模式串为pattern，考虑以下情况： A. 模式串下一个字符为 * ： 如果当前字符匹配，三种可能： 1、模式串当前字符出现0次，即 * 表示当前字符出现0次，则str[i]->str[i],pattern[j]->pattern[j+2]; 2、模式串当前字符出现1次，即 * 表示当前字符出现1次，则str[i]->str[i+1],pattern[j]->pattern[j+2]; 3、模式串当前字符出现2次或2次以上，即 * 表示当前字符出现2次或以上，则str[i]->str[i+1],pattern[j]->pattern[i]; 如果当前字符不匹配，则只能让 * 表示当前字符出现0次，则str[i]->str[i]，pattern[j]->pattern[j+2]; B. 模式串下一个字符不为 * 如果当前字符匹配，则str=str+1,pattern=pattern+1. 三、解题代码 public class Test { /** * 题目：请实现一个函数用来匹配包含‘.’和‘*’的正则表达式。模式中的字符'.'表示任意一个字符， * 而‘*’表示它前面的字符可以出现任意次（含0次）。本题中，匹配是指字符串的所有字符匹配整个模式。 * * @param input * @param pattern * @return */ public static boolean match(String input, String pattern) { if (input == null || pattern == null) { return false; } return matchCore(input, 0, pattern, 0); } private static boolean matchCore(String input, int i, String pattern, int p) { // 匹配串和模式串都到达尾，说明成功匹配 if (i >= input.length() && p >= pattern.length()) { return true; } // 只有模式串到达结尾，说明匹配失败 if (i != input.length() && p >= pattern.length()) { return false; } // 模式串未结束，匹配串有可能结束有可能未结束 // p位置的下一个字符中为*号 if (p + 1 = input.length()) { return matchCore(input, i, pattern, p + 2); } // 匹配串还没有结束 else { if (pattern.charAt(p) == input.charAt(i) || pattern.charAt(p) == '.') { return // 匹配串向后移动一个位置，模式串向后移动两个位置 matchCore(input, i + 1, pattern, p + 2) // 匹配串向后移动一个位置，模式串不移动 || matchCore(input, i + 1, pattern, p) // 匹配串不移动，模式串向后移动两个位置 || matchCore(input, i, pattern, p + 2); } else { return matchCore(input, i, pattern, p + 2); } } } // 匹配串已经结束 if (i >= input.length()) { return false; } // 匹配串还没有结束 else { if (input.charAt(i) == pattern.charAt(p) || pattern.charAt(p) == '.') { return matchCore(input, i + 1, pattern, p + 1); } } return false; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/52.html":{"url":"algorithm/For-offer/52.html","title":"52.表示数值的字符串","keywords":"","body":"一、题目 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 例子说明 例如，字符串“+100”，“5e2”，“-123”，“3.1416”及”-1E-16”都表示数值，但“12e”,”1a3.14”,”1.2.3”,”+-5”及“12e+5.4”都不是。 二、解题思路 在数值之前可能有一个表示正负的’-‘或者’+’。接下来是若干个0到9的数位表示数值的整数部分（在某些小数里可能没有数值的整数部分）。如果数值是一个小数，那么在小数点后面可能会有若干个0到9的数位表示数值的小数部分。如果数值用科学计数法表示，接下来是一个’e’或者‘E’，以及紧跟着的一个整数（可以有正负号）表示指数。 判断一个字符串是否符合上述模式时，首先看第一个字符是不是正负号。如果是，在字符串上移动一个字符，继续扫描剩余的字符串中0到9的数位。如果是一个小数，则将遇到小数点。另外，如果是用科学计数法表示的数值，在整数或者小数的后面还有可能遇到’e’或者’E’。 三、解题代码 public class Test { /** * 题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 * * @param string * @return */ public static boolean isNumeric(String string) { if (string == null || string.length() = string.length()) { return false; } boolean numeric = true; index = scanDigits(string, index); // 还未到字符串的末尾 if (index = string.length()) { numeric = true; } // 还未到字符串结束位置 else if (index = string.length() || (string.charAt(index) != 'e' && string.charAt(index) != 'E')) { return false; } // 移动到下一个要处理的位置 index++; // 到达字符串的末尾，就返回false if (index >= string.length()) { return false; } if (string.charAt(index) == '+' || string.charAt(index) == '-') { index++; } // 到达字符串的末尾，就返回false if (index >= string.length()) { return false; } index = scanDigits(string, index); // 如果已经处理到了的数字的末尾就认为是正确的指数 return index >= string.length(); } /** * 扫描字符串部分的数字部分 * * @param string 字符串 * @param index 开始扫描的位置 * @return 从扫描位置开始第一个数字字符的位置 */ private static int scanDigits(String string, int index) { while (index = '0' && string.charAt(index) Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/53.html":{"url":"algorithm/For-offer/53.html","title":"53.字符流中第一个不重复的字符","keywords":"","body":"一、题目 请实现一个函数用来找出字符流中第一个只出现一次的字符。 举例说明 例如，当从字符流中只读出前两个字符“Go”时，第一个只出现一次的字符是‘g’。当从该字符流中读出前六个字符“google”时，第一个只出现1次的字符是”l”。 二、解题思路 字符只能一个接着一个从字符流中读出来。可以定义一个数据容器来保存字符在字符流中的位置。当一个字符第一次从字符流中读出来时，把它在字符流中的位置保存到数据容器里。当这个字符再次从字符流中被读出来时，那么它就不是只出现一次的字符，也就可以被忽略了。这时把它在数据容器里保存的值更新成一个特殊的值（比如负值）。 为了尽可能高校地解决这个问题，需要在O(1)时间内往容器里插入一个字符，以及更新一个字符对应的值。这个容器可以用哈希表来实现。用字符的ASCII码作为哈希表的键值，而把字符对应的位置作为哈希表的值。 三、解题代码 public class Test { /** * 题目：请实现一个函数用来找出字符流中第一个只出现一次的字符。 */ private static class CharStatistics { // 出现一次的标识 private int index = 0; private int[] occurrence = new int[256]; public CharStatistics() { for (int i = 0; i 255) { throw new IllegalArgumentException( ch + \"must be a ASCII char\"); } // 只出现一次 if (occurrence[ch] == -1) { occurrence[ch] = index; } else { // 出现了两次 occurrence[ch] = -2; } index++; } public char firstAppearingOnce(String data) { if (data == null) { throw new IllegalArgumentException(data); } for (int i = 0; i = 0 && occurrence[i] Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/54.html":{"url":"algorithm/For-offer/54.html","title":"54.链表中环的入口结点","keywords":"","body":"一、题目 一个链表中包含环，如何找出环的入口结点？ 二、解题思路 可以用两个指针来解决这个问题。先定义两个指针P1和P2指向链表的头结点。如果链表中环有n个结点，指针P1在链表上向前移动n步，然后两个指针以相同的速度向前移动。当第二个指针指向环的入口结点时，第一个指针已经围绕着环走了一圈又回到了入口结点。 剩下的问题就是如何得到环中结点的数目。我们在面试题15的第二个相关题目时用到了一快一慢的两个指针。如果两个指针相遇，表明链表中存在环。两个指针相遇的结点一定是在环中。可以从这个结点出发，一边继续向前移动一边计数，当再次回到这个结点时就可以得到环中结点数了。 三、解题代码 public class Test { private static class ListNode { private int val; private ListNode next; public ListNode() { } public ListNode(int val) { this.val = val; } @Override public String toString() { return val +\"\"; } } public static ListNode meetingNode(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { break; } } // 链表中没有环 if (fast == null || fast.next == null) { return null; } return fast; } public ListNode EntryNodeOfLoop(ListNode pHead) { ListNode meetingNode=meetingNode(pHead); if(meetingNode==null) return null; // 得到环中的节点个数 int nodesInLoop=1; ListNode p1=meetingNode; while(p1.next!=meetingNode){ p1=p1.next; ++nodesInLoop; } // 移动p1 p1=pHead; for(int i=0;i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/55.html":{"url":"algorithm/For-offer/55.html","title":"55.删除链表中重复的结点","keywords":"","body":"一、题目 在一个排序的链表中，如何删除重复的结点？ 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5 二、解题思路 解决这个问题的第一步是确定删除的参数。当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头结点也可能被删除，所以在链表头添加一个结点。 接下来我们从头遍历整个链表。如果当前结点的值与下一个结点的值相同，那么它们就是重复的结点，都可以被删除。为了保证删除之后的链表仍然是相连的而没有中间断开，我们要把当前的前一个结点和后面值比当前结点的值要大的结点相连。我们要确保prev要始终与下一个没有重复的结点连接在一起。 三、解题代码 public static ListNode deleteDuplication(ListNode pHead) { ListNode first = new ListNode(-1);//设置一个trick first.next = pHead; ListNode p = pHead; ListNode last = first; while (p != null && p.next != null) { if (p.val == p.next.val) { int val = p.val; while (p!= null&&p.val == val) p = p.next; last.next = p; } else { last = p; p = p.next; } } return first.next; } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/56.html":{"url":"algorithm/For-offer/56.html","title":"56.二叉树的下一个结点","keywords":"","body":"一、题目 给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父节点的指针。 二、解题思路 如果一个结点有右子树，那么它的下一个结点就是它的右子树中的左子结点。也就是说右子结点出发一直沿着指向左子结点的指针，我们就能找到它的下一个结点。 接着我们分析一个结点没有右子树的情形。如果结点是它父节点的左子结点，那么它的下一个结点就是它的父结点。 如果一个结点既没有右子树，并且它还是它父结点的右子结点，这种情形就比较复杂。我们可以沿着指向父节点的指针一直向上遍历，直到找到一个是它父结点的左子结点的结点。如果这样的结点存在，那么这个结点的父结点就是我们要找的下一个结点。 三、解题代码 public class Test { private static class BinaryTreeNode { private int val; private BinaryTreeNode left; private BinaryTreeNode right; private BinaryTreeNode parent; public BinaryTreeNode() { } public BinaryTreeNode(int val) { this.val = val; } @Override public String toString() { return val + \"\"; } } public static BinaryTreeNode getNext(BinaryTreeNode node) { if (node == null) { return null; } // 保存要查找的下一个节点 BinaryTreeNode target = null; if (node.right != null) { target = node.right; while (target.left != null) { target = target.left; } return target; } else if (node.parent != null){ target = node.parent; BinaryTreeNode cur = node; // 如果父新结点不为空，并且，子结点不是父结点的左孩子 while (target != null && target.left != cur) { cur = target; target = target.parent; } return target; } return null; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/57.html":{"url":"algorithm/For-offer/57.html","title":"57.对称的二叉树","keywords":"","body":"一、题目 请实现一个函数来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 二、解题思路 通常我们有三种不同的二叉树遍历算法，即前序遍历、中序遍历和后序遍历。在这三种遍历算法中，都是先遍历左子结点再遍历右子结点。我们是否可以定义一种遍历算法，先遍历右子结点再遍历左子结点？比如我们针对前序遍历定义一种对称的遍历算法，即先遍历父节点，再遍历它的右子结点，最后遍历它的左子结点。 我们发现可以用过比较二叉树的前序遍历序列和对称前序遍历序列来判断二叉树是不是对称的。如果两个序列一样，那么二叉树就是对称的。 三、解题代码 public class Test { private static class BinaryTreeNode { private int val; private BinaryTreeNode left; private BinaryTreeNode right; public BinaryTreeNode() { } public BinaryTreeNode(int val) { this.val = val; } @Override public String toString() { return val + \"\"; } } public static boolean isSymmetrical(BinaryTreeNode root) { return isSymmetrical(root, root); } private static boolean isSymmetrical(BinaryTreeNode left, BinaryTreeNode right) { if (left == null && right == null) { return true; } if (left == null || right == null) { return false; } if (left.val != right.val ) { return false; } return isSymmetrical(left.left, right.right) && isSymmetrical(left.right, right.left); } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/58.html":{"url":"algorithm/For-offer/58.html","title":"58.把二叉树打印出多行","keywords":"","body":"一、题目 从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。 二、解题思路 用一个队列来保存将要打印的结点。为了把二叉树的每一行单独打印到一行里，我们需要两个变量：一个变量表示在当前的层中还没有打印的结点数，另一个变量表示下一层结点的数目。 三、解题代码 public class Test { private static class BinaryTreeNode { private int val; private BinaryTreeNode left; private BinaryTreeNode right; public BinaryTreeNode() { } public BinaryTreeNode(int val) { this.val = val; } @Override public String toString() { return val + \"\"; } } /** * 题目：从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印一行。 * @param root */ public static void print(BinaryTreeNode root) { if (root == null) { return; } List list = new LinkedList<>(); BinaryTreeNode node; // 当前层的结点个数 int current = 1; // 记录下一层的结点个数 int next = 0; list.add(root); while (list.size() > 0) { node = list.remove(0); current--; System.out.printf(\"%-3d\", node.val); if (node.left != null) { list.add(node.left); next++; } if (node.right != null) { list.add(node.right); next++; } if (current ==0) { System.out.println(); current = next; next = 0; } } } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/59.html":{"url":"algorithm/For-offer/59.html","title":"59.按之字形顺序打印二叉树","keywords":"","body":"一、题目 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，即第一行按照从左到右的顺序打印，第二层按照从右到左顺序打印，第三行再按照从左到右的顺序打印，其他以此类推。 二、解题思路 按之字形顺序打印二叉树需要两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层，则先保存左子结点再保存右子结点到一个栈里；如果当前打印的是偶数层，则先保存右子结点再保存左子结点到第二个栈里。 三、解题代码 public class Test { private static class BinaryTreeNode { private int val; private BinaryTreeNode left; private BinaryTreeNode right; public BinaryTreeNode() { } public BinaryTreeNode(int val) { this.val = val; } @Override public String toString() { return val + \"\"; } } public static void print(BinaryTreeNode root) { if (root == null) { return; } List current = new LinkedList<>(); List reverse = new LinkedList<>(); int flag = 0; BinaryTreeNode node; current.add(root); while (current.size() > 0) { // 从最后一个开始取 node = current.remove(current.size() - 1); System.out.printf(\"%-3d\", node.val); // 当前是从左往右打印的，那就按从左往右入栈 if (flag == 0) { if (node.left != null) { reverse.add(node.left); } if (node.right != null) { reverse.add(node.right); } } // 当前是从右往左打印的，那就按从右往左入栈 else { if (node.right != null) { reverse.add(node.right); } if (node.left != null) { reverse.add(node.left); } } if (current.size() == 0) { flag = 1 - flag; List tmp = current; current = reverse; reverse = tmp; System.out.println(); } } } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/60.html":{"url":"algorithm/For-offer/60.html","title":"60.二叉搜索树的第k个结点","keywords":"","body":"一、题目 给定一棵二叉搜索树，请找出其中的第k大的结点。 二、解题思路 如果按照中序遍历的顺序遍历一棵二叉搜索树，遍历序列的数值是递增排序的。只需要用中序遍历算法遍历一棵二叉搜索树，就很容易找出它的第k大结点。 三、解题代码 public class Test { private static class BinaryTreeNode { private int val; private BinaryTreeNode left; private BinaryTreeNode right; public BinaryTreeNode() { } public BinaryTreeNode(int val) { this.val = val; } @Override public String toString() { return val + \"\"; } } public static BinaryTreeNode kthNode(BinaryTreeNode root, int k) { if (root == null || k Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/61.html":{"url":"algorithm/For-offer/61.html","title":"61.数据流中的中位数","keywords":"","body":"一、题目 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有值排序之后位于中间的数值。如果数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 二、解题思路 如果能够保证数据容器左边的数据都小于右边的数据，这样即使左、右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。如何快速从一个容器中找出最大数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆中找出最小数。　　因此可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是O(logn).由于只需O(1)时间就可以得到位于堆顶的数据，因此得到中位数的时间效率是O(1). 接下来考虑用最大堆和最小堆实现的一些细节。首先要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过1（为了实现平均分配，可以在数据的总数目是偶数时把新数据插入到最小堆中，否则插入到最大堆中）。 还要保证最大堆中里的所有数据都要小于最小堆中的数据。当数据的总数目是偶数时，按照前面分配的规则会把新的数据插入到最小堆中。如果此时新的数据比最大堆中的一些数据要小，怎么办呢？ 可以先把新的数据插入到最大堆中，接着把最大堆中的最大的数字拿出来插入到最小堆中。由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中的所有数字都大于最大堆中的数字。 当需要把一个数据插入到最大堆中，但这个数据小于最小堆里的一些数据时，这个情形和前面类似。 三、解题代码 public class Test { private static class Heap { // 堆中元素存放的集合 private List data; // 比较器 private Comparator cmp; /** * 构造函数 * * @param cmp 比较器对象 */ public Heap(Comparator cmp) { this.cmp = cmp; this.data = new ArrayList<>(64); } /** * 向上调整堆 * * @param idx 被上移元素的起始位置 */ public void shiftUp(int idx) { // 检查是位置是否正确 if (idx = data.size()) { throw new IllegalArgumentException(idx + \"\"); } // 获取开始调整的元素对象 T intent = data.get(idx); // 如果不是根元素，则需要上移 while (idx > 0) { // 找父元素对象的位置 int parentIdx = (idx - 1) / 2; // 获取父元素对象 T parent = data.get(parentIdx); //上移的条件，子节点比父节点大，此处定义的大是以比较器返回值为准 if (cmp.compare(intent, parent) > 0) { // 将父节点向下放 data.set(idx, parent); idx = parentIdx; // 记录父节点下放的位置 } // 子节点不比父节点大，说明父子路径已经按从大到小排好顺序了，不需要调整了 else { break; } } // index此时记录是的最后一个被下放的父节点的位置（也可能是自身）， // 所以将最开始的调整的元素值放入index位置即可 data.set(idx, intent); } /** * 向下调整堆 * * @param idx 被下移的元素的起始位置 */ public void shiftDown(int idx) { // 检查是位置是否正确 if (idx = data.size()) { throw new IllegalArgumentException(idx + \"\"); } // 获取开始调整的元素对象 T intent = data.get(idx); // 获取开始调整的元素对象的左子结点的元素位置 int leftIdx = idx * 2 + 1; // 如果有左子结点 while (leftIdx 0) { maxChild = rightChild; maxIdx = rightIdx; } } // 如果最大子节点比父节点大，则需要向下调整 if (cmp.compare(maxChild, intent) > 0) { // 将较大的子节点向上移 data.set(idx, maxChild); // 记录上移节点的位置 idx = maxIdx; // 找到上移节点的左子节点的位置 leftIdx = 2 * idx + 1; } // 最大子节点不比父节点大，说明父子路径已经按从大到小排好顺序了，不需要调整了 else { break; } } // index此时记录是的最后一个被上移的子节点的位置（也可能是自身）， // 所以将最开始的调整的元素值放入index位置即可 data.set(idx, intent); } /** * 添加一个元素 * * @param item 添加的元素 */ public void add(T item) { // 将元素添加到最后 data.add(item); // 上移，以完成重构 shiftUp(data.size() - 1); } /** * 删除堆顶结点 * * @return 堆顶结点 */ public T deleteTop() { // 如果堆已经为空，就抛出异常 if (data.isEmpty()) { throw new RuntimeException(\"The heap is empty.\"); } // 获取堆顶元素 T first = data.get(0); // 删除最后一个元素 T last = data.remove(data.size() - 1); // 删除元素后，如果堆为空的情况，说明删除的元素也是堆顶元素 if (data.size() == 0) { return last; } else { // 将删除的元素放入堆顶 data.set(0, last); // 自上向下调整堆 shiftDown(0); // 返回堆顶元素 return first; } } /** * 获取堆顶元素，但不删除 * * @return 堆顶元素 */ public T getTop() { // 如果堆已经为空，就抛出异常 if (data.isEmpty()) { throw new RuntimeException(\"The heap is empty.\"); } return data.get(0); } /** * 获取堆的大小 * * @return 堆的大小 */ public int size() { return data.size(); } /** * 判断堆是否为空 * * @return 堆是否为空 */ public boolean isEmpty() { return data.isEmpty(); } /** * 清空堆 */ public void clear() { data.clear(); } /** * 获取堆中所有的数据 * * @return 堆中所在的数据 */ public List getData() { return data; } } /** * 升序比较器 */ private static class IncComparator implements Comparator { @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } } /** * 降序比较器 */ private static class DescComparator implements Comparator { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } } private static class DynamicArray { private Heap max; private Heap min; public DynamicArray() { max = new Heap<>(new IncComparator()); min = new Heap<>(new DescComparator()); } /** * 插入数据 * * @param num 待插入的数据 */ public void insert(Integer num) { // 已经有偶数个数据了（可能没有数据） // 数据总数是偶数个时把新数据插入到小堆中 if ((min.size() + max.size()) % 2 == 0) { // 大堆中有数据，并且插入的元素比大堆中的元素小 if (max.size() > 0 && num 0 && num > min.size()) { // 将num加入的小堆中去 min.add(num); // 删除堆顶元素，小堆中的最小元素 num = min.deleteTop(); } // num插入到大堆中，当num大于小堆中的最小值进， // num就会变成小堆中的最小值，见上面的if操作 // 如果num不大于大堆中的最小值，num就是自身 max.add(num); } } public double getMedian() { int size = max.size() + min.size(); if (size == 0) { throw new RuntimeException(\"No numbers are available\"); } if ((size & 1) == 1) { return min.getTop(); } else { return (max.getTop() + min.getTop()) / 2.0; } } } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/62.html":{"url":"algorithm/For-offer/62.html","title":"62.滑动窗口的最大值","keywords":"","body":"一、题目 给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。 举例说明 例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小为3，那么一共存在6个滑动窗口，它们的最大值分别为{4,4,6,6,6,5}。 二、解题思路 如果采用蛮力法，这个问题似乎不难解决：可以扫描每一个滑动窗口的所有数字并找出其中的最大值。如果滑动窗口的大小为k，需要O(k)时间才能找出滑动窗口里的最大值。对于长度为n的输入数组，这个算法总的时间复杂度是O(nk)。 实际上一个滑动窗口可以看成是一个队列。当窗口滑动时，处于窗口的第一个数字被删除，同时在窗口的末尾添加一个新的数字。这符合队列的先进先出特性。如果能从队列中找出它的最大数，这个问题也就解决了。 但我们并不把滑动窗口的每个数值都存入队列中，而只把有可能成为滑动窗口最大值的数值存入到一个两端开口的队列。接着以输入数字{2,3,4,2,6,2,5,1}为例一步分析。 数组的第一个数字是2，把它存入队列中。第二个数字是3.由于它比前一个数字2大，因此2不可能成为滑动窗口中的最大值。2先从队列里删除，再把3存入到队列中。此时队列中只有一个数字3.针对第三个数字4的步骤类似，最终在队列中只剩下一个数字4.此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。 接下来处理第四个数字2。2比队列中的数字4小。当4滑出窗口之后2还是有可能成为滑动窗口的最大值，因此把2存入队列的尾部。现在队列中有两个数字4和2，其中最大值4仍然位于队列的头部。 下一个数字是6.由于它比队列中已有的数字4和2都大，因此这时4和2已经不可能成为滑动窗口中的最大值。先把4和2从队列中删除，再把数字6存入队列。这个时候最大值6仍然位于队列的头部。 第六个数字是2.由于它比队列中已有的数字6小，所以2也存入队列的尾部。此时队列中有两个数字，其中最大值6位于队列的头部。 接下来的数字是5.在队列中已有的两个数字6和2里，2小于5，因此2不可能是一个滑动窗口的最大值，可以把它从队列的尾部删除。删除数字2之后，再把数字5存入队列。此时队列里剩下两个数字6和5，其中位于队列头部的是最大值6. 数组最后一个数字是1，把1存入队列的尾部。注意到位于队列头部的数字6是数组的第5个数字，此时的滑动窗口已经不包括这个数字了，因此应该把数字6从队列删除。 那么怎么知道滑动窗口是否包括一个数字？应该在队列里存入数字在数组里的下标，而不是数值。当一个数字的下标与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，这个数字已经从滑动窗口中滑出，可以从队列中删除了。 三、解题代码 public class Test { private static List maxInWindows(List data, int size) { List windowMax = new LinkedList<>(); // 条件检查 if (data == null || size idx = new LinkedList<>(); // 窗口还没有被填满时，找最大值的索引 for (int i = 0; i = data.get(idx.getLast())) { idx.removeLast(); } // 添加索引 idx.addLast(i); } // 窗口已经被填满了 for (int i = size; i = data.get(idx.getLast())) { idx.removeLast(); } // 删除已经滑出窗口的数据对应的下标 if (!idx.isEmpty() && idx.getFirst() Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/63.html":{"url":"algorithm/For-offer/63.html","title":"63.矩阵中的路径","keywords":"","body":"一、题目 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中间向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。 举例分析 例如在下面的3*4的矩阵中包含一条字符串”bcced”的路径。但矩阵中不包含字符串“abcb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二格子之后，路径不能再次进入这个格子。 a b c e s f c s a d e e 二、解题思路 这是一个可以用回朔法解决的典型题。首先，在矩阵中任选一个格子作为路径的起点。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。 由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。 由于路径不能重复进入矩阵的格子，还需要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否已经进入每个格子。 当矩阵中坐标为（row,col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下标为pathLength+1的字符。 如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符(pathLength-1)，然后重新定位。 一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到合适的位置 三、解题代码 public class Test { /** * 题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。 * 路径可以从矩阵中任意一格开始，每一步可以在矩阵中间向左、右、上、下移动一格。 * 如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。 * * @param matrix 输入矩阵 * @param rows 矩阵行数 * @param cols 矩阵列数 * @param str 要搜索的字符串 * @return 是否找到 true是，false否 */ public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) { // 参数校验 if (matrix == null || matrix.length != rows * cols || str == null || str.length = 0 && row = 0 && col Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/For-offer/64.html":{"url":"algorithm/For-offer/64.html","title":"64.机器人的运动范围","keywords":"","body":"一、题目 地上有个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。 举例分析 例如，当k为18时，机器人能够进入方格(35,37)，因为3+5+3+7=18.但它不能进入方格(35,38)，因为3+5+3+8=19.请问该机器人能够达到多少格子？ 二、解题思路 这个方格也可以看出一个m*n的矩阵。同样在这个矩阵中，除边界上的格子之外其他格子都有四个相邻的格子。 机器人从坐标(0,0)开始移动。当它准备进入坐标为(i,j)的格子时，通过检查坐标的数位和来判断机器人是否能够进入。如果机器人能够进入坐标为(i,j)的格子，我们接着再判断它能否进入四个相邻的格子(i,j-1)、(i-1,j),(i,j+1)和(i+1,j)。 三、解题代码 public class Test { /** * 题目：地上有个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动， * 它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数 * 位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35,37)， * 因为3+5+3+7=18.但它不能进入方格(35,38)，因为3+5+3+8=19. * 请问该机器人能够达到多少格子？ * * @param threshold 约束值 * @param rows 方格的行数 * @param cols 方格的列数 * @return 最多可走的方格 */ public static int movingCount(int threshold, int rows, int cols) { // 参数校验 if (threshold = 0 && col = 0 && row 0) { result += (number % 10); number /= 10; } return result; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/leetcode.html":{"url":"algorithm/leetcode.html","title":"LeetCode","keywords":"","body":"一、前言 LeetCode这部分内容的算法比较难，自己能力有限，刷的题目也比较少，这部分内容就面试及笔试出现的频率整理出一部分内容，熟悉相关解题方法，争取在笔试中能够AC。 整理内容主要包括以下几个部分： 数组 字符串 链表 动态规划 贪心算法 二、目录 Dynamic Programming Distinct Subsequences Longest Common Subsequence Longest Increasing Subsequence Best Time to Buy and Sell Stock Maximum Subarray Maximum Product Subarray Longest Palindromic Substring BackPack Maximal Square Stone Game Array Partition Array Subarray Sum Plus One Palindrome Number Two Sum String Restore IP Addresses Rotate String Valid Palindrome Length of Last Word Linked List Remove Duplicates from Sorted List Partition List Merge Two Sorted Lists LRU Cache Remove Linked List Elements Greedy Jump Game Gas Station Candy Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming.html":{"url":"algorithm/LeetCode/Dynamic-Programming.html","title":"Dynamic Programming","keywords":"","body":"一、动态规划 1. 简介 动态规划的本质，是对问题状态的定义和状态转移方程的定义。 dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems. 动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。 以下介绍，大多都是在说递推的求解方法，但如何拆分问题，才是动态规划的核心。 而拆分问题，靠的就是状态的定义和状态转移方程的定义。 2. 状态的定义 首先想说大家千万不要被下面的数学式吓到，这里只涉及到了函数相关的知识。 给定一个数列，长度为N， 求这个数列的最长上升（递增）子数列（LIS）的长度. 以 1 7 2 8 3 4 为例。 这个数列的最长递增子数列是 1 2 3 4，长度为4； 次长的长度为3， 包括 1 7 8; 1 2 3 等. 要解决这个问题，我们首先要定义这个问题和这个问题的子问题。 有人可能会问了，题目都已经在这了，我们还需定义这个问题吗？需要，原因就是这个问题在字面上看，找不出子问题，而没有子问题，这个题目就没办法解决。 给定一个数列，长度为N， 设为：以数列中第k项结尾的最长递增子序列的长度. 求 中的最大值. 显然，这个新问题与原问题等价。 而对于来讲，都是的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第中某项结尾的LIS。 上述的新问题也可以叫做状态，定义中的“为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。 之所以把做“状态”而不是“问题” ，一是因为避免跟原问题中“问题”混淆，二是因为这个新问题是数学化定义的。 对状态的定义只有一种吗？当然不是 给定一个数列，长度为N， 设$F{i,k}$为： 在前i项中的，长度为k的最长递增子序列中，最后一位的最小值. 1{i,k}$为正无穷. 求最大的x，使得$F_{N,k}$不为正无穷。 这个新定义与原问题的等价性也不难证明，请读者体会一下。 上述的$F{i,k}$就是状态，定义中的“$F{i,k}$为：在前i项中，长度为k的最长递增子序列中，最后一位的最小值”就是对状态的定义。 3. 状态转移方程 上述状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程。 设为：以数列中第k项结尾的最长递增子序列的长度. 设A为题中数列，状态转移方程为： 用文字解释一下是： 以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。 第二种定义： 设$F_{i,k}$为：在数列前i项中，长度为k的递增子序列中，最后一位的最小值 设A为题中数列，状态转移方程为： （边界情况需要分类讨论较多，在此不列出，需要根据状态定义导出边界情况。） 大家套着定义读一下公式就可以了，应该不难理解，就是有点绕。 这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。 可以看出，状态转移方程就是带有条件的递推式。 二、目录 本部分内容整理一些LeetCode中关于动态规划的常见问题及Java解决方案，供大家学习动态规划。 Distinct Subsequences Longest Common Subsequence Longest Increasing Subsequence Best Time to Buy and Sell Stock Maximum Subarray Maximum Product Subarray Longest Palindromic Substring BackPack Maximal Square Stone Game Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming/Distinct-Subsequences.html":{"url":"algorithm/LeetCode/Dynamic-Programming/Distinct-Subsequences.html","title":"Distinct Subsequences","keywords":"","body":"一、题目 Given a string S and a string T, count the number of distinct subsequences of T in S.A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not). Here is an example: S = \"rabbbit\", T = \"rabbit\" Return 3. 给定两个字符串S和T，求S有多少个不同的子串与T相同。S的子串定义为在S中任意去掉0个或者多个字符形成的串。 二、解题思路 动态规划，设dp[i][j] 是从字符串S[0...i]中删除几个字符得到字符串T[0...j]的不同的删除方法种类，动态规划方程如下 如果S[i] = T[j], dp[i][j] = dp[i-1][j-1]+dp[i-1][j] 如果S[i] 不等于 T[j], dp[i][j] = dp[i-1][j] 初始条件：当T为空字符串时，从任意的S删除几个字符得到T的方法为1 dp[0][0] = 1; // T和S都是空串. dp[1 ... S.length() - 1][0] = 1; // T是空串，S只有一种子序列匹配。 dp[0][1 ... T.length() - 1] = 0; // S是空串，T不是空串，S没有子序列匹配。 三、解题代码 public int numDistincts(String S, String T) { int[][] table = new int[S.length() + 1][T.length() + 1]; for (int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming/Longest-Common-Subsequence.html":{"url":"algorithm/LeetCode/Dynamic-Programming/Longest-Common-Subsequence.html","title":"Longest Common Subsequence","keywords":"","body":"一、题目 Given two strings, find the longest common subsequence (LCS). Your code should return the length of LCS. Have you met this question in a real interview? Yes Example For \"ABCD\" and \"EDCA\", the LCS is \"A\" (or \"D\", \"C\"), return 1. For \"ABCD\" and \"EACB\", the LCS is \"AC\", return 2. 求最长公共子序列的数目，注意这里的子序列可以不是连续序列。 二、解题思路 求『最长』类的题目往往与动态规划有点关系，这里是两个字符串，故应为双序列动态规划。 这道题的状态很容易找，不妨先试试以f[i][j]表示字符串 A 的前 i 位和字符串 B 的前 j 位的最长公共子序列数目，那么接下来试试寻找其状态转移方程。从实际例子ABCD和EDCA出发，首先初始化f的长度为字符串长度加1，那么有f[0][0] = 0, f[0][*] = 0, f[*][0] = 0, 最后应该返回f[lenA][lenB]. 即 f 中索引与字符串索引对应(字符串索引从1开始算起)，那么在A 的第一个字符与 B 的第一个字符相等时，f[1][1] = 1 + f[0][0], 否则f[1][1] = max(f[0][1], f[1][0])。 推而广之，也就意味着若A[i] == B[j], 则分别去掉这两个字符后，原 LCS 数目减一，那为什么一定是1而不是0或者2呢？因为不管公共子序列是以哪个字符结尾，在A[i] == B[j]时 LCS 最多只能增加1. 而在A[i] != B[j]时，由于A[i] 或者 B[j] 不可能同时出现在最终的 LCS 中，故这个问题可进一步缩小，f[i][j] = max(f[i - 1][j], f[i][j - 1]). 需要注意的是这种状态转移方程只依赖最终的 LCS 数目，而不依赖于公共子序列到底是以第几个索引结束。 三、解题代码 public class Solution { /** * @param A, B: Two strings. * @return: The length of longest common subsequence of A and B. */ public int longestCommonSubsequence(String A, String B) { if (A == null || A.length() == 0) return 0; if (B == null || B.length() == 0) return 0; int lenA = A.length(); int lenB = B.length(); int[][] lcs = new int[1 + lenA][1 + lenB]; for (int i = 1; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming/Longest-Increasing-Subsequence.html":{"url":"algorithm/LeetCode/Dynamic-Programming/Longest-Increasing-Subsequence.html","title":"Longest Increasing Subsequence","keywords":"","body":"一、题目 Given a sequence of integers, find the longest increasing subsequence (LIS). You code should return the length of the LIS. Example For [5, 4, 1, 2, 3], the LIS is [1, 2, 3], return 3 For [4, 2, 4, 5, 3, 7], the LIS is [4, 4, 5, 7], return 4 二、解题思路 方案一：动态规划 时间复杂度O(n*n) dp[i]表示以i结尾的子序列中LIS的长度。然后我用dp[j](0来表示在i之前的LIS的长度。然后我们可以看到，只有当a[i]>a[j]的时候，我们需要进行判断，是否将a[i]加入到dp[j]当中。为了保证我们每次加入都是得到一个最优的LIS，有两点需要注意：第一，每一次，a[i]都应当加入最大的那个dp[j]，保证局部性质最优，也就是我们需要找到max(dp[j](0；第二，每一次加入之后，我们都应当更新dp[j]的值，显然，dp[i]=dp[j]+1。 如果写成递推公式，我们可以得到dp[i]=max(dp[j](0a[j]?1:0)。 方案二：二分搜索 时间复杂度O(nlogn) 开一个栈，每次取栈顶元素top和读到的元素temp做比较，如果temp > top 则将temp入栈；如果temp 这也是很好理解的，对于x和y，如果x 举例：原序列为1，5，8，3，6，7 栈为1，5，8，此时读到3，用3替换5，得到1，3，8； 再读6，用6替换8，得到1，3，6；再读7，得到最终栈为1，3，6，7。最长递增子序列为长度4。 三、解题代码 方案一： public int longestIncreasingSubsequence(int[] nums) { int []f = new int[nums.length]; int max = 0; for (int i = 0; i f[j] + 1 ? f[i] : f[j] + 1; } } if (f[i] > max) { max = f[i]; } } return max; } 方案二： public int findLongest(int[] A, int n) { int length = A.length; int[] B = new int[length]; B[0] = A[0]; int end = 0; for (int i = 1; i = B[end]) { B[++end] = A[i]; continue; } // 否则，需要先找到替换位置 int pos = findInsertPos(B, A[i], 0, end); B[pos] = A[i]; } for (int i = 0; i n) { end = mid ; } else { return mid; } } return start; } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming/stock.html":{"url":"algorithm/LeetCode/Dynamic-Programming/stock.html","title":"Best Time to Buy and Sell Stock","keywords":"","body":"1.1 题目 Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. 这是卖股票的一个题目，一个数组prices，其中prices[i]表示第i天股票的价格。根据题意我们知道只能进行一次交易，但需要获得最大的利润。 1.2 解题思路 我们需要在最低价买入，最高价卖出，当然买入一定要在卖出之前。 对于这一题，还是比较简单的，我们只需要遍历一次数组，通过一个变量记录当前最低价格，同时算出此次交易利润，并与当前最大值比较就可以了。 1.3 解题代码 public class Solution { public int maxProfit(int[] prices) { if (prices == null || prices.length == 0) { return 0; } int min = Integer.MAX_VALUE; //just remember the smallest price int profit = 0; for (int i : prices) { min = i profit ? i - min : profit; } return profit; } } 2.1 题目 Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。 2.2 解题思路 因为不限制交易次数，我们在第i天买入，如果发现i + 1天比i高，那么就可以累加到利润里面。 2.3 解题代码 public class Solution { public int maxProfit(int[] prices) { int profit = 0; for (int i = 0; i 0) { profit += diff; } } return profit; } } 3.1 题目 Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来找到最大的利润。你最多可以完成两笔交易。然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。 3.2 解题思路 最多允许两次不相交的交易，也就意味着这两次交易间存在某一分界线，考虑到可只交易一次，也可交易零次，故分界线的变化范围为第一天至最后一天，只需考虑分界线两边各自的最大利润，最后选出利润和最大的即可。 这种方法抽象之后则为首先将 [1,n] 拆分为 [1,i] 和 [i+1,n], 参考卖股票系列的第一题计算各自区间内的最大利润即可。[1,i] 区间的最大利润很好算，但是如何计算 [i+1,n] 区间的最大利润值呢？难道需要重复 n 次才能得到？注意到区间的右侧 n 是个不变值，我们从 [1, i] 计算最大利润是更新波谷的值，那么我们可否逆序计算最大利润呢？这时候就需要更新记录波峰的值了 3.3 解题代码 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit(int[] prices) { if (prices == null || prices.length = 0; i--) { profitBack[i] = Math.max(profitBack[i + 1], peak - prices[i]); peak = Math.max(peak, prices[i]); } // add the profit front and back int profit = 0; for (int i = 0; i 4.1 题目 Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Example Given prices = [4,4,6,1,1,4,2,5], and k = 2, return 6. Note You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Challenge O(nk) time. 题目和上面一样，就是变成要求交易k次，时间复杂度O(nk) 。 4.2 解题思路 我们仍然使用动态规划来完成。我们维护两种量，一个是当前到达第i天可以最多进行j次交易，最好的利润是多少（global[i][j]），另一个是当前到达第i天，最多可进行j次交易，并且最后一次交易在当天卖出的最好的利润是多少（local[i][j]）。下面我们来看递推式，全局的比较简单， global[i][j]=max(local[i][j],global[i-1][j])， 也就是去当前局部最好的，和过往全局最好的中大的那个（因为最后一次交易如果包含当前天一定在局部最好的里面，否则一定在过往全局最优的里面）。 全局（到达第i天进行j次交易的最大收益） = max{局部（在第i天交易后，恰好满足j次交易），全局（到达第i-1天时已经满足j次交易）} 对于局部变量的维护，递推式是 local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)， 也就是看两个量，第一个是全局到i-1天进行j-1次交易，然后加上今天的交易，如果今天是赚钱的话（也就是前面只要j-1次交易，最后一次交易取当前天），第二个量则是取local第i-1天j次交易，然后加上今天的差值（这里因为local[i-1][j]比如包含第i-1天卖出的交易，所以现在变成第i天卖出，并不会增加交易次数，而且这里无论diff是不是大于0都一定要加上，因为否则就不满足local[i][j]必须在最后一天卖出的条件了）。 局部（在第i天交易后，总共交易了j次） = max{情况2，情况1} 情况1：在第i-1天时，恰好已经交易了j次（local[i-1][j]），那么如果i-1天到i天再交易一次：即在第i-1天买入，第i天卖出（diff），则这不并不会增加交易次数！【例如我在第一天买入，第二天卖出；然后第二天又买入，第三天再卖出的行为 和 第一天买入，第三天卖出 的效果是一样的，其实只进行了一次交易！因为有连续性】 情况2：第i-1天后，共交易了j-1次（global[i-1][j-1]），因此为了满足“第i天过后共进行了j次交易，且第i天必须进行交易”的条件：我们可以选择1：在第i-1天买入，然后再第i天卖出（diff），或者选择在第i天买入，然后同样在第i天卖出（收益为0）。 上面的算法中对于天数需要一次扫描，而每次要对交易次数进行递推式求解，所以时间复杂度是O(n*k)，如果是最多进行两次交易，那么复杂度还是O(n)。空间上只需要维护当天数据皆可以，所以是O(k)，当k=2，则是O(1)。 补充：这道题还有一个陷阱，就是当k大于天数时，其实就退化成 Best Time to Buy and Sell Stock II 了。 4.3 解题代码 public class Solution { /** * @param k: An integer * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit(int k, int[] prices) { if (prices == null || prices.length prices[i-1]) { maxProfit += prices[i] - prices[i-1]; } } return maxProfit; } }; Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming/Maximum-Subarray.html":{"url":"algorithm/LeetCode/Dynamic-Programming/Maximum-Subarray.html","title":"Maximum Subarray","keywords":"","body":"一、题目 Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [−2,1,−3,4,−1,2,1,−5,4], the contiguous subarray [4,−1,2,1] has the largest sum = 6. More practice: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 二、解题思路 方案一 典型的DP题： 状态dp[i]：以A[i]为最后一个数的所有max subarray的和。 通项公式：dp[i] = dp[i-1] 由于dp[i]仅取决于dp[i-1]，所以可以仅用一个变量来保存前一个状态，而节省内存。 方案二 虽然这道题目用dp解起来很简单，但是题目说了，问我们能不能采用divide and conquer的方法解答，也就是二分法。 假设数组A[left, right]存在最大区间，mid = (left + right) / 2，那么无非就是三中情况： 最大值在A[left, mid - 1]里面 最大值在A[mid + 1, right]里面 最大值跨过了mid，也就是我们需要计算[left, mid - 1]区间的最大值，以及[mid + 1, right]的最大值，然后加上mid，三者之和就是总的最大值 我们可以看到，对于1和2，我们通过递归可以很方便的求解，然后在同第3的结果比较，就是得到的最大值。 三、解题代码 方案一 public class Solution { /** * @param nums: A list of integers * @return: A integer indicate the sum of max subarray */ public int maxSubArray(int[] A) { int n = A.length; int[] dp = new int[n]; //dp[i] means the maximum subarray ending with A[i]; dp[0] = A[0]; int max = dp[0]; for(int i = 1; i 0 ? dp[i - 1] : 0); max = Math.max(max, dp[i]); } return max; } } 方案二 public class Solution { public int maxSubArray(int[] A) { int maxSum = Integer.MIN_VALUE; return findMaxSub(A, 0, A.length - 1, maxSum); } // recursive to find max sum // may appear on the left or right part, or across mid(from left to right) public int findMaxSub(int[] A, int left, int right, int maxSum) { if(left > right) return Integer.MIN_VALUE; // get max sub sum from both left and right cases int mid = (left + right) / 2; int leftMax = findMaxSub(A, left, mid - 1, maxSum); int rightMax = findMaxSub(A, mid + 1, right, maxSum); maxSum = Math.max(maxSum, Math.max(leftMax, rightMax)); // get max sum of this range (case: across mid) // so need to expend to both left and right using mid as center // mid -> left int sum = 0, midLeftMax = 0; for(int i = mid - 1; i >= left; i--) { sum += A[i]; if(sum > midLeftMax) midLeftMax = sum; } // mid -> right int midRightMax = 0; sum = 0; for(int i = mid + 1; i midRightMax) midRightMax = sum; } // get the max value from the left, right and across mid maxSum = Math.max(maxSum, midLeftMax + midRightMax + A[mid]); return maxSum; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming/Maxmimum-Product-Subarray.html":{"url":"algorithm/LeetCode/Dynamic-Programming/Maxmimum-Product-Subarray.html","title":"Maximum Product Subarray","keywords":"","body":"一、题目 Find the contiguous subarray within an array (containing at least one number) which has the largest product. For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6. 在一个数组中，寻找一个连续子数组使得成绩最大。 二、解题思路 这题是求数组中子区间的最大乘积，对于乘法，我们需要注意，负数乘以负数，会变成正数，所以解这题的时候我们需要维护两个变量，当前的最大值，以及最小值，最小值可能为负数，但没准下一步乘以一个负数，当前的最大值就变成最小值，而最小值则变成最大值了。 DP的四要素 状态： max_product[i]: 以nums[i]结尾的max subarray product min_product[i]: 以nums[i]结尾的min subarray product 方程： max_product[i] = getMax(max_product[i-1] * nums[i], min_product[i-1] * nums[i], nums[i]) min_product[i] = getMin(max_product[i-1] * nums[i], min_product[i-1] * nums[i], nums[i]) 初始化： max_product[0] = min_product[0] = nums[0] 结果： 每次循环中 max_product[i] 的最大值 三、解题代码 public class Solution { /** * @param nums: an array of integers * @return: an integer */ public int maxProduct(List nums) { int[] max = new int[nums.size()]; int[] min = new int[nums.size()]; min[0] = max[0] = nums.get(0); int result = nums.get(0); for (int i = 1; i 0) { max[i] = Math.max(max[i], max[i - 1] * nums.get(i)); min[i] = Math.min(min[i], min[i - 1] * nums.get(i)); } else if (nums.get(i) Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming/Longest-Palindromic-Substring.html":{"url":"algorithm/LeetCode/Dynamic-Programming/Longest-Palindromic-Substring.html","title":"Longest Palindromic Substring","keywords":"","body":"一、题目 Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. Example Given the string = \"abcdzdcab\", return \"cdzdc\". Challenge O(n2) time is acceptable. Can you do it in O(n) time. 求一个字符串中的最长回文子串。 二、解题思路 区间类动态规划 Time O(n^2), Space O(n^2) 用dp[i][j]来存DP的状态，需要较多的额外空间: Space O(n^2) DP的4个要素 状态： dp[i][j]: s.charAt(i)到s.charAt(j)是否构成一个Palindrome 转移方程： dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i 初始化： dp[i][j] = true when j - i 结果： 找 maxLen = j - i + 1;，并得到相应longest substring： longest = s.substring(i, j + 1); 中心扩展 这种方法基本思想是遍历数组，以其中的1个元素或者2个元素作为palindrome的中心，通过辅助函数，寻找能拓展得到的最长子字符串。外层循环 O(n)，内层循环O(n)，因此时间复杂度 Time O(n^2)，相比动态规划二维数组存状态的方法，因为只需要存最长palindrome子字符串本身，这里空间更优化：Space O(1)。 三、解题代码 区间DP，Time O(n^2) Space O(n^2) public class Solution { /** * @param s input string * @return the longest palindromic substring */ public String longestPalindrome(String s) { if(s == null || s.length() maxLen){ maxLen = j - i + 1; longest = s.substring(i, j + 1); } } } } return longest; } } Time O(n^2) Space O(1) public class Solution { /** * @param s input string * @return the longest palindromic substring */ public String longestPalindrome(String s) { if (s.isEmpty()) { return null; } if (s.length() == 1) { return s; } String longest = s.substring(0, 1); for (int i = 0; i longest.length()) { longest = tmp; } // get longest palindrome with center of i, i+1 tmp = helper(s, i, i + 1); if (tmp.length() > longest.length()) { longest = tmp; } } return longest; } // Given a center, either one letter or two letter, // Find longest palindrome public String helper(String s, int begin, int end) { while (begin >= 0 && end Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming/backpack.html":{"url":"algorithm/LeetCode/Dynamic-Programming/backpack.html","title":"BackPack","keywords":"","body":"1.1 题目 Given n items with size A[i], an integer m denotes the size of a backpack. How full you can fill this backpack? NoteYou can not divide any item into small pieces .Example If we have 4 items with size [2, 3, 5, 7], the backpack size is 11, we can select 2, 3 and 5, so that the max size we can fill this backpack is 10. If the backpack size is 12. we can select [2, 3, 7] so that we can fulfill the backpack. You function should return the max size we can fill in the given backpack. 在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]。 1.2 解题思路 本题是典型的01背包问题，每种类型的物品最多只能选择一件。 State:dp[i][S]表示前i个物品，取出一些能否组成和为S体积的背包 Function:f[i][S] = f[i-1][S - A[i]] or f[i-1][S] (A[i]表示第i个物品的大小) 转移方程想得到f[i][S]前i个物品取出一些物品想组成S体积的背包。 那么可以从两个状态转换得到。 （1）f[i-1][S - A[i]] 放入第i个物品，并且前i-1个物品能否取出一些组成和为S-A[i] 体积大小的背包。 （2）f[i-1][S]不放入第i个物品， 并且前i-1个物品能否取出一些组成和为S 体积大小的背包。 Intialize:f[1…n][0] = true; f[0][1... m]= false 初始化f[1...n][0]表示前1...n个物品，取出一些能否组成和为0 大小的背包始终为真。 其他初始化为假 Answer: 寻找使f[n][S]值为true的最大的S. （S的取值范围1到m） 1.3 解题代码 public class Solution { /** * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] * @return: The maximum size */ public int backPack(int m, int[] A) { boolean f[][] = new boolean[A.length + 1][m + 1]; for (int i = 0; i = A[i-1] && f[i-1][j - A[i-1]]) { f[i][j] = true; } } // for j } // for i for (int i = m; i >= 0; i--) { for (int j = A.length;j>=0;j--){ if (f[j][i]) { return i; } } } return 0; } } 2.1 题目 Given n items with size A[i] and value V[i], and a backpack with size m. What's the maximum value can you put into the backpack? Note You cannot divide item into small pieces and the total size of items you choose should smaller or equal to m. Example Given 4 items with size [2, 3, 5, 7] and value [1, 5, 2, 4], and a backpack with size 10. The maximum value is 9. 两个数组，一个表示体积，另一个表示价值，给定一个容积为m的背包，求背包装入物品的最大价值。 2.2 解题思路 首先定义状态 K(i,w) 为前 i 个物品放入size为 w 的背包中所获得的最大价值，则相应的状态转移方程为： K(i,w)=max{K(i−1,w),K(i−1,w−wi)+vi} 2.3 解题代码 public class Solution { /** * @param m: An integer m denotes the size of a backpack * @param A & V: Given n items with size A[i] and value V[i] * @return: The maximum value */ public int backPackII(int m, int[] A, int V[]) { // write your code here int[][] dp = new int[A.length + 1][m + 1]; for(int i = 0; i j){ dp[i][j] = dp[(i-1)][j]; } else{ dp[i][j] = Math.max(dp[(i-1)][j], dp[(i-1)][j-A[i-1]] + V[i-1]); } } } return dp[A.length][m]; } } 3.1 题目 Given n kind of items with size Ai and value Vi( each item has an infinite number available) and a backpack with size m. What's the maximum value can you put into the backpack? Notice You cannot divide item into small pieces and the total size of items you choose should smaller or equal to m. Example Given 4 items with size [2, 3, 5, 7] and value [1, 5, 2, 4], and a backpack with size 10. The maximum value is 15. 这道题相比上题变为：重复选择+最大价值。 3.2 解题思路 和01背包问题很类似 状态转移方程 不放A[i] f[i][j] =f[i-1][j] 放A[j] 可放多个设为k， k = j/A[i] f[i][j] = f[i-1][j- ki*A[i]] + ki*A[i] 0 3.3 解题代码 public class Solution { /** * 多重背包问题 * 总体积是m，每个小物品的体积是A[i] * * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] 0 开始的 A是 * @return: The maximum size */ public int backPackIII(int m, int[] A) { // write your code here int[][] P = new int[A.length+1][m+1];// P[i][j] 前i个物品放在j的空间中的最大价值 for(int i = 0;i=1;j--){ if(j>=A[i]){ int k = j/A[i];// 该物品最大可以放k个 while(k>=0){ if(j>=A[i]*k){ P[i+1][j] =Math.max(P[i+1][j], P[i][j-k*A[i]] + k*A[i]); } k--; } } else P[i+1][j] = Math.max(P[i][j],P[i+1][j]); } } return P[A.length][m]; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming/Maximal-Square.html":{"url":"algorithm/LeetCode/Dynamic-Programming/Maximal-Square.html","title":"Maximal Square","keywords":"","body":"一、题目 Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area. Example For example, given the following matrix: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Return 4. 给定一个二维矩阵，其中元素值为0或1,找出最大的一个正方形，使得其元素都为1,返回其面积。 二、解题思路 当我们判断以某个点为正方形右下角时最大的正方形时，那它的上方，左方和左上方三个点也一定是某个正方形的右下角，否则该点为右下角的正方形最大就是它自己了。 这是定性的判断，那具体的最大正方形边长呢？我们知道，该点为右下角的正方形的最大边长，最多比它的上方，左方和左上方为右下角的正方形的边长多1，最好的情况是是它的上方，左方和左上方为右下角的正方形的大小都一样的，这样加上该点就可以构成一个更大的正方形。 但如果它的上方，左方和左上方为右下角的正方形的大小不一样，合起来就会缺了某个角落，这时候只能取那三个正方形中最小的正方形的边长加1了。假设dp[i][j]表示以i,j为右下角的正方形的最大边长，则有 dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 当然，如果这个点在原矩阵中本身就是0的话，那dp[i][j]肯定就是0了。 三、解题代码 public class Solution { public int maximalSquare(char[][] matrix) { if(matrix.length == 0) return 0; int m = matrix.length, n = matrix[0].length; int max = 0; int[][] dp = new int[m][n]; // 第一列赋值 for(int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Dynamic-Programming/Stone-Game.html":{"url":"algorithm/LeetCode/Dynamic-Programming/Stone-Game.html","title":"Stone Game","keywords":"","body":"一、题目 There is a stone game.At the beginning of the game the player picks n piles of stones in a line. The goal is to merge the stones in one pile observing the following rules: At each step of the game, the player can merge two adjacent piles to a new pile. The score is the number of stones in the new pile. You are to determine the minimum of the total score. Example For [4, 1, 1, 4], in the best solution, the total score is 18: 1. Merge second and third piles => [4, 2, 4], score +2 2. Merge the first two piles => [6, 4]，score +6 3. Merge the last two piles => [10], score +10 Other two examples: [1, 1, 1, 1] return 8 [4, 4, 5, 9] return 43 一堆石头，每个石头代表一个值。每次可以合并两个相邻的石头，得分是合并后的和。一直合并，同时累计得分，直到变成一个石头，并求出得分最小的值。 二、解题思路 这道题可用DP解。 dp[i][j]表示合并i到j的石头需要的最小代价。 转移函数： dp[i][j]=dp[i][k]+dp[k+1][j]+sum[i][j] （idp[i][j]最小的k。 DP四要素 State: dp[i][j]表示把第i到第j个石子合并到一起的最小花费 Function: 预处理sum[i][j]表示i到j所有石子价值和 dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum[i][j]) 对于所有k属于{i,j} Intialize: for each i dp[i][i] = 0 Answer: dp[0][n-1] 区间型DP，利用二维数组下标表示下标范围。 需要注意的是对状态转移方程的理解，也就是对每一种分割方式进行遍历。 三、解题代码 public class Solution { /** * @param A an integer array * @return an integer */ public int stoneGame(int[] A) { // Write your code here // DP if(A == null || A.length == 0){ return 0; } int n = A.length; int[][] sum = new int[n][n]; for(int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Array.html":{"url":"algorithm/LeetCode/Array.html","title":"Array","keywords":"","body":"一、数组 数组是较为简单的数据结构，它占据一块连续的内存，并按照顺序存储数据。数组需要事先知道容量大小，然后根据大小分配存储空间，所以数组的空间利用率不高。数组有很好的查找效率，能在O(1)内找到元素。所以我们可以基于数组实现简单的hash表，提高查找效率。 关于数组是面试中常考的一种数据结构，此类的相关题目相对简单，一般通过数字规律，指针，动态规划等方法来解决。 二、目录 Partition Array Subarray Sum Plus One Palindrome Number Two Sum Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Array/Partition-Array.html":{"url":"algorithm/LeetCode/Array/Partition-Array.html","title":"Partition Array","keywords":"","body":"一、题目 Given an array nums of integers and an int k, partition the array (i.e move the elements in \"nums\") such that: All elements All elements >= k are moved to the right Return the partitioning index, i.e the first index i nums[i] >= k. Notice You should do really partition in array nums instead of just counting the numbers of integers smaller than k. If all elements in nums are smaller than k, then return nums.length 二、解题思路 根据给定的k，也就是类似于Quick Sort中的pivot，将array从两头进行缩进，时间复杂度 O(n) 三、解题代码 public class Solution { private void swap(int i, int j, int[] arr) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } /** *@param nums: The integer array you should partition *@param k: As description *return: The index after partition */ public int partitionArray(int[] nums, int k) { int pl = 0; int pr = nums.length - 1; while (pl = k) { pr--; } if (pl Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Array/Subarray-Sum.html":{"url":"algorithm/LeetCode/Array/Subarray-Sum.html","title":"Subarray Sum","keywords":"","body":"一、题目 Given an integer array, find a subarray where the sum of numbers is zero. Your code should return the index of the first number and the index of the last number. Example Given [-3, 1, 2, -3, 4], return [0, 2] or [1, 3]. 给定一个整数数组，找到和为零的子数组。你的代码应该返回满足要求的子数组的起始位置和结束位置 二、解题思路 记录每一个位置的sum，存入HashMap中，如果某一个sum已经出现过，那么说明中间的subarray的sum为0. 时间复杂度O(n)，空间复杂度O(n) 三、解题代码 public class Solution { /** * @param nums: A list of integers * @return: A list of integers includes the index of the first number * and the index of the last number */ public ArrayList subarraySum(int[] nums) { // write your code here int len = nums.length; ArrayList ans = new ArrayList(); HashMap map = new HashMap(); map.put(0, -1); int sum = 0; for (int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Array/plus-one.html":{"url":"algorithm/LeetCode/Array/plus-one.html","title":"Plus One","keywords":"","body":"一、题目 Given a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. Example Given [1,2,3] which represents 123, return [1,2,4]. Given [9,9,9] which represents 999, return [1,0,0,0]. 给一个包含非负整数的数组，其中每个值代表该位数的值，对这个数加1。 二、解题思路 数组的最后一个数是个位数，所以从后面开始读，个位数+1后，如果有进位，存储进位值，没有直接存储。 处理十位数，如果个位数有进位，十位数+1,在判断十位数有没有进位。 重复上面的动作直到没有进位。 三、解题代码 public class Solution { public int[] plusOne(int[] digits) { int carries = 1; for(int i = digits.length-1; i>=0 && carries > 0; i--){ // fast break when carries equals zero int sum = digits[i] + carries; digits[i] = sum % 10; carries = sum / 10; } if(carries == 0) return digits; int[] rst = new int[digits.length+1]; rst[0] = 1; for(int i=1; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Array/Palindrome-Number.html":{"url":"algorithm/LeetCode/Array/Palindrome-Number.html","title":"Palindrome Number","keywords":"","body":"一、题目 Determine whether an integer is a palindrome. Do this without extra space. 给定一个数字，要求判断这个数字是否为回文数字. 比如121就是回文数字，122就不是回文数字. 二、解题思路 题目要求只能用O(1)的空间，所以不能考虑把它转化为字符串然后reverse比较的方法。 基本思路是每次去第一位和最后一位，如果不相同则返回false，否则继续直到位数为0。 需要注意的点: 负数不是回文数字. 0是回文数字. 三、解题代码 public boolean isPalindrome(int x) { if(x0) { if(x/div!=x%10) return false; x = (x%div)/10; div /= 100; } return true; } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Array/Two-Sum.html":{"url":"algorithm/LeetCode/Array/Two-Sum.html","title":"Two Sum","keywords":"","body":"一、题目 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 给定一个整型数组，找出能相加起来等于一个特定目标数字的两个数。 二、解题思路 用hashmap，hashmap是内部存储方式为哈希表的map结构。遍历数组，其中key存放目标值减去当前值，value存放对应索引。如果在遍历过程中发现map中存在与当前值相等的key，则返回结果。 三、解题代码 public class Solution { /* * @param numbers : An array of Integer * @param target : target = numbers[index1] + numbers[index2] * @return : [index1 + 1, index2 + 1] (index1 map = new HashMap<>(); for (int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/String.html":{"url":"algorithm/LeetCode/String.html","title":"String","keywords":"","body":"一、字符串 关于字符串的题目，在面试和笔试中都有很多出现。主要包括以下几个方面： 大数问题。 字符串的翻转（全部翻转、部分翻转），拼接等问题。 字符串的模式匹配，找重复子串、公共前缀、回文问题。 以上几个方面的题目在剑指offer以及leetcode动态规划方面都有出现过。本部分主要整理了几个比较典型常考的题目。 二、目录 Restore IP Addresses Rotate String Valid Palindrome Length of Last Word Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/String/ip.html":{"url":"algorithm/LeetCode/String/ip.html","title":"Restore IP Addresses","keywords":"","body":"一、题目 Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example: Given \"25525511135\", return [\"255.255.11.135\", \"255.255.111.35\"]. (Order does not matter) 给一个由数字组成的字符串。求出其可能恢复为的所有IP地址。 注意 ：中间IP位置不能以0开始，0.01.01.1非法，应该是0.0.101.1或者0.0.10.11 二、解题思路 方法一： 直接三种循环暴力求解 方法二： 深度搜索，回溯 三、解题代码 方法一 public class Solution { /** * @param s the IP string * @return All possible valid IP addresses */ public ArrayList restoreIpAddresses(String s) { ArrayList res = new ArrayList(); int len = s.length(); for(int i = 1; i3 || s.length()==0 || (s.charAt(0)=='0' && s.length()>1) || Integer.parseInt(s)>255) return false; return true; } } 方法二 public class Solution { /** * @param s the IP string * @return All possible valid IP addresses */ public ArrayList restoreIpAddresses(String s) { ArrayList result = new ArrayList(); ArrayList list = new ArrayList(); if(s.length() 12) return result; helper(result, list, s , 0); return result; } public void helper(ArrayList result, ArrayList list, String s, int start){ if(list.size() == 4){ if(start != s.length()) return; StringBuffer sb = new StringBuffer(); for(String tmp: list){ sb.append(tmp); sb.append(\".\"); } sb.deleteCharAt(sb.length()-1); result.add(sb.toString()); return; } for(int i=start; i= 0 && digit Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/String/Rotate-String.html":{"url":"algorithm/LeetCode/String/Rotate-String.html","title":"Rotate String","keywords":"","body":"一、题目 Given a string and an offset, rotate string by offset. (rotate from left to right) Example Given \"abcdefg\". offset=0 => \"abcdefg\" offset=1 => \"gabcdef\" offset=2 => \"fgabcde\" offset=3 => \"efgabcd\" Challenge Rotate in-place with O(1) extra memory. 给定一个字符串和一个偏移量，根据偏移量旋转字符串(从左向右旋转) 二、解题思路 常见的翻转法应用题，仔细观察规律可知翻转的分割点在从数组末尾数起的offset位置。先翻转前半部分，随后翻转后半部分，最后整体翻转。 三、解题代码 public class Solution { /* * param A: A string * param offset: Rotate string with offset. * return: Rotated string. */ public char[] rotateString(char[] A, int offset) { if (A == null || A.length == 0) { return A; } int len = A.length; offset %= len; reverse(A, 0, len - offset - 1); reverse(A, len - offset, len - 1); reverse(A, 0, len - 1); return A; } private void reverse(char[] str, int start, int end) { while (start Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/String/Valid-Palindrome.html":{"url":"algorithm/LeetCode/String/Valid-Palindrome.html","title":"Valid Palindrome","keywords":"","body":"一、题目 Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example, \"A man, a plan, a canal: Panama\" is a palindrome. \"race a car\" is not a palindrome. Note: Have you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. 判断一个字符串是不是回文串。 二、解题思路 字符串的回文判断问题，由于字符串可随机访问，故逐个比较首尾字符是否相等最为便利，即常见的『两根指针』技法。 两步走： 找到最左边和最右边的第一个合法字符(字母或者字符) 一致转换为小写进行比较 三、解题代码 public class Solution { public boolean isPalindrome(String s) { if (s == null || s.trim().isEmpty()) { return true; } int l = 0, r = s.length() - 1; while (l Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/String/Length-of-Last-Word.html":{"url":"algorithm/LeetCode/String/Length-of-Last-Word.html","title":"Length of Last Word","keywords":"","body":"一、题目 Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example, Given s = \"Hello World\", return 5. 给定一个字符串， 包含大小写字母、空格' '，请返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 二、解题思路 关键点在于确定最后一个字符串之前的空格，此外还需要考虑末尾空格这一特殊情况。从最后往前扫描。 三、解题代码 public class Solution { public int lengthOfLastWord(String s) { if (s == null || s.isEmpty()) return 0; int len = 0; for (int i = s.length() - 1; i >= 0; i--) { if (s.charAt(i) == ' ') { if (len > 0) return len; } else { len++; } } return len; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Linked-List.html":{"url":"algorithm/LeetCode/Linked-List.html","title":"Linked List","keywords":"","body":"一、链表 链表是面试中十分容易考到的题目，一般代码比较短，而且考查面试者的思维全面性和写无bug代码的能力。在写链表的题目时，建议画出示意图，并把头结点、尾节点这些特殊的结点考虑在内。 常考题型如下: 题一、 给定单链表，检测是否有环 题二、 给定两个单链表(head1, head2)，检测两个链表是否有交点，如果有返回第一个交点。 题三、 给定单链表(head)，如果有环的话请返回从头结点进入环的第一个节点。 题四、只给定单链表中某个结点p(并非最后一个结点，即p->next!=NULL)指针，删除该结点。 题五、只给定单链表中某个结点p(非空结点)，在p前面插入一个结点。 题六、给定单链表头结点，删除链表中倒数第k个结点 题七、复杂链表复制 题八、两个不交叉的有序链表的合并 题九、链表翻转（包括全翻转，部分翻转，分段翻转）（递归或非递归实现） 题十、实现链表排序的一种算法 题十一、删除有序单链表中重复的元素 题十二、用链表模拟大整数加法运算 链表可以说是面试高频必问知识点，而关于链表的题目也比较固定。以上题目在剑指offer上大多出现过。本部分主要整理了几个比较典型常考的题目。 二、目录 Remove Duplicates from Sorted List Partition List Merge Two Sorted Lists LRU Cache Remove Linked List Elements Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Linked-List/Remove-Duplicates-from-Sorted-List.html":{"url":"algorithm/LeetCode/Linked-List/Remove-Duplicates-from-Sorted-List.html","title":"Remove Duplicates from Sorted List","keywords":"","body":"一、题目 Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1->1->2, return 1->2. Given 1->1->2->3->3, return 1->2->3. 给定一个排序链表，删除所有重复的元素每个元素只留下一个。 二、解题思路 遍历之，遇到当前节点和下一节点的值相同时，删除下一节点，并将当前节点next值指向下一个节点的next, 当前节点首先保持不变，直到相邻节点的值不等时才移动到下一节点。 三、解题代码 /** * Definition for ListNode * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { /** * @param ListNode head is the head of the linked list * @return: ListNode head of linked list */ public static ListNode deleteDuplicates(ListNode head) { ListNode curr = head; while (curr != null) { while (curr.next != null && curr.val == curr.next.val) { curr.next = curr.next.next; } curr = curr.next; } return head; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Linked-List/Partition-List.html":{"url":"algorithm/LeetCode/Linked-List/Partition-List.html","title":"Partition List","keywords":"","body":"一、题目 Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. For example, Given 1->4->3->2->5->2 and x = 3, return 1->2->2->4->3->5. 给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。 你应该保留两部分内链表节点原有的相对顺序。 二、解题思路 依据题意，是要根据值x对链表进行分割操作，具体是指将所有小于x的节点放到不小于x的节点之前，咋一看和快速排序的分割有些类似，但是这个题的不同之处在于只要求将小于x的节点放到前面，而并不要求对元素进行排序。 这种分割的题使用两路指针即可轻松解决。左边指针指向小于x的节点，右边指针指向不小于x的节点。由于左右头节点不确定，我们可以使用两个dummy节点。 三、解题代码 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ public class Solution { public ListNode partition(ListNode head, int x) { ListNode leftDummy = new ListNode(0); ListNode leftCurr = leftDummy; ListNode rightDummy = new ListNode(0); ListNode rightCurr = rightDummy; ListNode runner = head; while (runner != null) { if (runner.val Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Linked-List/Merge-Two-Sorted-Lists.html":{"url":"algorithm/LeetCode/Linked-List/Merge-Two-Sorted-Lists.html","title":"Merge Two Sorted Lists","keywords":"","body":"一、题目 Merge two sorted (ascending) linked lists and return it as a new sorted list. The new sorted list should be made by splicing together the nodes of the two lists and sorted in ascending order. Example Given 1->3->8->11->15->null, 2->null , return 1->2->3->8->11->15->null. 将两个排序链表合并为一个新的排序链表 二、解题思路 只需要从头开始比较已排序的两个链表，新链表指针每次指向值小的节点，依次比较下去，最后，当其中一个链表到达了末尾，我们只需要把新链表指针指向另一个没有到末尾的链表此时的指针即可。 三、解题代码 /** * Definition for ListNode. * public class ListNode { * int val; * ListNode next; * ListNode(int val) { * this.val = val; * this.next = null; * } * } */ public class Solution { /** * @param ListNode l1 is the head of the linked list * @param ListNode l2 is the head of the linked list * @return: ListNode head of linked list */ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode curr = dummy; while ((l1 != null) && (l2 != null)) { if (l1.val > l2.val) { curr.next = l2; l2 = l2.next; } else { curr.next = l1; l1 = l1.next; } curr = curr.next; } // link to non-null list curr.next = (l1 != null) ? l1 : l2; return dummy.next; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Linked-List/LRU-Cache.html":{"url":"algorithm/LeetCode/Linked-List/LRU-Cache.html","title":"LRU Cache","keywords":"","body":"一、题目 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 为最近最少使用（LRU）缓存策略设计一个数据结构，它应该支持以下操作：获取数据（get）和写入数据（set）。 获取数据get(key)：如果缓存中存在key，则获取其数据值（通常是正数），否则返回-1。 写入数据set(key, value)：如果key还没有在缓存中，则写入其数据值。当缓存达到上限，它应该在写入新数据之前删除最近最少使用的数据用来腾出空闲位置。 二、解题思路 双向链表加哈希表 缓存讲究的就是快，所以我们必须做到O(1)的获取速度，这样看来只有哈希表可以胜任。但是哈希表无序的，我们没办法在缓存满时，将最早更新的元素给删去。那么是否有一种数据结构，可以将先进的元素先出呢？那就是队列。所以我们将元素存在队列中，并用一个哈希表记录下键值和元素的映射，就可以做到O(1)获取速度，和先进先出的效果。然而，当我们获取一个元素时，还需要把这个元素再次放到队列头，这个元素可能在队列的任意位置，可是队列并不支持对任意位置的增删操作。而最适合对任意位置增删操作的数据结构又是什么呢？是链表。我可以用链表来实现一个队列，这样就同时拥有链表和队列的特性了。不过，如果仅用单链表的话，在任意位置删除一个节点还是很麻烦的，要么记录下该节点的上一个节点，要么遍历一遍。所以双向链表是最好的选择。我们用双向链表实现一个队列用来记录每个元素的顺序，用一个哈希表来记录键和值的关系，就行了。 三、解题代码 public class Solution { private int capacity; private HashMap map = new HashMap<>(); private Node head = new Node(-1, -1), tail = new Node(-1, -1); private class Node { Node prev, next; int val, key; public Node(int key, int val) { this.val = val; this.key = key; prev = null; next = null; } // @Override // public String toString() { // return \"(\" + key + \", \" + val + \") \" + \"last:\" // + (prev == null ? \"null\" : \"node\"); // } } public Solution(int capacity) { this.capacity = capacity; tail.prev = head; head.next = tail; } public int get(int key) { if (!map.containsKey(key)) { return -1; } // remove current Node currentNode = map.get(key); currentNode.prev.next = currentNode.next; currentNode.next.prev = currentNode.prev; // move current to tail; moveToTail(currentNode); return map.get(key).val; } public void set(int key, int value) { if (get(key) != -1) { map.get(key).val = value; return; } if (map.size() == capacity) { map.remove(head.next.key); head.next = head.next.next; head.next.prev = head; } Node insert = new Node(key, value); map.put(key, insert); moveToTail(insert); } private void moveToTail(Node current) { current.prev = tail.prev; tail.prev = current; current.prev.next = current; current.next = tail; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Linked-List/Remove-Linked-List-Elements.html":{"url":"algorithm/LeetCode/Linked-List/Remove-Linked-List-Elements.html","title":"Remove Linked List Elements","keywords":"","body":"一、题目 Remove all elements from a linked list of integers that have value val. Example Given 1->2->3->3->4->5->3, val = 3, you should return the list as 1->2->4->5 删除链表中等于给定值val的所有节点。 二、解题思路 删除链表中指定值，找到其前一个节点即可，将 next 指向下一个节点即可 三、解题代码 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ public class Solution { /** * @param head a ListNode * @param val an integer * @return a ListNode */ public ListNode removeElements(ListNode head, int val) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode curr = dummy; while (curr.next != null) { if (curr.next.val == val) { curr.next = curr.next.next; } else { curr = curr.next; } } return dummy.next; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Greedy.html":{"url":"algorithm/LeetCode/Greedy.html","title":"Greedy","keywords":"","body":"一、贪心算法 贪心法，又称贪心算法、贪婪算法、或称贪婪法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。 贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。 贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。 二、目录 Jump Game Gas Station Candy Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Greedy/Jump-Game.html":{"url":"algorithm/LeetCode/Greedy/Jump-Game.html","title":"Jump Game","keywords":"","body":"1.1 题目 Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example: A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. 给出一个非负整数数组，你最初定位在数组的第一个位置。　　　 数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　　 判断你是否能到达数组的最后一个位置。 1.2 解题思路 注意题目中A[i]表示的是在位置i，“最大”的跳跃距离，而并不是指在位置i只能跳A[i]的距离。所以当跳到位置i后，能达到的最大的距离至少是i+A[i]。用greedy来解，记录一个当前能达到的最远距离maxIndex： 能跳到位置i的条件：i 一旦跳到i，则maxIndex = max(maxIndex, i+A[i])。 能跳到最后一个位置n-1的条件是：maxIndex >= n-1 1.3 解题代码 public class Solution { public boolean canJump(int[] A) { // think it as merging n intervals if (A == null || A.length == 0) { return false; } int farthest = A[0]; for (int i = 1; i = farthest) { farthest = A[i] + i; } } return farthest >= A.length - 1; } } 2.1 题目 Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. For example: Given array A = [2,3,1,1,4] The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.) 给出一个非负整数数组，你最初定位在数组的第一个位置。 数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 2.2 解题思路 同样可以用greedy解决。与I不同的是，求的不是对每个i，从A[0:i]能跳到的最远距离；而是计算跳了k次后能达到的最远距离，这里的通项公式为： d[k] = max(i+A[i]) d[k-2] 2.3 解题代码 public class Solution { public int jump(int[] A) { if (A == null || A.length == 0) { return -1; } int start = 0, end = 0, jumps = 0; while (end farthest) { farthest = A[i] + i; } } start = end + 1; end = farthest; } return jumps; } } Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Greedy/Gas-Station.html":{"url":"algorithm/LeetCode/Greedy/Gas-Station.html","title":"Gas Station","keywords":"","body":"一、题目 There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once, otherwise return -1. Note: The solution is guaranteed to be unique. 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油gas[i]，并且从第i个加油站前往第i+1个加油站需要消耗汽油cost[i]。 你有一辆油箱容量无限大的汽车，现在要从某一个加油站出发绕环路一周，一开始油箱为空。 求可环绕环路一周时出发的加油站的编号，若不存在环绕一周的方案，则返回-1。 二、解题思路 首先我们可以得到所有油站的油量totalGas，以及总里程需要消耗的油量totalCost，如果totalCost大于totalGas，那么铁定不能够走完整个里程。 如果totalGas大于totalCost了，那么就能走完整个里程了，假设现在我们到达了第i个油站，这时候还剩余的油量为sum，如果 sum + gas[i] - cost[i]小于0，我们无法走到下一个油站，所以起点一定不在第i个以及之前的油站里面（都铁定走不到第i + 1号油站），起点只能在i + 1后者后面。 三、解题代码 public class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { if (gas == null || cost == null || gas.length == 0 || cost.length == 0) { return -1; } int sum = 0; int total = 0; int index = -1; for(int i = 0; i Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"algorithm/LeetCode/Greedy/Candy.html":{"url":"algorithm/LeetCode/Greedy/Candy.html","title":"Candy","keywords":"","body":"一、题目 There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? 有 N 个小孩站成一列。每个小孩有一个评级。 按照以下要求，给小孩分糖果： 每个小孩至少得到一颗糖果。 评级越高的小孩可以比他相邻的两个小孩得到更多的糖果。 需最少准备多少糖果？ 二、解题思路 首先我们会给每个小朋友一颗糖果，然后从左到右，假设第i个小孩的等级比第i - 1个小孩高，那么第i的小孩的糖果数量就是第i - 1个小孩糖果数量在加一。再我们从右到左，如果第i个小孩的等级大于第i + 1个小孩的，同时第i个小孩此时的糖果数量小于第i + 1的小孩，那么第i个小孩的糖果数量就是第i + 1个小孩的糖果数量加一。 三、解题代码 public class Solution { public int candy(int[] ratings) { if(ratings == null || ratings.length == 0) { return 0; } int[] count = new int[ratings.length]; Arrays.fill(count, 1); int sum = 0; for(int i = 1; i ratings[i - 1]) { count[i] = count[i - 1] + 1; } } for(int i = ratings.length - 1; i >= 1; i--) { sum += count[i]; if(ratings[i - 1] > ratings[i] && count[i - 1] Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Builder-Pattern.html":{"url":"design-mode/Builder-Pattern.html","title":"创建型模式","keywords":"","body":"一、前言 创建型模式 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。 创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 包含模式 简单工厂模式（Simple Factory） 工厂方法模式（Factory Method） 抽象工厂模式（Abstract Factory） 建造者模式（Builder） 原型模式（Prototype） 单例模式（Singleton） 二、目录 本部分没有包含以上所有模式，仅介绍了几种常用的。 简单工厂模式 工厂方法模式 抽象工厂模式 单例模式 建造者模式 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Builder-Pattern/Simple-Factory.html":{"url":"design-mode/Builder-Pattern/Simple-Factory.html","title":"简单工厂模式","keywords":"","body":"一、简单工厂模式简介 1.定义 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 2.使用动机 考虑一个简单的软件应用场景：一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观。 如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。 二、简单工厂模式结构 1.模式结构 简单工厂模式包含如下角色： ●Factory：工厂角色工厂角色负责实现创建所有实例的内部逻辑 ●Product：抽象产品角色抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ●ConcreteProduct：具体产品角色具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 2.时序图 ①先调用工厂类中的静态方法createProduct() ②根据传入产品类型参数，获得具体的产品对象 ③返回产品对象并使用 三、简单工厂的使用实例 以登录功能来说，假如应用系统需要支持多种登录方式如：口令认证、域认证（口令认证通常是去数据库中验证用户，而域认证则是需要到微软的域中验证用户）。那么自然的做法就是建立一个各种登录方式都适用的接口，如下图所示： 抽象产品Login public interface Login { //登录验证 public boolean verify(String name , String password); } 具体产品DomainLogin public class DomainLogin implements Login { @Override public boolean verify(String name, String password) { // TODO Auto-generated method stub /** * 业务逻辑 */ return true; } } 具体产品PasswordLogin public class PasswordLogin implements Login { @Override public boolean verify(String name, String password) { // TODO Auto-generated method stub /** * 业务逻辑 */ return true; } } 工厂类LoginManager根据调用者不同的要求，创建出不同的登录对象并返回。而如果碰到不合法的要求，会返回一个Runtime异常。 public class LoginManager { public static Login factory(String type){ if(type.equals(\"password\")){ return new PasswordLogin(); }else if(type.equals(\"passcode\")){ return new DomainLogin(); }else{ /** * 这里抛出一个自定义异常会更恰当 */ throw new RuntimeException(\"没有找到登录类型\"); } } } 测试调用 public class Test { public static void main(String[] args) { String loginType = \"password\"; String name = \"name\"; String password = \"password\"; Login login = LoginManager.factory(loginType); boolean bool = login.verify(name, password); if (bool) { /** * 业务逻辑 */ } else { /** * 业务逻辑 */ } } } 假如不使用简单工厂模式则验证登录Servlet代码如下： public class Test { public static void main(String[] args) { // TODO Auto-generated method stub String loginType = \"password\"; String name = \"name\"; String password = \"password\"; //处理口令认证 if(loginType.equals(\"password\")){ PasswordLogin passwordLogin = new PasswordLogin(); boolean bool = passwordLogin.verify(name, password); if (bool) { /** * 业务逻辑 */ } else { /** * 业务逻辑 */ } } //处理域认证 else if(loginType.equals(\"passcode\")){ DomainLogin domainLogin = new DomainLogin(); boolean bool = domainLogin.verify(name, password); if (bool) { /** * 业务逻辑 */ } else { /** * 业务逻辑 */ } }else{ /** * 业务逻辑 */ } } } 可以看到非常麻烦，代码重复很多，而且不利于扩展维护。 四、简单工厂模式优缺点 优点： 通过使用工厂类，外界不再需要关心如何创造各种具体的产品，只要提供一个产品的名称作为参数传给工厂，就可以直接得到一个想要的产品对象，并且可以按照接口规范来调用产品对象的所有功能（方法）。 构造容易，逻辑简单。 缺点： 1.简单工厂模式中的if else判断非常多，完全是Hard Code，如果有一个新产品要加进来，就要同时添加一个新产品类，并且必须修改工厂类，再加入一个 else if 分支才可以， 这样就违背了 “开放-关闭原则”中的对修改关闭的准则了。当系统中的具体产品类不断增多时候，就要不断的修改工厂类，对系统的维护和扩展不利。 2.一个工厂类中集合了所有的类的实例创建逻辑，违反了高内聚的责任分配原则，将全部的创建逻辑都集中到了一个工厂类当中，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。因此一般只在很简单的情况下应用，比如当工厂类负责创建的对象比较少时。 3.简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用环境 在以下情况下可以使用简单工厂模式： 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 五、简单工厂模式在Java中的应用 ①JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。 public final static DateFormat getDateInstance(); public final static DateFormat getDateInstance(int style); public final static DateFormat getDateInstance(int style,Locale locale); ②Java加密技术获取不同加密算法的密钥生成器: KeyGenerator keyGen=KeyGenerator.getInstance(\"DESede\"); 创建密码器: Cipher cp=Cipher.getInstance(\"DESede\"); Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Builder-Pattern/Factory-Method.html":{"url":"design-mode/Builder-Pattern/Factory-Method.html","title":"工厂方法模式","keywords":"","body":"一、工厂方法模式简介 1.定义 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。 在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 2.使用动机 现在对该系统（上篇文章提到）进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成。 我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。 二、工厂方法模式结构 1.模式结构 工厂方法模式包含如下角色： ●Product：抽象产品，工厂方法模式所创建的对象的超类，也就是所有产品类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。 ●ConcreteProduct：具体产品，这个角色实现了抽象产品（Product）所声明的接口，工厂方法模式所创建的每一个对象都是某个具体产品的实例。 ●Factory：抽象工厂，担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。 ●ConcreteFactory：具体工厂，担任这个角色的是实现了抽象工厂接口的具体Java类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建具体产品对象。 2.时序图 ①先调用具体工厂对象中的方法createProduct() ②根据传入产品类型参数（也可以无参），获得具体的产品对象 ③返回产品对象并使用 三、工厂方法模式的使用实例 上面的类图中，在灯这个品类下，有灯泡和灯管两种产品，并且都实现了灯的通用方法：关灯和开灯。在工厂类下，有各种生产具体产品的子工厂负责生产相应的两种灯具。 如果还不是太明白，那我们来假设一个情景。小明（客户端）想要买一个灯泡，他不认识工厂，只能去供销店（工厂类）买，于是和老板说“我要一个灯泡”，老板说 “没问题！您稍等”。转身到了后院，对生产灯泡的小弟（灯泡工厂子类）吆喝一声，给我造个灯泡！不一会灯泡造好了，老板拿给小明，“嘿嘿，灯泡给您作了一个，您试试？”，小明把灯泡拧在灯口上，开关了两下（灯的通用方法）“嘿！挺好，没问题！”，付了钱高高兴兴走了。 抽象的产品接口ILight public interface ILight { void TurnOn(); void TurnOff(); } 具体的产品类：BulbLight public class BulbLight implements ILight { public void TurnOn() { Console.WriteLine(\"BulbLight turns on.\"); } public void TurnOff() { Console.WriteLine(\"BulbLight turns off.\"); } } 具体的产品类：TubeLight public class TubeLight implements ILight { public void TurnOn() { Console.WriteLine(\"TubeLight turns on.\"); } public void TurnOff() { Console.WriteLine(\"TubeLight turns off.\"); } } 抽象的工厂类 public interface ICreator { ILight CreateLight(); } 具体的工厂类:BulbCreator public class BulbCreator implements ICreator { public ILight CreateLight() { return new BulbLight(); } } 具体的工厂类:TubeCreator public class TubeCreator implements ICreator { public ILight CreateLight() { return new TubeLight(); } } 客户端调用 static void Main(string[] args) { //先给我来个灯泡 ICreator creator = new BulbCreator(); ILight light = creator.CreateLight(); light.TurnOn(); light.TurnOff(); //再来个灯管看看 creator = new TubeCreator(); light = creator.CreateLight(); light.TurnOn(); light.TurnOff(); } 通过一个引用变量ICreator来创建产品对象，创建何种产品对象由指向的具体工厂类决定。通过工厂方法模式，将具体的应用逻辑和产品的创建分离开，促进松耦合。 本例中每个具体工厂类只负责生产一种类型的产品，当然每个具体工厂类也内部可以维护少数几种产品实例对象，类似于简单工厂模式。 四、工厂方法模式的优缺点 优点 ①在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 ②基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 ③使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”，这点比简单工厂模式更优秀。 缺点 ①在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 ②由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 适用场景 在以下情况下可以使用工厂方法模式： ①一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 ②一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 ③将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 五、工厂方法模式在Java中应用 JDBC中的工厂方法: Connection conn=DriverManager.getConnection(\"jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=\"); Statement statement=conn.createStatement(); ResultSet rs=statement.executeQuery(\"select * from UserInfo\"); Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Builder-Pattern/Abstract-Factory.html":{"url":"design-mode/Builder-Pattern/Abstract-Factory.html","title":"抽象工厂模式","keywords":"","body":"一、抽象工厂模式简介 1.定义 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 定义很难懂？没错，看起来是很抽象，不过这正反应了这种模式的强大。下面具体阐述下定义。 2.定义阐述 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种或几种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个不同种类产品对象，而不是单一种类的产品对象。 为了更清晰地理解工厂方法模式，需要先引入两个概念： 产品等级结构： 产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族： 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 二、抽象工厂模式结构 1.模式结构 抽象工厂模式包含如下角色： AbstractFactory：抽象工厂ConcreteFactory：具体工厂AbstractProduct：抽象产品Product：具体产品 2.时序图 ①先调用具体工厂对象中的方法createProductX()。根据具体工厂不同可以选择不同的方法，针对同一种工厂也可以选择不同的方法创建不同类型的产品对象。 ②根据传入产品类型参数（也可以无参），获得具体的产品对象 ③返回产品对象并使用 三、抽象工厂的使用实例 假设有一个移动终端工厂，可以制造苹果系列的移动产品和三星系列的移动产品。这个工厂下有两个子厂，一个负责制造苹果系列的Pad和三星系列的Pad，另一个负责制造苹果系列的手机和三星系列的手机。这便是一个典型的抽象工厂的实例。抽象产品： 苹果系列 public interface Apple { void AppleStyle(); } 抽象产品： 三星系列 public interface Sumsung { void BangziStyle(); } 具体产品：iphone public class iphone implements Apple { public void AppleStyle() { Console.WriteLine(\"Apple's style: iPhone!\"); } } 具体产品：ipad public class ipad implements Apple { public void AppleStyle() { Console.WriteLine(\"Apple's style: iPad!\"); } } 具体产品：note2 public class note2 implements Sumsung { public void BangziStyle() { Console.WriteLine(\"Bangzi's style : Note2!\"); } } 具体产品：tabs public class Tabs implements Sumsung { public void BangziStyle() { Console.WriteLine(\"Bangzi's style : Tab!\"); } } 抽象工厂 public interface Factory { Apple createAppleProduct(); Sumsung createSumsungProduct(); } 手机工厂 public class Factory_Phone implements Factory { public Apple createAppleProduct() { return new iphone(); } public Sumsung createSumsungProduct() { return new note2(); } } pad工厂 public class Factory_Pad implements Factory { public Apple createAppleProduct() { return new ipad(); } public Sumsung createSumsungProduct() { return new Tabs(); } } 客户端调用 public static void Main(string[] args) { //采购商要一台iPad和一台Tab Factory factory = new Factory_Pad(); Apple apple = factory.createAppleProduct(); apple.AppleStyle(); Sumsung sumsung = factory.createSumsungProduct(); sumsung.BangziStyle(); //采购商又要一台iPhone和一台Note2 factory = new Factory_Phone(); apple = factory.createAppleProduct(); apple.AppleStyle(); sumsung = factory.createSumsungProduct(); sumsung.BangziStyle(); Console.ReadKey(); } 抽象工厂可以通过多态，来动态设置不同的工厂，生产不同的产品，同时每个工厂中的产品又不属于同一个产品等级结构。 四、抽象工厂模式优缺点 优点 ①抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。 ②增加新的具体工厂和产品族很方便，因为一个具体的工厂实现代表的是一个产品族，无须修改已有系统，符合“开闭原则”。 缺点 在添加新的产品对象（不同于现有的产品等级结构）时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。 适用环境 在以下情况下可以使用抽象工厂模式： ①一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 ②系统中有多于一个的产品族，而每次只使用其中某一产品族。与工厂方法模式的区别 ③属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 ④系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Builder-Pattern/Singleton-Pattern.html":{"url":"design-mode/Builder-Pattern/Singleton-Pattern.html","title":"单例模式","keywords":"","body":"一、单例模式 1.定义 作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。 2.特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 二、创建单例模式的方式 ①懒汉式，线程不安全 懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。 public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。 ②懒汉式，线程安全 为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } 虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。 ③双重检验锁 双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 public static Singleton getSingleton() { if (instance == null) { //Single Checked synchronized (Singleton.class) { if (instance == null) { //Double Checked instance = new Singleton(); } } } return instance ; } 这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 1.给 instance 分配内存 2.调用 Singleton 的构造函数来初始化成员变量 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 我们只需要将 instance 变量声明成 volatile 就可以了。 public class Singleton { private volatile static Singleton instance; //声明成 volatile private Singleton (){} public static Singleton getSingleton() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。 从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。 但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。 相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。 ④饿汉式 static final field 饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。 这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 public class Singleton{ //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } 缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。 饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 ⑤静态内部类 static nested class 这种方法也是《Effective Java》上所推荐的。 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 这种写法仍然使用JVM本身机制保证了线程安全问题。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SingletonHolder，在该内部类中定义了一个static类型的变量INSTANCE ，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。 由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 ⑥枚举 Enum 用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。 public enum EasySingleton{ INSTANCE; } 我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。 三、总结 一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，上文中第一种方式线程不安全，排除。 一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）倾向于使用静态内部类。如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Builder-Pattern/Builder-Pattern.html":{"url":"design-mode/Builder-Pattern/Builder-Pattern.html","title":"建造者模式","keywords":"","body":"一、模式定义 造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。 二、模式结构 建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 三、时序图 四、简单实现 电脑的组装过程较为复杂，步骤繁多，但是顺序却是不固定的。下面我们以组装电脑为例来演示一下简单且经典的builder模式 package com.dp.example.builder; /** * Computer产品抽象类, 为了例子简单, 只列出这几个属性 * * @author mrsimple * */ public abstract class Computer { protected int mCpuCore = 1; protected int mRamSize = 0; protected String mOs = \"Dos\"; protected Computer() { } // 设置CPU核心数 public abstract void setCPU(int core); // 设置内存 public abstract void setRAM(int gb); // 设置操作系统 public abstract void setOs(String os); @Override public String toString() { return \"Computer [mCpuCore=\" + mCpuCore + \", mRamSize=\" + mRamSize + \", mOs=\" + mOs + \"]\"; } } package com.dp.example.builder; /** * Apple电脑 */ public class AppleComputer extends Computer { protected AppleComputer() { } @Override public void setCPU(int core) { mCpuCore = core; } @Override public void setRAM(int gb) { mRamSize = gb; } @Override public void setOs(String os) { mOs = os; } } package com.dp.example.builder; package com.dp.example.builder; /** * builder抽象类 * */ public abstract class Builder { // 设置CPU核心数 public abstract void buildCPU(int core); // 设置内存 public abstract void buildRAM(int gb); // 设置操作系统 public abstract void buildOs(String os); // 创建Computer public abstract Computer create(); } package com.dp.example.builder; public class ApplePCBuilder extends Builder { private Computer mApplePc = new AppleComputer(); @Override public void buildCPU(int core) { mApplePc.setCPU(core); } @Override public void buildRAM(int gb) { mApplePc.setRAM(gb); } @Override public void buildOs(String os) { mApplePc.setOs(os); } @Override public Computer create() { return mApplePc; } } package com.dp.example.builder; public class Director { Builder mBuilder = null; /** * * @param builder */ public Director(Builder builder) { mBuilder = builder; } /** * 构建对象 * * @param cpu * @param ram * @param os */ public void construct(int cpu, int ram, String os) { mBuilder.buildCPU(cpu); mBuilder.buildRAM(ram); mBuilder.buildOs(os); } } /** * 经典实现较为繁琐 * * @author mrsimple * */ public class Test { public static void main(String[] args) { // 构建器 Builder builder = new ApplePCBuilder(); // Director Director pcDirector = new Director(builder); // 封装构建过程, 4核, 内存2GB, Mac系统 pcDirector.construct(4, 2, \"Mac OS X 10.9.1\"); // 构建电脑, 输出相关信息 System.out.println(\"Computer Info : \" + builder.create().toString()); } } 五、Android源码中模式实现 在Android源码中，我们最常用到的Builder模式就是AlertDialog.Builder， 使用该Builder来构建复杂的AlertDialog对象。简单示例如下 : //显示基本的AlertDialog private void showDialog(Context context) { AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setIcon(R.drawable.icon); builder.setTitle(\"Title\"); builder.setMessage(\"Message\"); builder.setPositiveButton(\"Button1\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { setTitle(\"点击了对话框上的Button1\"); } }); builder.setNeutralButton(\"Button2\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { setTitle(\"点击了对话框上的Button2\"); } }); builder.setNegativeButton(\"Button3\", new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { setTitle(\"点击了对话框上的Button3\"); } }); builder.create().show(); // 构建AlertDialog， 并且显示 } 结果 : 下面我们看看AlertDialog的相关源码 : // AlertDialog public class AlertDialog extends Dialog implements DialogInterface { // Controller, 接受Builder成员变量P中的各个参数 private AlertController mAlert; // 构造函数 protected AlertDialog(Context context, int theme) { this(context, theme, true); } // 4 : 构造AlertDialog AlertDialog(Context context, int theme, boolean createContextWrapper) { super(context, resolveDialogTheme(context, theme), createContextWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); } // 实际上调用的是mAlert的setTitle方法 @Override public void setTitle(CharSequence title) { super.setTitle(title); mAlert.setTitle(title); } // 实际上调用的是mAlert的setCustomTitle方法 public void setCustomTitle(View customTitleView) { mAlert.setCustomTitle(customTitleView); } public void setMessage(CharSequence message) { mAlert.setMessage(message); } // AlertDialog其他的代码省略 // ************ Builder为AlertDialog的内部类 ******************* public static class Builder { // 1 : 存储AlertDialog的各个参数, 例如title, message, icon等. private final AlertController.AlertParams P; // 属性省略 /** * Constructor using a context for this builder and the {@link AlertDialog} it creates. */ public Builder(Context context) { this(context, resolveDialogTheme(context, 0)); } public Builder(Context context, int theme) { P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, theme))); mTheme = theme; } // Builder的其他代码省略 ...... // 2 : 设置各种参数 public Builder setTitle(CharSequence title) { P.mTitle = title; return this; } public Builder setMessage(CharSequence message) { P.mMessage = message; return this; } public Builder setIcon(int iconId) { P.mIconId = iconId; return this; } public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; } public Builder setView(View view) { P.mView = view; P.mViewSpacingSpecified = false; return this; } // 3 : 构建AlertDialog, 传递参数 public AlertDialog create() { // 调用new AlertDialog构造对象， 并且将参数传递个体AlertDialog final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false); // 5 : 将P中的参数应用的dialog中的mAlert对象中 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } dialog.setOnCancelListener(P.mOnCancelListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } return dialog; } } } 可以看到，通过Builder来设置AlertDialog中的title, message, button等参数， 这些参数都存储在类型为AlertController.AlertParams的成员变量P中，AlertController.AlertParams中包含了与之对应的成员变量。在调用Builder类的create函数时才创建AlertDialog, 并且将Builder成员变量P中保存的参数应用到AlertDialog的mAlert对象中，即P.apply(dialog.mAlert)代码段。我们看看apply函数的实现 : public void apply(AlertController dialog) { if (mCustomTitleView != null) { dialog.setCustomTitle(mCustomTitleView); } else { if (mTitle != null) { dialog.setTitle(mTitle); } if (mIcon != null) { dialog.setIcon(mIcon); } if (mIconId >= 0) { dialog.setIcon(mIconId); } if (mIconAttrId > 0) { dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId)); } } if (mMessage != null) { dialog.setMessage(mMessage); } if (mPositiveButtonText != null) { dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText, mPositiveButtonListener, null); } if (mNegativeButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText, mNegativeButtonListener, null); } if (mNeutralButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText, mNeutralButtonListener, null); } if (mForceInverseBackground) { dialog.setInverseBackgroundForced(true); } // For a list, the client can either supply an array of items or an // adapter or a cursor if ((mItems != null) || (mCursor != null) || (mAdapter != null)) { createListView(dialog); } if (mView != null) { if (mViewSpacingSpecified) { dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight, mViewSpacingBottom); } else { dialog.setView(mView); } } } 实际上就是把P中的参数挨个的设置到AlertController中， 也就是AlertDialog中的mAlert对象。从AlertDialog的各个setter方法中我们也可以看到，实际上也都是调用了mAlert对应的setter方法。在这里，Builder同时扮演了上文中提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。 六、优缺点 优点 良好的封装性， 使用建造者模式可以使客户端不必知道产品内部组成的细节； 建造者独立，容易扩展； 在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。 缺点 会产生多余的Builder对象以及Director对象，消耗内存； 对象的构建过程暴露。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Structural-Patterns.html":{"url":"design-mode/Structural-Patterns.html","title":"结构型模式","keywords":"","body":"一、前言 结构型模式 结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。 结构型模式可以分为类结构型模式和对象结构型模式： 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。 对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。 包含模式 适配器模式(Adapter) 桥接模式(Bridge) 组合模式(Composite) 装饰模式(Decorator) 外观模式(Facade) 享元模式(Flyweight) 代理模式(Proxy) 二、目录 本部分没有包含以上所有模式，仅介绍了几种常用的。 适配器模式 外观模式 装饰者模式 代理模式 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Structural-Patterns/Adapter-Pattern.html":{"url":"design-mode/Structural-Patterns/Adapter-Pattern.html","title":"适配器模式","keywords":"","body":"一、适配器模式简介 1.定义 适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 2.定义阐述 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。 例如：　用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。 二、适配器模式结构 适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。 类适配器模式 类的适配器模式把适配的类的API转换成为目标类的API。 在上图中可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的： 模式所涉及的角色有： ●　　目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。 ●　　源(Adapee)角色：现在需要适配的接口。 ●　　适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。 public interface Target { /** * 这是源类Adaptee也有的方法 */ public void sampleOperation1(); /** * 这是源类Adapteee没有的方法 */ public void sampleOperation2(); } 上面给出的是目标角色的源代码，这个角色是以一个JAVA接口的形式实现的。可以看出，这个接口声明了两个方法：sampleOperation1()和sampleOperation2()。而源角色Adaptee是一个具体类，它有一个sampleOperation1()方法，但是没有sampleOperation2()方法。 public class Adaptee { public void sampleOperation1(){} } 适配器角色Adapter扩展了Adaptee,同时又实现了目标(Target)接口。由于Adaptee没有提供sampleOperation2()方法，而目标接口又要求这个方法，因此适配器角色Adapter实现了这个方法。 public class Adapter extends Adaptee implements Target { /** * 由于源类Adaptee没有方法sampleOperation2() * 因此适配器补充上这个方法 */ @Override public void sampleOperation2() { //写相关的代码 } } 对象适配器模式 与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。 从上图可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。 public interface Target { /** * 这是源类Adaptee也有的方法 */ public void sampleOperation1(); /** * 这是源类Adapteee没有的方法 */ public void sampleOperation2(); } public class Adaptee { public void sampleOperation1(){} } public class Adapter { private Adaptee adaptee; public Adapter(Adaptee adaptee){ this.adaptee = adaptee; } /** * 源类Adaptee有方法sampleOperation1 * 因此适配器类直接委派即可 */ public void sampleOperation1(){ this.adaptee.sampleOperation1(); } /** * 源类Adaptee没有方法sampleOperation2 * 因此由适配器类需要补充此方法 */ public void sampleOperation2(){ //写相关的代码 } } 时序图 三、类适配器和对象适配器的权衡 ●　　类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。 ●　　对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。 ●　　对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。 ●　 对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。 ●　 对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 ●　　对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。 ●　　对于对象适配器，需要额外的引用来间接得到Adaptee。 建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。 四、缺省适配器 缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。 五、Java中适配器模式的使用 JDK1.1 之前提供的容器有 Arrays,Vector,Stack,Hashtable,Properties,BitSet，其中定义了一种访问群集内各元素的标准方式，称为 Enumeration（列举器）接口。 Vector v=new Vector(); for (Enumeration enum =v.elements(); enum.hasMoreElements();) { Object o = enum.nextElement(); processObject(o); } JDK1.2 版本中引入了 Iterator 接口，新版本的集合对（HashSet,HashMap,WeakHeahMap,ArrayList,TreeSet,TreeMap, LinkedList）是通过 Iterator 接口访问集合元素。 List list=new ArrayList(); for(Iterator it=list.iterator();it.hasNext();){ System.out.println(it.next()); } 这样，如果将老版本的程序运行在新的 Java 编译器上就会出错。因为 List 接口中已经没有 elements()，而只有 iterator() 了。那么如何将老版本的程序运行在新的 Java 编译器上呢? 如果不加修改，是肯定不行的，但是修改要遵循“开－闭”原则。我们可以用 Java 设计模式中的适配器模式解决这个问题。 public class NewEnumeration implements Enumeration { Iterator it; public NewEnumeration(Iterator it) { this.it = it; } public boolean hasMoreElements() { return it.hasNext(); } public Object nextElement() { return it.next(); } public static void main(String[] args) { List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"C\"); for (Enumeration e = new NewEnumeration(list.iterator()); e.hasMoreElements(); ) { System.out.println(e.nextElement()); } } } NewEnumeration 是一个适配器类，通过它实现了从 Iterator 接口到 Enumeration 接口的适配，这样我们就可以使用老版本的代码来使用新的集合对象了。 六、Android中适配器模式的使用 在开发过程中,ListView的Adapter是我们最为常见的类型之一。一般的用法大致如下: // 代码省略 ListView myListView = (ListView) findViewById(listview_id); // 设置适配器 myListView.setAdapter(new MyAdapter(context,myDatas)); // 适配器 public class MyAdapter extends BaseAdapter { private LayoutInflater mInflater; List mDatas; public MyAdapter(Context context, List datas) { this.mInflater = LayoutInflater.from(context); mDatas = datas; } @Override public int getCount() { return mDatas.size(); } @Override public String getItem(int pos) { return mDatas.get(pos); } @Override public long getItemId(int pos) { return pos; } // 解析、设置、缓存convertView以及相关内容 @Override public View getView(int position, View convertView, ViewGroup parent) { ViewHolder holder = null; // Item View的复用 if (convertView == null) { holder = new ViewHolder(); convertView = mInflater.inflate(R.layout.my_listview_item, null); // 获取title holder.title = (TextView) convertView.findViewById(R.id.title); convertView.setTag(holder); } else { holder = (ViewHolder) convertView.getTag(); } holder.title.setText(mDatas.get(position)); return convertView; } } 我们知道，作为最重要的View，ListView需要能够显示各式各样的视图，每个人需要的显示效果各不相同，显示的数据类型、数量等也千变万化。那么如何隔离这种变化尤为重要。 Android的做法是增加一个Adapter层来应对变化，将ListView需要的接口抽象到Adapter对象中，这样只要用户实现了Adapter的接口，ListView就可以按照用户设定的显示效果、数量、数据来显示特定的Item View。 通过代理数据集来告知ListView数据的个数( getCount函数 )以及每个数据的类型( getItem函数 )，最重要的是要解决Item View的输出。Item View千变万化，但终究它都是View类型，Adapter统一将Item View输出为View ( getView函数 )，这样就很好的应对了Item View的可变性。 那么ListView是如何通过Adapter模式 ( 不止Adapter模式 )来运作的呢 ？我们一起来看一看。ListView继承自AbsListView，Adapter定义在AbsListView中，我们看一看这个类。 public abstract class AbsListView extends AdapterView implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback { ListAdapter mAdapter; // 关联到Window时调用的函数 @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); // 代码省略 // 给适配器注册一个观察者。 if (mAdapter != null&& mDataSetObserver == null){ mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); // Data may have changed while we were detached. Refresh. mDataChanged = true; mOldItemCount = mItemCount // 获取Item的数量,调用的是mAdapter的getCount方法 mItemCount = mAdapter.getCount(); } mIsAttached = true; } /** * 子类需要覆写layoutChildren()函数来布局child view,也就是Item View */ @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { super.onLayout(changed, l, t, r, b); mInLayout = true; if (changed) { int childCount = getChildCount(); for (int i = 0; i 通过增加Adapter一层来将Item View的操作抽象起来，ListView等集合视图通过Adapter对象获得Item的个数、数据元素、Item View等，从而达到适配各种数据、各种Item视图的效果。 因为Item View和数据类型千变万化，Android的架构师们将这些变化的部分交给用户来处理，通过getCount、getItem、getView等几个方法抽象出来，也就是将Item View的构造过程交给用户来处理，灵活地运用了适配器模式，达到了无限适配、拥抱变化的目的。 七、适配器模式的优缺点 适配器模式的优点 更好的复用性 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 更好的扩展性 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。 适配器模式的缺点 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Structural-Patterns/Facade-Pattern.html":{"url":"design-mode/Structural-Patterns/Facade-Pattern.html","title":"外观模式","keywords":"","body":"一、外观模式概述 1.定义 外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 2.定义阐述 医院的例子 现代的软件系统都是比较复杂的，设计师处理复杂系统的一个常见方法便是将其“分而治之”，把一个系统划分为几个较小的子系统。如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。 首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验。化验后再回到门诊室。 上图描述的是病人在医院里的体验，图中的方框代表医院。 解决这种不便的方法便是引进外观模式，医院可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是外观模式的体现，病人只接触接待员，由接待员与各个部门打交道。 二、外观模式结构 外观模式没有一个一般化的类图描述，最好的描述方法实际上就是以一个例子说明。 由于门面模式的结构图过于抽象，因此把它稍稍具体点。假设子系统内有三个模块，分别是ModuleA、ModuleB和ModuleC，它们分别有一个示例方法，那么此时示例的整体结构图如下： 在这个对象图中，出现了两个角色：●　　外观(Facade)角色 ：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。 ●　　子系统(SubSystem)角色 ：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。 时序图 子系统角色中的类： public class ModuleA { //示意方法 public void testA(){ System.out.println(\"调用ModuleA中的testA方法\"); } } public class ModuleB { //示意方法 public void testB(){ System.out.println(\"调用ModuleB中的testB方法\"); } } public class ModuleC { //示意方法 public void testC(){ System.out.println(\"调用ModuleC中的testC方法\"); } } 外观角色类: public class Facade { //示意方法，满足客户端需要的功能 public void test(){ ModuleA a = new ModuleA(); a.testA(); ModuleB b = new ModuleB(); b.testB(); ModuleC c = new ModuleC(); c.testC(); } } 客户端角色类： public class Client { public static void main(String[] args) { Facade facade = new Facade(); facade.test(); } } Facade类其实相当于A、B、C模块的外观界面，有了这个Facade类，那么客户端就不需要亲自调用子系统中的A、B、C模块了，也不需要知道系统内部的实现细节，甚至都不需要知道A、B、C模块的存在，客户端只需要跟Facade类交互就好了，从而更好地实现了客户端和子系统中A、B、C模块的解耦，让客户端更容易地使用系统。 三、外观模式的扩展 使用外观模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。 比如，定义如下A、B、C模块。 public class Module { /** * 提供给子系统外部使用的方法 */ public void a1(){}; /** * 子系统内部模块之间相互调用时使用的方法 */ public void a2(){}; public void a3(){}; } public class ModuleB { /** * 提供给子系统外部使用的方法 */ public void b1(){}; /** * 子系统内部模块之间相互调用时使用的方法 */ public void b2(){}; public void b3(){}; } public class ModuleC { /** * 提供给子系统外部使用的方法 */ public void c1(){}; /** * 子系统内部模块之间相互调用时使用的方法 */ public void c2(){}; public void c3(){}; } public class ModuleFacade { ModuleA a = new ModuleA(); ModuleB b = new ModuleB(); ModuleC c = new ModuleC(); /** * 下面这些是A、B、C模块对子系统外部提供的方法 */ public void a1(){ a.a1(); } public void b1(){ b.b1(); } public void c1(){ c.c1(); } } 这样定义一个ModuleFacade类可以有效地屏蔽内部的细节，免得客户端去调用Module类时，发现一些不需要它知道的方法。比如a2()和a3()方法就不需要让客户端知道，否则既暴露了内部的细节，又让客户端迷惑。 一个系统可以有几个外观类 在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个外观类，而仅仅是说对每一个子系统只有一个外观类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个外观类，整个系统可以有数个外观类。 为子系统增加新行为 初学者往往以为通过继承一个外观类便可在子系统中加入新的行为，这是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。 四、外观模式的实例 1.实例说明 某软件公司欲开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括三个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这三个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这三个操作的业务代码封装在三个不同的类中。 2.实例类图 EncryptFacade充当外观类，FileReader、CipherMachine和FileWriter充当子系统类。 3.实例代码 FileReader：文件读取类，充当子系统类。 class FileReader { public string Read(string fileNameSrc) { Console.Write(\"读取文件，获取明文：\"); FileStream fs = null; StringBuilder sb = new StringBuilder(); try { fs = new FileStream(fileNameSrc, FileMode.Open); int data; while((data = fs.ReadByte())!= -1) { sb = sb.Append((char)data); } fs.Close(); Console.WriteLine(sb.ToString()); } catch(FileNotFoundException e) { Console.WriteLine(\"文件不存在！\"); } catch(IOException e) { Console.WriteLine(\"文件操作错误！\"); } return sb.ToString(); } } CipherMachine：数据加密类，充当子系统类。 class CipherMachine { public string Encrypt(string plainText) { Console.Write(\"数据加密，将明文转换为密文：\"); string es = \"\"; char[] chars = plainText.ToCharArray(); foreach(char ch in chars) { string c = (ch % 7).ToString(); es += c; } Console.WriteLine(es); return es; } } FileWriter：文件保存类，充当子系统类。 class FileWriter { public void Write(string encryptStr,string fileNameDes) { Console.WriteLine(\"保存密文，写入文件。\"); FileStream fs = null; try { fs = new FileStream(fileNameDes, FileMode.Create); byte[] str = Encoding.Default.GetBytes(encryptStr); fs.Write(str,0,str.Length); fs.Flush(); fs.Close(); } catch(FileNotFoundException e) { Console.WriteLine(\"文件不存在！\"); } catch(IOException e) { Console.WriteLine(e.Message); Console.WriteLine(\"文件操作错误！\"); } } } EncryptFacade：加密外观类，充当外观类。 class EncryptFacade { //维持对其他对象的引用 private FileReader reader; private CipherMachine cipher; private FileWriter writer; public EncryptFacade() { reader = new FileReader(); cipher = new CipherMachine(); writer = new FileWriter(); } //调用其他对象的业务方法 public void FileEncrypt(string fileNameSrc, string fileNameDes) { string plainStr = reader.Read(fileNameSrc); string encryptStr = cipher.Encrypt(plainStr); writer.Write(encryptStr, fileNameDes); } } Program：客户端测试类 class Program { static void Main(string[] args) { EncryptFacade ef = new EncryptFacade(); ef.FileEncrypt(\"src.txt\", \"des.txt\"); Console.Read(); } } 五、外观模式的优点 ●　　松散耦合 外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。 ●　　简单易用 外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观类交互就可以了。 ●　　更好的划分访问层次 通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到外观中，这样既方便客户端使用，也很好地隐藏了内部的细节。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Structural-Patterns/Decorator-Pattern.html":{"url":"design-mode/Structural-Patterns/Decorator-Pattern.html","title":"装饰者模式","keywords":"","body":"一、装饰者模式的概念 装饰者模式又名包装(Wrapper)模式。装饰者模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 装饰者模式动态地将责任附加到对象身上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 二、装饰者模式的结构 装饰者模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰者模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。 　　装饰者模式的类图如下： 　在装饰模式中的角色有： 　　●　　抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。 　　●　　具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。 　　●　　装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 　　●　　具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。抽象构件角色 public interface Component { public void sampleOperation(); } 具体构件角色 public class ConcreteComponent implements Component { @Override public void sampleOperation() { // 写相关的业务代码 } } 装饰角色 public class Decorator implements Component{ private Component component; public Decorator(Component component){ this.component = component; } @Override public void sampleOperation() { // 委派给构件 component.sampleOperation(); } } 具体装饰角色 public class ConcreteDecoratorA extends Decorator { public ConcreteDecoratorA(Component component) { super(component); } @Override public void sampleOperation() { // 写相关的业务代码 　　　super.sampleOperation(); // 写相关的业务代码 } } 三、装饰者模式实例演示 齐天大圣的例子孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。 本例中，Component的角色便由鼎鼎大名的齐天大圣扮演；ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；Decorator的角色由大圣的七十二变扮演。而ConcreteDecorator的角色便是鱼儿、鸟儿等七十二般变化。 抽象构件角色“齐天大圣”接口定义了一个move()方法，这是所有的具体构件类和装饰类必须实现的。 //大圣的尊号 public interface TheGreatestSage { public void move(); } 具体构件角色“大圣本尊”猢狲类 public class Monkey implements TheGreatestSage { @Override public void move() { //代码 System.out.println(\"Monkey Move\"); } } 抽象装饰角色“七十二变” public class Change implements TheGreatestSage { private TheGreatestSage sage; public Change(TheGreatestSage sage){ this.sage = sage; } @Override public void move() { // 代码 sage.move(); } } 具体装饰角色“鱼儿” public class Fish extends Change { public Fish(TheGreatestSage sage) { super(sage); } @Override public void move() { // 代码 System.out.println(\"Fish Move\"); } } 具体装饰角色“鸟儿” public class Bird extends Change { public Bird(TheGreatestSage sage) { super(sage); } @Override public void move() { // 代码 System.out.println(\"Bird Move\"); } } 客户端调用 public class Client { public static void main(String[] args) { TheGreatestSage sage = new Monkey(); // 第一种写法 单层装饰 TheGreatestSage bird = new Bird(sage); TheGreatestSage fish = new Fish(bird); // 第二种写法 双层装饰 //TheGreatestSage fish = new Fish(new Bird(sage)); fish.move(); } } “大圣本尊”是ConcreteComponent类，而“鸟儿”、“鱼儿”是装饰类。要装饰的是“大圣本尊”，也即“猢狲”实例。 上面的例子中，第二种些方法：系统把大圣从一只猢狲装饰成了一只鸟儿（把鸟儿的功能加到了猢狲身上），然后又把鸟儿装饰成了一条鱼儿（把鱼儿的功能加到了猢狲+鸟儿身上，得到了猢狲+鸟儿+鱼儿）。 如上图所示，大圣的变化首先将鸟儿的功能附加到了猢狲身上，然后又将鱼儿的功能附加到猢狲+鸟儿身上。 四、装饰者模式的一些变化 1.装饰者模式的简化 大多数情况下，装饰者模式的实现都要比上面给出的示意性例子要简单。 如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。如下图所示： 如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。如下图所示： 2.透明性的要求 装饰者模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。 用孙悟空的例子来说，必须永远把孙悟空的所有变化都当成孙悟空来对待，而如果把老孙变成的鱼儿当成鱼儿，而不是老孙，那就被老孙骗了，而这时不应当发生的。下面的做法是对的： TheGreatestSage sage = new Monkey(); TheGreatestSage bird = new Bird(sage); 而下面的做法是不对的： Monkey sage = new Monkey(); Bird bird = new Bird(sage); 3.半透明的装饰者模式 然而，纯粹的装饰者模式很难找到。装饰者模式的用意是在不改变接口的前提下，增强所考虑的类的性能。在增强性能的时候，往往需要建立新的公开的方法。即便是在孙大圣的系统里，也需要新的方法。比如齐天大圣类并没有飞行的能力，而鸟儿有。这就意味着鸟儿应当有一个新的fly()方法。再比如，齐天大圣类并没有游泳的能力，而鱼儿有，这就意味着在鱼儿类里应当有一个新的swim()方法。 这就导致了大多数的装饰者模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰者模式改变接口，增加新的方法。这意味着客户端可以声明ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator类中才有的方法： TheGreatestSage sage = new Monkey(); Bird bird = new Bird(sage); bird.fly(); 半透明的装饰者模式是介于装饰者模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数的装饰者模式实际上是半透明的装饰者模式，这样的装饰者模式也称做半装饰、半适配器模式。 五、装饰者模式的优缺点 装饰模式的优点 　　（1）装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。 　　（2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 装饰模式的缺点 　　由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。 六、装饰者模式在Java IO流中的应用 装饰者模式在Java语言中的最著名的应用莫过于Java I/O标准库的设计了。 由于Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。而如果采用装饰者模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰者模式是Java I/O库的基本模式。 Java I/O库的对象结构图如下，由于Java I/O的对象众多，因此只画出InputStream的部分。 根据上图可以看出： 　　●　　抽象构件(Component)角色：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。 　　●　　具体构件(ConcreteComponent)角色：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。 　　●　　抽象装饰(Decorator)角色：由FilterInputStream扮演。它实现了InputStream所规定的接口。 　　●　　具体装饰(ConcreteDecorator)角色：由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。 半透明的装饰者模式 装饰者模式和适配器模式都是“包装模式(Wrapper Pattern)”，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。 理想的装饰者模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。而适配器模式则不然，一般而言，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。 装饰者模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。透明的装饰者模式也就是理想的装饰者模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。相反，如果装饰角色的接口与抽象构件角色接口不一致，也就是说装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，这种装饰者模式也是可以接受的，称为“半透明”的装饰模式，如下图所示。 在适配器模式里面，适配器类的接口通常会与目标类的接口重叠，但往往并不完全相同。换言之，适配器类的接口会比被装饰的目标类接口宽。 显然，半透明的装饰者模式实际上就是处于适配器模式与装饰者模式之间的灰色地带。如果将装饰者模式与适配器模式合并成为一个“包装模式”的话，那么半透明的装饰者模式倒可以成为这种合并后的“包装模式”的代表。 InputStream类型中的装饰者模式 InputStream类型中的装饰者模式是半透明的。为了说明这一点，不妨看一看作装饰者模式的抽象构件角色的InputStream的源代码。这个抽象类声明了九个方法，并给出了其中八个的实现，另外一个是抽象方法，需要由子类实现。 public abstract class InputStream implements Closeable { public abstract int read() throws IOException; public int read(byte b[]) throws IOException {} public int read(byte b[], int off, int len) throws IOException {} public long skip(long n) throws IOException {} public int available() throws IOException {} public void close() throws IOException {} public synchronized void mark(int readlimit) {} public synchronized void reset() throws IOException {} public boolean markSupported() {} } 下面是作为装饰模式的抽象装饰角色FilterInputStream类的源代码。可以看出，FilterInputStream的接口与InputStream的接口是完全一致的。也就是说，直到这一步，还是与装饰模式相符合的。 public class FilterInputStream extends InputStream { protected FilterInputStream(InputStream in) {} public int read() throws IOException {} public int read(byte b[]) throws IOException {} public int read(byte b[], int off, int len) throws IOException {} public long skip(long n) throws IOException {} public int available() throws IOException {} public void close() throws IOException {} public synchronized void mark(int readlimit) {} public synchronized void reset() throws IOException {} public boolean markSupported() {} } 下面是具体装饰角色PushbackInputStream的源代码。 public class PushbackInputStream extends FilterInputStream { private void ensureOpen() throws IOException {} public PushbackInputStream(InputStream in, int size) {} public PushbackInputStream(InputStream in) {} public int read() throws IOException {} public int read(byte[] b, int off, int len) throws IOException {} public void unread(int b) throws IOException {} public void unread(byte[] b, int off, int len) throws IOException {} public void unread(byte[] b) throws IOException {} public int available() throws IOException {} public long skip(long n) throws IOException {} public boolean markSupported() {} public synchronized void mark(int readlimit) {} public synchronized void reset() throws IOException {} public synchronized void close() throws IOException {} } 查看源码，你会发现，这个装饰类提供了额外的方法unread()，这就意味着PushbackInputStream是一个半透明的装饰类。换言 之，它破坏了理想的装饰者模式的要求。如果客户端持有一个类型为InputStream对象的引用in的话，那么如果in的真实类型是 PushbackInputStream的话，只要客户端不需要使用unread()方法，那么客户端一般没有问题。但是如果客户端必须使用这个方法，就 必须进行向下类型转换。将in的类型转换成为PushbackInputStream之后才可能调用这个方法。但是，这个类型转换意味着客户端必须知道它 拿到的引用是指向一个类型为PushbackInputStream的对象。这就破坏了使用装饰者模式的原始用意。 现实世界与理论总归是有一段差距的。纯粹的装饰者模式在真实的系统中很难找到。一般所遇到的，都是这种半透明的装饰者模式。 下面是使用I/O流读取文件内容的简单操作示例。 public class IOTest { public static void main(String[] args) throws IOException { // 流式读取文件 DataInputStream dis = null; try{ dis = new DataInputStream( new BufferedInputStream( new FileInputStream(\"test.txt\") ) ); //读取文件内容 byte[] bs = new byte[dis.available()]; dis.read(bs); String content = new String(bs); System.out.println(content); }finally{ dis.close(); } } } 观察上面的代码，会发现最里层是一个FileInputStream对象，然后把它传递给一个BufferedInputStream对象，经过BufferedInputStream处理，再把处理后的对象传递给了DataInputStream对象进行处理，这个过程其实就是装饰器的组装过程，FileInputStream对象相当于原始的被装饰的对象，而BufferedInputStream对象和DataInputStream对象则相当于装饰器。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Structural-Patterns/Proxy-Pattern.html":{"url":"design-mode/Structural-Patterns/Proxy-Pattern.html","title":"代理模式","keywords":"","body":"一、模式定义 代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。 二、模式结构 代理模式包含如下角色： Subject: 抽象主题角色 Proxy: 代理主题角色 RealSubject: 真实主题角色 三、时序图 四、模式的简单实现 抽象对象角色 public abstract class AbstractObject { //操作 public abstract void operation(); } 目标对象角色 public class RealObject extends AbstractObject { @Override public void operation() { //一些操作 System.out.println(\"一些操作\"); } } 代理对象角色 public class ProxyObject extends AbstractObject{ RealObject realObject = new RealObject(); @Override public void operation() { //调用目标对象之前可以做相关操作 System.out.println(\"before\"); realObject.operation(); //调用目标对象之后可以做相关操作 System.out.println(\"after\"); } } 客户端 public class Client { public static void main(String[] args) { AbstractObject obj = new ProxyObject(); obj.operation(); } } 五、代理模式在Binder中的使用 直观来说，Binder是Android中的一个类，它继承了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，etc）和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。 Binder一个很重要的作用是：将客户端的请求参数通过Parcel包装后传到远程服务端，远程服务端解析数据并执行对应的操作，同时客户端线程挂起，当服务端方法执行完毕后，再将返回结果写入到另外一个Parcel中并将其通过Binder传回到客户端，客户端接收到返回数据的Parcel后，Binder会解析数据包中的内容并将原始结果返回给客户端，至此，整个Binder的工作过程就完成了。由此可见，Binder更像一个数据通道，Parcel对象就在这个通道中跨进程传输，至于双方如何通信，这并不负责，只需要双方按照约定好的规范去打包和解包数据即可。 为了更好地说明Binder，这里我们先手动实现了一个Binder。为了使得逻辑更清晰，这里简化一下，我们来模拟一个银行系统，这个银行提供的功能只有一个：即查询余额，只有传递一个int的id过来，银行就会将你的余额设置为id*10，满足下大家的发财梦。 先定义一个Binder接口 package com.ryg.design.manualbinder; import android.os.IBinder; import android.os.IInterface; import android.os.RemoteException; public interface IBank extends IInterface { static final String DESCRIPTOR = \"com.ryg.design.manualbinder.IBank\"; static final int TRANSACTION_queryMoney = (IBinder.FIRST_CALL_TRANSACTION + 0); public long queryMoney(int uid) throws RemoteException; } 2.创建一个Binder并实现这个上述接口 package com.ryg.design.manualbinder; import android.os.Binder; import android.os.IBinder; import android.os.Parcel; import android.os.RemoteException; public class BankImpl extends Binder implements IBank { public BankImpl() { this.attachInterface(this, DESCRIPTOR); } public static IBank asInterface(IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) && (iin instanceof IBank))) { return ((IBank) iin); } return new BankImpl.Proxy(obj); } @Override public IBinder asBinder() { return this; } @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException { switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(DESCRIPTOR); return true; } case TRANSACTION_queryMoney: { data.enforceInterface(DESCRIPTOR); int uid = data.readInt(); long result = this.queryMoney(uid); reply.writeNoException(); reply.writeLong(result); return true; } } return super.onTransact(code, data, reply, flags); } @Override public long queryMoney(int uid) throws RemoteException { return uid * 10l; } private static class Proxy implements IBank { private IBinder mRemote; Proxy(IBinder remote) { mRemote = remote; } @Override public IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } @Override public long queryMoney(int uid) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); long result; try { data.writeInterfaceToken(DESCRIPTOR); data.writeInt(uid); mRemote.transact(TRANSACTION_queryMoney, data, reply, 0); reply.readException(); result = reply.readLong(); } finally { reply.recycle(); data.recycle(); } return result; } } } ok，到此为止，我们的Binder就完成了，这里只要创建服务端和客户端，二者就能通过我们的Binder来通信了。这里就不做这个示例了，我们的目的是分析代理模式在Binder中的使用。 我们看上述Binder的实现中，有一个叫做“Proxy”的类，它的构造方法如下： Proxy(IBinder remote) { mRemote = remote; } Proxy类接收一个IBinder参数，这个参数实际上就是服务端Service中的onBind方法返回的Binder对象在客户端重新打包后的结果，因为客户端无法直接通过这个打包的Binder和服务端通信，因此客户端必须借助Proxy类来和服务端通信，这里Proxy的作用就是代理的作用，客户端所有的请求全部通过Proxy来代理，具体工作流程为：Proxy接收到客户端的请求后，会将客户端的请求参数打包到Parcel对象中，然后将Parcel对象通过它内部持有的Ibinder对象传送到服务端，服务端接收数据、执行方法后返回结果给客户端的Proxy，Proxy解析数据后返回给客户端的真正调用者。很显然，上述所分析的就是典型的代理模式。至于Binder如何传输数据，这涉及到很底层的知识，这个很难搞懂，但是数据传输的核心思想是共享内存。 六、优缺点 优点 给对象增加了本地化的扩展性，增加了存取操作控制 缺点 会产生多余的代理类 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Behavioral-Pattern.html":{"url":"design-mode/Behavioral-Pattern.html","title":"行为型模式","keywords":"","body":"一、前言 行为型模式 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 行为型模式分为类行为型模式和对象行为型模式两种： 类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。 包含模式 职责链模式(Chain of Responsibility) 命令模式(Command) 解释器模式(Interpreter) 迭代器模式(Iterator) 中介者模式(Mediator) 备忘录模式(Memento) 观察者模式(Observer) 状态模式(State) 策略模式(Strategy) 模板方法模式(Template Method) 访问者模式(Visitor) 二、目录 本部分没有包含以上所有模式，仅介绍了几种常用的。 命令模式 迭代器模式 观察者模式 策略模式 模板方法模式 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Behavioral-Pattern/Command-Pattern.html":{"url":"design-mode/Behavioral-Pattern/Command-Pattern.html","title":"命令模式","keywords":"","body":"一、命令模式的概念 命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。 命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，具有请求排队或者记录请求日志，提供命令的撤销和恢复的功能。 命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 二、命令模式的结构 命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。 每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 下面以一个示意性的系统，说明命令模式的结构。 命令模式涉及到五个角色，它们分别是： ●　　客户端(Client)角色：创建请求者，接收者以及命令对象，执行具体逻辑。 ●　　命令(Command)角色：声明了一个给所有具体命令类的抽象接口。 ●　　具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。 ●　　请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。 ●　　接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。 时序图 接收者角色类 public class Receiver { /** * 真正执行命令相应的操作 */ public void action(){ System.out.println(\"执行操作\"); } } 抽象命令角色类 public interface Command { /** * 执行方法 */ void execute(); } 具体命令角色类 public class ConcreteCommand implements Command { //持有相应的接收者对象 private Receiver receiver = null; /** * 构造方法 */ public ConcreteCommand(Receiver receiver){ this.receiver = receiver; } @Override public void execute() { //通常会转调接收者对象的相应方法，让接收者来真正执行功能 receiver.action(); } } 请求者角色类 public class Invoker { /** * 持有命令对象 */ private Command command = null; /** * 构造方法 */ public Invoker(Command command){ this.command = command; } /** * 行动方法 */ public void action(){ command.execute(); } } 客户端角色类 public class Client { public static void main(String[] args) { //创建接收者 Receiver receiver = new Receiver(); //创建命令对象，设定它的接收者 Command command = new ConcreteCommand(receiver); //创建请求者，把命令对象设置进去 Invoker invoker = new Invoker(command); //执行方法 invoker.action(); } } 三、命令模式的具体实例 AudioPlayer系统 小女孩茱丽(Julia)有一个盒式录音机，此录音机有播音(Play)、倒带(Rewind)和停止(Stop)功能，录音机的键盘便是请求者(Invoker)角色；茱丽(Julia)是客户端角色，而录音机便是接收者角色。Command类扮演抽象命令角色，而PlayCommand、StopCommand和RewindCommand便是具体命令类。茱丽(Julia)不需要知道播音(play)、倒带(rewind)和停止(stop)功能是怎么具体执行的，这些命令执行的细节全都由键盘(Keypad)具体实施。茱丽(Julia)只需要在键盘上按下相应的键便可以了。 录音机是典型的命令模式。录音机按键把客户端与录音机的操作细节分割开来。 接收者角色，由录音机类扮演 public class AudioPlayer { public void play(){ System.out.println(\"播放...\"); } public void rewind(){ System.out.println(\"倒带...\"); } public void stop(){ System.out.println(\"停止...\"); } } 抽象命令角色类 public interface Command { /** * 执行方法 */ public void execute(); } 具体命令角色类 public class PlayCommand implements Command { private AudioPlayer myAudio; public PlayCommand(AudioPlayer audioPlayer){ myAudio = audioPlayer; } /** * 执行方法 */ @Override public void execute() { myAudio.play(); } } public class RewindCommand implements Command { private AudioPlayer myAudio; public RewindCommand(AudioPlayer audioPlayer){ myAudio = audioPlayer; } @Override public void execute() { myAudio.rewind(); } } public class StopCommand implements Command { private AudioPlayer myAudio; public StopCommand(AudioPlayer audioPlayer){ myAudio = audioPlayer; } @Override public void execute() { myAudio.stop(); } } 请求者角色，由键盘类扮演 public class Keypad { private Command playCommand; private Command rewindCommand; private Command stopCommand; public void setPlayCommand(Command playCommand) { this.playCommand = playCommand; } public void setRewindCommand(Command rewindCommand) { this.rewindCommand = rewindCommand; } public void setStopCommand(Command stopCommand) { this.stopCommand = stopCommand; } /** * 执行播放方法 */ public void play(){ playCommand.execute(); } /** * 执行倒带方法 */ public void rewind(){ rewindCommand.execute(); } /** * 执行播放方法 */ public void stop(){ stopCommand.execute(); } } 客户端角色，由茱丽小女孩扮演 public class Julia { public static void main(String[]args){ //创建接收者对象 AudioPlayer audioPlayer = new AudioPlayer(); //创建命令对象 Command playCommand = new PlayCommand(audioPlayer); Command rewindCommand = new RewindCommand(audioPlayer); Command stopCommand = new StopCommand(audioPlayer); //创建请求者对象 Keypad keypad = new Keypad(); keypad.setPlayCommand(playCommand); keypad.setRewindCommand(rewindCommand); keypad.setStopCommand(stopCommand); //测试 keypad.play(); keypad.rewind(); keypad.stop(); keypad.play(); keypad.stop(); } } 运行结果： 四、宏命令 宏命令所谓宏命令简单点说就是包含多个命令的命令，是一个命令的组合。 设想茱丽的录音机有一个记录功能，可以把一个一个的命令记录下来，再在任何需要的时候重新把这些记录下来的命令一次性执行，这就是所谓的宏命令集功能。因此，茱丽的录音机系统现在有四个键，分别为播音、倒带、停止和宏命令功能。此时系统的设计与前面的设计相比有所增强，主要体现在Julia类现在有了一个新方法，用以操作宏命令键。 系统需要一个代表宏命令的接口，以定义出具体宏命令所需要的接口。 public interface MacroCommand extends Command { /** * 宏命令聚集的管理方法 * 可以添加一个成员命令 */ public void add(Command cmd); /** * 宏命令聚集的管理方法 * 可以删除一个成员命令 */ public void remove(Command cmd); } 具体的宏命令MacroAudioCommand类负责把个别的命令合成宏命令。 public class MacroAudioCommand implements MacroCommand { private List commandList = new ArrayList (); /** * 宏命令聚集管理方法 */ @Override public void add(Command cmd) { commandList.add(cmd); } /** * 宏命令聚集管理方法 */ @Override public void remove(Command cmd) { commandList.remove(cmd); } /** * 执行方法 */ @Override public void execute() { for(Command cmd : commandList){ cmd.execute(); } } } 客户端类Julia public class Julia { public static void main(String[]args){ //创建接收者对象 AudioPlayer audioPlayer = new AudioPlayer(); //创建命令对象 Command playCommand = new PlayCommand(audioPlayer); Command rewindCommand = new RewindCommand(audioPlayer); Command stopCommand = new StopCommand(audioPlayer); MacroCommand marco = new MacroAudioCommand(); marco.add(playCommand); marco.add(rewindCommand); marco.add(stopCommand); marco.execute(); } } 这样执行MacroCommand 的execute()方法就会一次性执行多条命令。 五、命令模式的优缺点 优点 　　●　　更松散的耦合 　　命令模式使得发起命令的对象，和具体实现命令的对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。 　　●　　更动态的控制 　　命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。 　　●　　很自然的复合命令 　　命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。 　　●　　更好的扩展性 　　由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。 缺点 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Behavioral-Pattern/Iterator-Pattern.html":{"url":"design-mode/Behavioral-Pattern/Iterator-Pattern.html","title":"迭代器模式","keywords":"","body":"一、迭代器模式定义 迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。 二、迭代器模式结构 迭代器模式涉及到以下几个角色： 　　●　　抽象迭代器(Iterator)角色：此抽象角色定义出遍历元素所需的接口。 　　●　　具体迭代器(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。 　　●　　聚集(Aggregate)角色：此抽象角色给出创建迭代器(Iterator)对象的接口。 　　●　　具体聚集(ConcreteAggregate)角色：实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。 　　●　　客户端(Client)角色：持有对聚集及其迭代器对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。 抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代器模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代器对象的实例。 public abstract class Aggregate { /** * 工厂方法，创建相应迭代子对象的接口 */ public abstract Iterator createIterator(); } 具体聚集角色类，实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。 public class ConcreteAggregate extends Aggregate { private Object[] objArray = null; /** * 构造方法，传入聚合对象的具体内容 */ public ConcreteAggregate(Object[] objArray){ this.objArray = objArray; } @Override public Iterator createIterator() { return new ConcreteIterator(this); } /** * 取值方法：向外界提供聚集元素 */ public Object getElement(int index){ if(index 抽象迭代器角色类 public interface Iterator { /** * 迭代方法：移动到第一个元素 */ public void first(); /** * 迭代方法：移动到下一个元素 */ public void next(); /** * 迭代方法：是否为最后一个元素 */ public boolean isDone(); /** * 迭代方法：返还当前元素 */ public Object currentItem(); } 具体迭代器角色类 public class ConcreteIterator implements Iterator { //持有被迭代的具体的聚合对象 private ConcreteAggregate agg; //内部索引，记录当前迭代到的索引位置 private int index = 0; //记录当前聚集对象的大小 private int size = 0; public ConcreteIterator(ConcreteAggregate agg){ this.agg = agg; this.size = agg.size(); index = 0; } /** * 迭代方法：返还当前元素 */ @Override public Object currentItem() { return agg.getElement(index); } /** * 迭代方法：移动到第一个元素 */ @Override public void first() { index = 0; } /** * 迭代方法：是否为最后一个元素 */ @Override public boolean isDone() { return (index > = size); } /** * 迭代方法：移动到下一个元素 */ @Override public void next() { if(index 客户端类 public class Client { public void operation(){ Object[] objArray = {\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\"}; //创建聚合对象 Aggregate agg = new ConcreteAggregate(objArray); //循环输出聚合对象中的值 Iterator it = agg.createIterator(); while(!it.isDone()){ System.out.println(it.currentItem()); it.next(); } } public static void main(String[] args) { Client client = new Client(); client.operation(); } } 三、迭代器模式的应用 如果要问Java中使用最多的一种模式，答案不是单例模式，也不是工厂模式，更不是策略模式，而是迭代器模式，先来看一段代码吧： public static void print(Collection coll){ Iterator it = coll.iterator(); while(it.hasNext()){ String str = (String)it.next(); System.out.println(str); } } 这个方法的作用是循环打印一个字符串集合，里面就用到了迭代器模式，java语言已经完整地实现了迭代器模式，例如List，Set，Map，而迭代器的作用就是把容器中的对象一个一个地遍历出来。 四、迭代器模式的优缺点 优点 ①简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。 ②可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。 ③封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。 缺点 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。 五、迭代器的应用场景 迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。 但是，由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Behavioral-Pattern/Observer-Pattern.html":{"url":"design-mode/Behavioral-Pattern/Observer-Pattern.html","title":"观察者模式","keywords":"","body":"一、观察者模式的概念 观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 二、观察者模式的结构 一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。 同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。 下面以一个简单的示意性实现为例，讨论观察者模式的结构。 观察者模式所涉及的角色有： 　　●　　抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。 　　●　　具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。 　　●　　抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。 　　●　　具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 三、观察者模式的代码实现 抽象主题角色类(此处是抽象类，改成接口将会提高复用) public abstract class Subject { /** * 用来保存注册的观察者对象 */ private List list = new ArrayList (); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer){ list.add(observer); System.out.println(\"Attached an observer\"); } /** * 删除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer){ list.remove(observer); } /** * 通知所有注册的观察者对象 */ public void nodifyObservers(String newState){ for(Observer observer : list){ observer.update(newState); } } } 具体主题角色类 public class ConcreteSubject extends Subject{ private String state; public String getState() { return state; } public void change(String newState){ state = newState; System.out.println(\"主题状态为：\" + state); //状态发生改变，通知各个观察者 this.nodifyObservers(state); } } 抽象观察者角色类 public interface Observer { /** * 更新接口 * @param state 更新的状态 */ public void update(String state); } 具体观察者角色类 public class ConcreteObserver implements Observer { //观察者的状态 private String observerState; @Override public void update(String state) { /** * 更新观察者的状态，使其与目标的状态保持一致 */ observerState = state; System.out.println(\"状态为：\"+observerState); } } 具体使用： public class Client { public static void main(String[] args) { //创建主题对象 ConcreteSubject subject = new ConcreteSubject(); //创建观察者对象 Observer observer = new ConcreteObserver(); //将观察者对象登记到主题对象上 subject.attach(observer); //改变主题对象的状态 subject.change(\"new state\"); } } 当主题对象的状态改变时，将通知所有观察者，观察者接收到主题对象的通知后，将可以进行其他操作，进行响应。 四、推模型和拉模型 　在观察者模式中，又分为推模型和拉模型两种方式。 　　●　　推模型 　　　　 主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。 　　●　　拉模型 　　　　 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。 　　根据上面的描述，发现前面的例子就是典型的推模型，下面给出一个拉模型的实例。 拉模型的抽象观察者类 拉模型通常都是把主题对象当做参数传递。 public interface Observer { /** * 更新接口 * @param subject 传入主题对象，方面获取相应的主题对象的状态 */ public void update(Subject subject); } 拉模型的具体观察者类 public class ConcreteObserver implements Observer { //观察者的状态 private String observerState; @Override public void update(Subject subject) { /** * 更新观察者的状态，使其与目标的状态保持一致 */ observerState = ((ConcreteSubject)subject).getState(); System.out.println(\"观察者状态为：\"+observerState); } } 拉模型的抽象主题类拉模型的抽象主题类主要的改变是nodifyObservers()方法。在循环通知观察者的时候，也就是循环调用观察者的update()方法的时候，传入的参数不同了。 public abstract class Subject { /** * 用来保存注册的观察者对象 */ private List list = new ArrayList (); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer){ list.add(observer); System.out.println(\"Attached an observer\"); } /** * 删除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer){ list.remove(observer); } /** * 通知所有注册的观察者对象 */ public void nodifyObservers(){ for(Observer observer : list){ observer.update(this); } } } 拉模型的具体主题类跟推模型相比，有一点变化，就是调用通知观察者的方法的时候，不需要传入参数了。 public class ConcreteSubject extends Subject{ private String state; public String getState() { return state; } public void change(String newState){ state = newState; System.out.println(\"主题状态为：\" + state); //状态发生改变，通知各个观察者 this.nodifyObservers(); } } 两种模式的比较 　　■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 　　■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。 五、JAVA提供的对观察者模式的支持 在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。 Observer接口这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。 public interface Observer { void update(Observable o, Object arg); } Observable类被观察者类都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。 public class Observable { private boolean changed = false; private Vector obs; /** Construct an Observable with zero Observers. */ public Observable() { obs = new Vector(); } /** * 将一个观察者添加到观察者聚集上面 */ public synchronized void addObserver(Observer o) { if (o == null) throw new NullPointerException(); if (!obs.contains(o)) { obs.addElement(o); } } /** * 将一个观察者从观察者聚集上删除 */ public synchronized void deleteObserver(Observer o) { obs.removeElement(o); } public void notifyObservers() { notifyObservers(null); } /** * 如果本对象有变化（那时hasChanged 方法会返回true） * 调用本方法通知所有登记的观察者，即调用它们的update()方法 * 传入this和arg作为参数 */ public void notifyObservers(Object arg) { Object[] arrLocal; synchronized (this) { if (!changed) return; arrLocal = obs.toArray(); clearChanged(); } for (int i = arrLocal.length-1; i > =0; i--) ((Observer)arrLocal[i]).update(this, arg); } /** * 将观察者聚集清空 */ public synchronized void deleteObservers() { obs.removeAllElements(); } /** * 将“已变化”设置为true */ protected synchronized void setChanged() { changed = true; } /** * 将“已变化”重置为false */ protected synchronized void clearChanged() { changed = false; } /** * 检测本对象是否已变化 */ public synchronized boolean hasChanged() { return changed; } /** * Returns the number of observers of this Observable object. * * @return the number of observers of this object. */ public synchronized int countObservers() { return obs.size(); } } 这个类代表一个被观察者对象，有时称之为主题对象。一个被观察者对象可以有数个观察者对象，每个观察者对象都是实现Observer接口的对象。在被观察者发生变化时，会调用Observable的notifyObservers()方法，此方法调用所有的具体观察者的update()方法，从而使所有的观察者都被通知更新自己。 使用JAVA对观察者模式的支持 这里给出一个非常简单的例子，说明怎样使用JAVA所提供的对观察者模式的支持。在这个例子中，被观察对象叫做Watched；而观察者对象叫做Watcher。Watched对象继承自java.util.Observable类；而Watcher对象实现了java.util.Observer接口。另外有一个Test类扮演客户端角色。被观察者Watched类 public class Watched extends Observable{ private String data = \"\"; public String getData() { return data; } public void setData(String data) { if(!this.data.equals(data)){ this.data = data; setChanged(); notifyObservers(); } } } 观察者Watcher 类 public class Watcher implements Observer{ public Watcher(Observable o){ o.addObserver(this); } @Override public void update(Observable o, Object arg) { System.out.println(\"状态发生改变：\" + ((Watched)o).getData()); } } 具体使用： public static void main(String[] args) { //创建被观察者对象 Watched watched = new Watched(); //创建观察者对象，并将被观察者对象登记 Observer watcher = new Watcher(watched); //给被观察者状态赋值 watched.setData(\"start\"); watched.setData(\"run\"); watched.setData(\"stop\"); } 总结： 观察者模式一般是一对多的情形，本文中篇幅有限，都是一对一的例子。当一对多时，通过Java内置的观察者模式时，通知多个观察者的顺序不是固定的。所以如果依赖此顺序的话，要自己实现观察者模式。同时Java内置的观察者模式中，Observerable是个类，所以在子类继承了该类后就不能继承其他类，导致复用受到限制，自己实现观察者模式时可以设置为接口，提高复用。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Behavioral-Pattern/Strategy-Pattern.html":{"url":"design-mode/Behavioral-Pattern/Strategy-Pattern.html","title":"策略模式","keywords":"","body":"一、策略模式的简介 1.定义 策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 2.使用场景 针对一个对象，其行为有些是固定的不变的，有些是容易变化的，针对不同情况有不同的表现形式。那么对于这些容易变化的行为，我们不希望将其实现绑定在对象中，而是希望以动态的形式，针对不同情况产生不同的应对策略。那么这个时候就要用到策略模式了。简言之，策略模式就是为了应对对象中复杂多变的行为而产生的。 二、策略模式的结构 策略模式是对算法的包装，是把调用算法的责任（行为）和算法本身（行为实现）分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。 　　这个模式涉及到三个角色： 　　●　　环境(Context)角色：持有一个Strategy的引用，即具有复杂多变行为的对象。 　　●　　抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 　　●　　具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 三、具体场景实现 假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。 　　根据描述，折扣是根据以下的几个算法中的一个进行的： 　　算法一：对初级会员没有折扣。 　　算法二：对中级会员提供10%的促销折扣。 　　算法三：对高级会员提供20%的促销折扣。 　　使用策略模式来实现的结构图如下： 抽象折扣类 public interface MemberStrategy { /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double calcPrice(double booksPrice); } 初级会员折扣类 public class PrimaryMemberStrategy implements MemberStrategy { @Override public double calcPrice(double booksPrice) { System.out.println(\"对于初级会员的没有折扣\"); return booksPrice; } } 中级会员折扣类 public class IntermediateMemberStrategy implements MemberStrategy { @Override public double calcPrice(double booksPrice) { System.out.println(\"对于中级会员的折扣为10%\"); return booksPrice * 0.9; } } 高级会员折扣类 public class AdvancedMemberStrategy implements MemberStrategy { @Override public double calcPrice(double booksPrice) { System.out.println(\"对于高级会员的折扣为20%\"); return booksPrice * 0.8; } } 价格类 public class Price { //持有一个具体的策略对象 private MemberStrategy strategy; /** * 构造函数，传入一个具体的策略对象 * @param strategy 具体的策略对象 */ public Price(MemberStrategy strategy){ this.strategy = strategy; } /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double quote(double booksPrice){ return this.strategy.calcPrice(booksPrice); } } 具体调用： public static void main(String[] args) { //选择并创建需要使用的策略对象 MemberStrategy strategy = new AdvancedMemberStrategy(); //创建环境 Price price = new Price(strategy); //计算价格 double quote = price.quote(300); System.out.println(\"图书的最终价格为：\" + quote); } 四、对策略模式的深入认识 策略模式对多态的使用 　　通过让环境类持有一个抽象策略类（超类）的引用，在生成环境类实例对象时，让该引用指向具体的策略子类。再对应的方法调用中，就会通过Java的多态，调用对应策略子类的方法。从而可以相互替换，不需要修改环境类内部的实现。同时，在有新的需求的情况下，也只需要修改策略类即可，降低与环境类之间的耦合度。 策略模式的重心 　　策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。 算法的平等性 　　策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。 　　所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。 运行时策略的唯一性 　　运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。 公有的行为 　　经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。 　　这其实也是典型的将代码向继承等级结构的上方集中的标准做法。 五、策略模式的优缺点 策略模式的优点　　（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 　　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 策略模式的缺点　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"design-mode/Behavioral-Pattern/Template-Method.html":{"url":"design-mode/Behavioral-Pattern/Template-Method.html","title":"模板方法模式","keywords":"","body":"一、模版方法模式的定义 模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 二、模版方法模式的结构 模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。 模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。 模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示： 这里涉及到两个角色： 抽象模板(Abstract Template)角色有如下责任： ■　　定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 ■　　定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色又如下责任： ■　　实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 ■　　每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 抽象模板角色类，abstractMethod()、hookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由templateMethod()方法代表。 public abstract class AbstractTemplate { /** * 模板方法 */ public void templateMethod(){ //调用基本方法 abstractMethod(); hookMethod(); concreteMethod(); } /** * 基本方法的声明（由子类实现） */ protected abstract void abstractMethod(); /** * 基本方法(空方法) */ protected void hookMethod(){} /** * 基本方法（已经实现） */ private final void concreteMethod(){ //业务相关的代码 } } 具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而hookMethod()方法是可选择实现的逻辑，不是必须实现的。 public class ConcreteTemplate extends AbstractTemplate{ //基本方法的实现 @Override public void abstractMethod() { //业务相关的代码 } //重写父类的方法 @Override public void hookMethod() { //业务相关的代码 } } 模板模式的关键是：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。 每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。 三、模板方法模式中的方法 模板方法中的方法可以分为两大类：模板方法和基本方法。 模板方法 一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。 一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。 基本方法 基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。 ●　　抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。 ●　　具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。 ●　　钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。 在上面的例子中，AbstractTemplate是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。 默认钩子方法 一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。具体模版类中可以选择是否重写钩子方法，通常重写钩子方法是为了对模版方法中的步骤进行控制，判断钩子方法中的状态，是否进行下一步操作。 四、模版方法的具体实例 考虑一个计算存款利息的例子。假设系统需要支持两种存款账号，即货币市场(Money Market)账号和定期存款(Certificate of Deposite)账号。这两种账号的存款利息是不同的，因此，在计算一个存户的存款利息额时，必须区分两种不同的账号类型。 这个系统的总行为应当是计算出利息，这也就决定了作为一个模板方法模式的顶级逻辑应当是利息计算。由于利息计算涉及到两个步骤：一个基本方法给出账号种类，另一个基本方法给出利息百分比。这两个基本方法构成具体逻辑，因为账号的类型不同，所以具体逻辑会有所不同。 显然，系统需要一个抽象角色给出顶级行为的实现，而将两个作为细节步骤的基本方法留给具体子类实现。由于需要考虑的账号有两种：一是货币市场账号，二是定期存款账号。系统的类结构如下图所示。 抽象模板角色类 public abstract class Account { /** * 模板方法，计算利息数额 * @return 返回利息数额 */ public final double calculateInterest(){ double interestRate = doCalculateInterestRate(); String accountType = doCalculateAccountType(); double amount = calculateAmount(accountType); return amount * interestRate; } /** * 基本方法留给子类实现 */ protected abstract String doCalculateAccountType(); /** * 基本方法留给子类实现 */ protected abstract double doCalculateInterestRate(); /** * 基本方法，已经实现 */ private double calculateAmount(String accountType){ /** * 省略相关的业务逻辑 */ return 7243.00; } } 具体模板角色类 public class MoneyMarketAccount extends Account { @Override protected String doCalculateAccountType() { return \"Money Market\"; } @Override protected double doCalculateInterestRate() { return 0.045; } } public class CDAccount extends Account { @Override protected String doCalculateAccountType() { return \"Certificate of Deposite\"; } @Override protected double doCalculateInterestRate() { return 0.06; } } 客户端类 public class Client { public static void main(String[] args) { Account account = new MoneyMarketAccount(); System.out.println(\"货币市场账号的利息数额为：\" + account.calculateInterest()); account = new CDAccount(); System.out.println(\"定期账号的利息数额为：\" + account.calculateInterest()); } } 五、模板方法模式效果与适用场景 模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化，测试流程的设置等）。 在以下情况下可以考虑使用模板方法模式： (1) 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。 (2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。 (3) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。 六、模版方法模式的优缺点 优点 (1) 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 (2) 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。 (3) 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 (4) 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。 缺点 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"computer-networks/tcpip.html":{"url":"computer-networks/tcpip.html","title":"TCP/IP","keywords":"","body":" 一、TCP/IP模型 TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。 基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。 TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp，等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。 上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。 上图以HTTP协议为例，具体说明。 二、数据链路层 物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点，这些节点是通过MAC来唯一标识的(MAC，物理地址，一个主机会有一个MAC地址)。 封装成帧：把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。 透明传输：零比特填充、转义字符。 可靠传输：在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。 差错检测(CRC)：接收者检测错误,如果发现差错，丢弃该帧。 三、网络层 1.IP协议 IP协议是TCP/IP协议的核心，所有的TCP，UDP，ICMP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议——TCP或UDP要做的事情。 1.1 IP地址 在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。 32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。 A类IP地址：1.0.0.0~127.0.0.0 B类IP地址：128.0.0.0~191.255.255.255 C类IP地址：192.0.0.0~223.255.255.255 1.2 IP协议头 这里只介绍：八位的TTL（Time To Live）字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。 这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。 2.ARP及RARP协议 ARP 是根据IP地址获取MAC地址的一种协议。 ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。 如果查询的IP-MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址。如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。 而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。 RARP协议的工作与此相反，不做赘述。 3. ICMP协议 IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。 当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。 四、ping ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。 例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下: ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。 ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。 五、Traceroute Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。 Traceroute的原理非常非常有意思。它收到到目的主机的IP后，首先给目的主机发送一个TTL=1（Time To Live）的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。 六、TCP/UDP TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。 面向报文 面向报文的传输方式是应用层交给UDP多长的报文，UDP发送多长的报文，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率；若太短，会使IP数据报太小。 面向字节流 面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。 关于拥塞控制，流量控制，是TCP的重点，后面讲解。 TCP和UDP协议的一些应用 什么时候应该使用TCP？ 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 什么时候应该使用UDP？ 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 七、DNS DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。 八、TCP连接的建立与终止 1.三次握手 TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 回合 说明 第一次握手 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x + 1(Sequence Number + 1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y + 1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手？ 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 具体例子——“已失效的连接请求报文段”的产生在这样一种情况下： client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。 例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 2.四次挥手 当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 回合 说明 第一次分手 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为 Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL（MSL：Maximum Segment Lifetime，报文段最大生存时间，详情请见下文介绍）后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次分手？ TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 为什么要等待2MSL？ MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。原因有二： 保证TCP协议的全双工连接能够可靠关闭 保证这次连接的重复数据段从网络中消失 第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT状态。当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。 第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中（称为Lost Duplicate），这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接要在TIME_WAIT状态等待2倍MSL，保证本次连接的所有数据都从网络中消失。 九、TCP流量控制 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。 设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。 从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。 TCP为每一个连接设有一个持续计时器(persistence timer)。当TCP连接中的发送方收到接收方的零窗口通知时，发送方就启动持续计时器。若持续计时器设置的时间到期，发送方就发送一个零窗口控测报文段（携1字节的数据）给接收方。如果接收方可以接收数据，就重新开始发送数据；如果接收方不能接收数据，就重新设置持续计时器。 十、TCP拥塞控制 1.慢开始和拥塞避免 发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 慢开始算法： 当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。 因此，较好的方法是，先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。 通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS（Maximum Segment Size，最大报文长度）的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值（底数为2的指数增长规律）。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。 每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 一个传输轮次所经历的时间其实就是往返时间RTT。 不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。 另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下： 当 cwnd 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。 拥塞避免 让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性增长规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。 这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。 如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。 2.快重传和快恢复 快重传 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。 接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。 显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。 但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。 快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。 由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。 快恢复 与快重传配合使用的还有快恢复算法，其过程有以下两个要点： 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。 与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"computer-networks/http.html":{"url":"computer-networks/http.html","title":"HTTP","keywords":"","body":"一、 HTTP请求和响应步骤 以上完整表示了HTTP请求和响应的7个步骤，下面从TCP/IP协议模型的角度来理解HTTP请求和响应如何传递的。 二、TCP/IP协议 TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。 HTTP协议就是基于TCP/IP协议模型来传输信息的。 (1). 链路层 也称作数据链路层或网络接口层（在第一个图中为网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。 (2). 网络层 也称作互联网层（在第一个图中为网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。 IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。 ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。 IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。 (3). 传输层 主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。 TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。 UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。 (4). 应用层 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务。 当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。 当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源I P地址和源端口号进行解包的。 通过以上步骤我们从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程。 下面这张图更清楚明白： 下面具体来看如何进行一步步操作的。 三、TCP三次握手 TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 回合 说明 第一次握手 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x + 1(Sequence Number + 1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN + ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手 客户端收到服务器的SYN + ACK报文段。然后将Acknowledgment Number设置为y + 1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 具体例子： ——“已失效的连接请求报文段”的产生在这样一种情况下： client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。 例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 四、HTTP协议 Http是什么？ 通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。 四个基于： 请求与响应： 客户端发送请求，服务器端响应数据 无状态的： 协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。 应用层： Http是属于应用层的协议，配合TCP/IP使用。 TCP/IP： Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。 针对无状态的一些解决策略： 有时需要对用户之前的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。于是引入了Cookie技术。 HTTP/1.1想出了持久连接（HTTP keep-alive）方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。等等还有很多…… 下面开始讲解重头戏：HTTP请求报文，响应报文，对应于上述步骤的2，3，4，5，6。 HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。 五、HTTP请求报文 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 1.请求行 请求行分为三个部分：请求方法、请求地址和协议版本 请求方法 HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。 请求地址 URL：统一资源定位符，是一种自愿位置的抽象唯一识别方法。 组成：：//：/ 端口和路径有时可以省略（HTTP默认端口号是80） 如下例： 有时会带参数，GET请求 协议版本 协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1 2.请求头部 请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。 常见请求头如下： 请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。 3.请求数据 可选部分，比如GET请求就没有请求数据。 下面是一个POST方法的请求报文： POST 　/index.php　HTTP/1.1 　　 请求行Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveReferer:http://localhost/Content-Length：25Content-Type：application/x-www-form-urlencoded　　空行username=aa&password=1234　　请求数据 六、HTTP响应报文 HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。 1.状态行 由3部分组成，分别为：协议版本，状态码，状态码描述。 其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。 状态码 状态代码为3位数字。 1xx：指示信息——表示请求已接收，继续处理。 2xx：成功——表示请求已被成功接收、理解、接受。 3xx：重定向——要完成请求必须进行更进一步的操作。 4xx：客户端错误——请求有语法错误或请求无法实现。 5xx：服务器端错误——服务器未能实现合法的请求。 下面列举几个常见的： 2.响应头部 与请求头部类似，为响应报文添加了一些附加信息 常见响应头部如下： 3.响应数据 用于存放需要返回给客户端的数据信息。 下面是一个响应报文的实例： HTTP/1.1 200 OK　　状态行Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部Server: Apache/2.2.8 (Win32) PHP/5.2.5X-Powered-By: PHP/5.2.5Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheContent-Length: 4393Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/html; charset=utf-8　　空行 　　响应数据HTTP响应示例Hello HTTP! 关于请求头部和响应头部的知识点很多，这里只是简单介绍。 通过以上步骤，数据已经传递完毕，HTTP/1.1会维持持久连接，但持续一段时间总会有关闭连接的时候，这时候据需要断开TCP连接。 七、TCP四次挥手 当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 回合 说明 第一次分手 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次分手 TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 通过以上步骤便完成了HTTP的请求和响应，进行了数据传递，这其中涉及到需要知识点，都进行了逐一了解。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"computer-networks/https.html":{"url":"computer-networks/https.html","title":"HTTPS","keywords":"","body":"我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 HTTPS简介 HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。 1. 客户端发起HTTPS请求 这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 2. 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 3. 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 4. 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 5. 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6. 服务段加密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7. 传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原 8. 客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"operating-system/summarize.html":{"url":"operating-system/summarize.html","title":"概述","keywords":"","body":" 操作系统这一块内容比较晦涩枯燥，如果系统学起来需要耗费很长时间。针对于面试，本章内容整理了一些面试重难点问题，大致分为3块内容，18个问题。 一、操作系统知识点图谱 二、面试问题总结 操作系统的四个特性。 操作系统的主要功能。 进程的有哪几种状态，状态转换图，及导致转换的事件。 进程与线程的区别。 进程通信的几种方式。 进程同步的几种方式 用户态和核心态的区别。 死锁的概念，导致死锁的原因. 导致死锁的四个必要条件。 处理死锁的四个方式。 预防死锁的方法、避免死锁的方法。 进程调度算法。 内存连续分配方式采用的几种算法及各自优劣。 基本分页储存管理方式。 基本分段储存管理方式。 分段分页方式的比较各自优缺点。 几种页面置换算法，会算所需换页数 虚拟内存的定义及实现方式。 三、 概述 1.操作系统的四个特性 并发： 同一段时间内多个程序执行(注意区别并行和并发，前者是同一时刻的多个事件，后者是同一时间段内的多个事件) 共享： 系统中的资源可以被内存中多个并发执行的进线程共同使用 虚拟： 通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个 异步： 系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进 2.操作系统的主要功能 处理机管理： 处理机分配都是以进程为单位，所以处理机管理也被看做是进程管理。包括进程控制，进程同步，进程通信和进程调度 存储器管理（或者内存管理）： 内存分配，内存保护，地址映射，内存扩充 设备管理： 管理所有外围设备，包括完成用户的IO请求；为用户进程分配IO设备；提高IO设备利用率；提高IO速度；方便IO的使用 文件管理： 管理用户文件和系统文件，方便使用同时保证安全性。包括：磁盘存储空间管理，目录管理，文件读写管理以及文件共享和保护 提供用户接口： 程序接口（如API）和用户接口（如GUI） Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"operating-system/process-thread.html":{"url":"operating-system/process-thread.html","title":"进程与线程","keywords":"","body":"一、进程的状态与转换 运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。 注意区别就绪状态和等待状态： 就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。 就绪状态 -> 运行状态： 处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。 运行状态 -> 就绪状态： 处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。 运行状态 -> 阻塞状态： 当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。 阻塞状态 -> 就绪状态： 当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。 二、进程与线程的区别 进程： 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位（具有动态、并发、独立、异步的特性，以及就绪、执行、阻塞3种状态）；引入进程是为了使多个程序可以并发的执行，以提高系统的资源利用率和吞吐量。 线程： 是比进程更小的可独立运行的基本单位，可以看做是轻量级的进程（具有轻型实体，独立调度分派单位，可并发执行，共享进程资源等属性）；引入目的是为了减少程序在并发执行过程中的开销，使OS的并发效率更高。 两者的对比： 调度方面：在引入线程的OS中，线程是独立的调度和分派单位，而进程作为资源的拥有单位(相当于把未引入线程的传统OS中的进程的两个属性分开了)。由于线程不拥有资源，因此可以显著的提高并发度以及减少切换开销。 并发性：引入了线程的OS中，进程间可以并发，而且一个进程内部的多个线程之间也是可以并发的，这就使OS具有更好的并发性，有效的提高了系统资源利用率和吞吐量。 拥有资源：无论OS是否支持线程，进程都是基本的资源拥有单位，线程只拥有很少的基本的资源，但是线程可以访问所隶属的进程的资源（进程的代码段，数据段和所拥有的系统资源如fd） 系统开销：创建或者撤销进程的时候，系统要为之创建或回收PCB，系统资源等，切换时也需要保存和恢复CPU环境。而线程的切换只需要保存和恢复少量的寄存器，不涉及存储器管理方面的工作，所以开销较小。此外，统一进程中的多个线程由于共享地址空间，所以通信同步等都比较方便。 三、进程通信 进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。 共享存储 在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。 需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。 消息传递 在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。 1) 直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。 2) 间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。 管道通信 管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。 四、进程同步 多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性 同步机制需要遵循的原则： 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等 让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等 经典的进程同步问题：生产者-消费者问题；哲学家进餐问题；读者-写者问题 同步的解决方案：管程，信号量。 五、用户态和核心态 当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态； 反之，当程序运行在级特权级上时，就可以称之为运行在内核态。 虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。 当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。 用户态切换到内核态的3种方式 1) 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 2) 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 3) 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 六、死锁 死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。 死锁原因： 竞争资源：请求同一有限资源的进程数多于可用资源数 进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链 死锁产生的必要条件： 互斥条件:进程对所分配的资源进行排他性的使用 请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源 不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺 环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链 死锁处理： 预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量 避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大 七、进程调度算法 先来先服务调度算法FCFS： 既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利； 短作业优先调度算法SJF： 作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ； 高响应比算法HRN： 响应比=(等待时间+要求服务时间)/要求服务时间； 时间片轮转调度RR： 按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ; 多级反馈队列调度算法： 目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部……只有当前一个队列为空的时候才会去调度下一个队列的进程。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "},"operating-system/memory-management.html":{"url":"operating-system/memory-management.html","title":"内存管理","keywords":"","body":"一、内存连续分配 主要是指动态分区分配时所采用的几种算法。 动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。 首次适应(First Fit)算法： 空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。 最佳适应(Best Fit)算法： 空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 最坏适应(Worst Fit)算法： 又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。 二、基本分页储存管理方式 把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。 因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。 由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。 为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。 在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用两级页表或者多级页表的方法，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。 三、基本分段储存管理方式 分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。 分段内存管理当中，地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。 访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了联想寄存器。 分段分页方式的比较 页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制 页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定 四、虚拟内存 如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。但是可以从逻辑的角度扩充内存容量，即可解决上述两种问题。 基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。 虚拟存储器的特征： 多次性：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性 对换性：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据) 虚拟性：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上。 五、页面置换算法 最佳置换算法： 只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。 先进先出置换算法： 简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。 最近最久未使用算法LRU： 算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。 时钟算法clock(也被称为是最近未使用算法NRU)： 页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。 改进型Clock算法： 在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。 最少使用算法LFU： 设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。 Copyright © github.com/zxpei 2019 all right reserved，powered by GitbookModification Time： 2018-05-12 09:48:13 "}}